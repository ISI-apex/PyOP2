<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>PyOP2 Kernels &mdash; PyOP2 0.10.0 documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.10.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="PyOP2 0.10.0 documentation" href="index.html" />
    <link rel="next" title="PyOP2 Architecture" href="architecture.html" />
    <link rel="prev" title="PyOP2 Concepts" href="concepts.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="architecture.html" title="PyOP2 Architecture"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="concepts.html" title="PyOP2 Concepts"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">PyOP2 0.10.0 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="pyop2-kernels">
<span id="kernels"></span><h1>PyOP2 Kernels<a class="headerlink" href="#pyop2-kernels" title="Permalink to this headline">¶</a></h1>
<p>Kernels in PyOP2 define the local operations that are to be performed for each
element of the iteration set the kernel is executed over. There must be a one
to one match between the arguments declared in the kernel signature and the
actual arguments passed to the parallel loop executing this kernel. As
described in <a class="reference internal" href="concepts.html"><em>PyOP2 Concepts</em></a>, data is accessed directly on the iteration set
or via mappings passed in the <a class="reference internal" href="user.html#pyop2.par_loop" title="pyop2.par_loop"><tt class="xref py py-func docutils literal"><span class="pre">par_loop()</span></tt></a> call.</p>
<p>The kernel only sees data corresponding to the current element of the
iteration set it is invoked for. Any data read by the kernel i.e. accessed as
<a class="reference internal" href="user.html#pyop2.READ" title="pyop2.READ"><tt class="xref py py-data docutils literal"><span class="pre">READ</span></tt></a>, <a class="reference internal" href="user.html#pyop2.RW" title="pyop2.RW"><tt class="xref py py-data docutils literal"><span class="pre">RW</span></tt></a> or <a class="reference internal" href="user.html#pyop2.INC" title="pyop2.INC"><tt class="xref py py-data docutils literal"><span class="pre">INC</span></tt></a> is automatically
gathered via the mapping relationship in the <em>staging in</em> phase and the kernel
is passed pointers to the staging memory. Similarly, after the kernel has been
invoked, any modified data i.e. accessed as <a class="reference internal" href="user.html#pyop2.WRITE" title="pyop2.WRITE"><tt class="xref py py-data docutils literal"><span class="pre">WRITE</span></tt></a>,
<a class="reference internal" href="user.html#pyop2.RW" title="pyop2.RW"><tt class="xref py py-data docutils literal"><span class="pre">RW</span></tt></a> or <a class="reference internal" href="user.html#pyop2.INC" title="pyop2.INC"><tt class="xref py py-data docutils literal"><span class="pre">INC</span></tt></a> is scattered back out via the
<a class="reference internal" href="user.html#pyop2.Map" title="pyop2.Map"><tt class="xref py py-class docutils literal"><span class="pre">Map</span></tt></a> in the <em>staging out</em> phase. It is only safe for a kernel
to manipulate data in the way declared via the access descriptor in the
parallel loop call. Any modifications to an argument accessed read-only would
not be written back since the staging out phase is skipped for this argument.
Similarly, the result of reading an argument declared as write-only is
undefined since the data has not been staged in.</p>
<div class="section" id="kernel-api">
<span id="id1"></span><h2>Kernel API<a class="headerlink" href="#kernel-api" title="Permalink to this headline">¶</a></h2>
<p>Consider a <a class="reference internal" href="user.html#pyop2.par_loop" title="pyop2.par_loop"><tt class="xref py py-func docutils literal"><span class="pre">par_loop()</span></tt></a> computing the midpoint of a triangle given
the three vertex coordinates. Note that we make use of a covenience in the
PyOP2 syntax, which allow declaring an anonymous <a class="reference internal" href="user.html#pyop2.DataSet" title="pyop2.DataSet"><tt class="xref py py-class docutils literal"><span class="pre">DataSet</span></tt></a> of a
dimension greater one by using the <tt class="docutils literal"><span class="pre">**</span></tt> operator. We omit the actual data in
the declaration of the <a class="reference internal" href="user.html#pyop2.Map" title="pyop2.Map"><tt class="xref py py-class docutils literal"><span class="pre">Map</span></tt></a> <tt class="docutils literal"><span class="pre">cell2vertex</span></tt> and
<a class="reference internal" href="user.html#pyop2.Dat" title="pyop2.Dat"><tt class="xref py py-class docutils literal"><span class="pre">Dat</span></tt></a> <tt class="docutils literal"><span class="pre">coordinates</span></tt>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">vertices</span> <span class="o">=</span> <span class="n">op2</span><span class="o">.</span><span class="n">Set</span><span class="p">(</span><span class="n">num_vertices</span><span class="p">)</span>
<span class="n">cells</span> <span class="o">=</span> <span class="n">op2</span><span class="o">.</span><span class="n">Set</span><span class="p">(</span><span class="n">num_cells</span><span class="p">)</span>

<span class="n">cell2vertex</span> <span class="o">=</span> <span class="n">op2</span><span class="o">.</span><span class="n">Map</span><span class="p">(</span><span class="n">cells</span><span class="p">,</span> <span class="n">vertices</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="p">[</span><span class="o">...</span><span class="p">])</span>

<span class="n">coordinates</span> <span class="o">=</span> <span class="n">op2</span><span class="o">.</span><span class="n">Dat</span><span class="p">(</span><span class="n">vertices</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="o">...</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
<span class="n">midpoints</span> <span class="o">=</span> <span class="n">op2</span><span class="o">.</span><span class="n">Dat</span><span class="p">(</span><span class="n">cells</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

<span class="n">op2</span><span class="o">.</span><span class="n">par_loop</span><span class="p">(</span><span class="n">midpoint</span><span class="p">,</span> <span class="n">cells</span><span class="p">,</span>
             <span class="n">midpoints</span><span class="p">(</span><span class="n">op2</span><span class="o">.</span><span class="n">WRITE</span><span class="p">),</span>
             <span class="n">coordinates</span><span class="p">(</span><span class="n">op2</span><span class="o">.</span><span class="n">READ</span><span class="p">,</span> <span class="n">cell2vertex</span><span class="p">))</span>
</pre></div>
</div>
<p>Kernels are implemented in a restricted subset of C99 and are declared by
passing a <em>C code string</em> and the <em>kernel function name</em>, which must match the
name in the C kernel signature, to the <a class="reference internal" href="user.html#pyop2.Kernel" title="pyop2.Kernel"><tt class="xref py py-class docutils literal"><span class="pre">Kernel</span></tt></a> constructor:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">midpoint</span> <span class="o">=</span> <span class="n">op2</span><span class="o">.</span><span class="n">Kernel</span><span class="p">(</span><span class="s">&quot;&quot;&quot;</span>
<span class="s">void midpoint(double p[2], double *coords[2]) {</span>
<span class="s">  p[0] = (coords[0][0] + coords[1][0] + coords[2][0]) / 3.0;</span>
<span class="s">  p[1] = (coords[0][1] + coords[1][1] + coords[2][1]) / 3.0;</span>
<span class="s">}&quot;&quot;&quot;</span><span class="p">,</span> <span class="s">&quot;midpoint&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Since kernels cannot return any value, the return type is always <tt class="docutils literal"><span class="pre">void</span></tt>. The
kernel argument <tt class="docutils literal"><span class="pre">p</span></tt> corresponds to the third <a class="reference internal" href="user.html#pyop2.par_loop" title="pyop2.par_loop"><tt class="xref py py-func docutils literal"><span class="pre">par_loop()</span></tt></a>
argument <tt class="docutils literal"><span class="pre">midpoints</span></tt> and <tt class="docutils literal"><span class="pre">coords</span></tt> to the fourth argument <tt class="docutils literal"><span class="pre">coordinates</span></tt>
respectively. Argument names need not agree, the matching is by position.</p>
<p>Data types of kernel arguments must match the type of data passed to the
parallel loop. The Python types <tt class="xref py py-class docutils literal"><span class="pre">float</span></tt> and <tt class="xref py py-class docutils literal"><span class="pre">numpy.float64</span></tt>
correspond to a C <tt class="xref py py-class docutils literal"><span class="pre">double</span></tt>, <tt class="xref py py-class docutils literal"><span class="pre">numpy.float32</span></tt> to a C
<tt class="xref py py-class docutils literal"><span class="pre">float</span></tt>, <tt class="xref py py-class docutils literal"><span class="pre">int</span></tt> or <tt class="xref py py-class docutils literal"><span class="pre">numpy.int64</span></tt> to a C <tt class="xref py py-class docutils literal"><span class="pre">long</span></tt> and
<tt class="xref py py-class docutils literal"><span class="pre">numpy.int32</span></tt> to a C <tt class="xref py py-class docutils literal"><span class="pre">int</span></tt>.</p>
<p>Direct <a class="reference internal" href="user.html#pyop2.par_loop" title="pyop2.par_loop"><tt class="xref py py-func docutils literal"><span class="pre">par_loop()</span></tt></a> arguments such as <tt class="docutils literal"><span class="pre">midpoints</span></tt> are passed to
the kernel as a <tt class="docutils literal"><span class="pre">double</span> <span class="pre">*</span></tt>, indirect arguments such as <tt class="docutils literal"><span class="pre">coordinates</span></tt> as a
<tt class="docutils literal"><span class="pre">double</span> <span class="pre">**</span></tt> with the first indirection due to the map and the second
indirection due the data dimension. The kernel signature above uses arrays
with explicit sizes to draw attention to the fact that these are known. We
could have interchangibly used a kernel signature with plain pointers:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="kt">void</span> <span class="n">midpoint</span><span class="p">(</span><span class="kt">double</span> <span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="kt">double</span> <span class="o">**</span> <span class="n">coords</span><span class="p">)</span>
</pre></div>
</div>
<p>Argument creation supports an optional flag <tt class="docutils literal"><span class="pre">flatten</span></tt>, which is used
for kernels which expect data to be laid out by component:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">midpoint</span> <span class="o">=</span> <span class="n">op2</span><span class="o">.</span><span class="n">Kernel</span><span class="p">(</span><span class="s">&quot;&quot;&quot;</span>
<span class="s">void midpoint(double p[2], double *coords[1]) {</span>
<span class="s">  p[0] = (coords[0][0] + coords[1][0] + coords[2][0]) / 3.0;</span>
<span class="s">  p[1] = (coords[3][0] + coords[4][0] + coords[5][0]) / 3.0;</span>
<span class="s">}&quot;&quot;&quot;</span><span class="p">,</span> <span class="s">&quot;midpoint&quot;</span><span class="p">)</span>

<span class="n">op2</span><span class="o">.</span><span class="n">par_loop</span><span class="p">(</span><span class="n">midpoint</span><span class="p">,</span> <span class="n">cells</span><span class="p">,</span>
             <span class="n">midpoints</span><span class="p">(</span><span class="n">op2</span><span class="o">.</span><span class="n">WRITE</span><span class="p">),</span>
             <span class="n">coordinates</span><span class="p">(</span><span class="n">op2</span><span class="o">.</span><span class="n">READ</span><span class="p">,</span> <span class="n">cell2vertex</span><span class="p">,</span> <span class="n">flatten</span><span class="o">=</span><span class="bp">True</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="section" id="data-layout">
<span id="id2"></span><h2>Data layout<a class="headerlink" href="#data-layout" title="Permalink to this headline">¶</a></h2>
<p>Data for a <a class="reference internal" href="user.html#pyop2.Dat" title="pyop2.Dat"><tt class="xref py py-class docutils literal"><span class="pre">Dat</span></tt></a> declared on a <a class="reference internal" href="user.html#pyop2.Set" title="pyop2.Set"><tt class="xref py py-class docutils literal"><span class="pre">Set</span></tt></a> is
stored contiguously for all elements of the set. For each element,
this is a contiguous chunk of data of a shape given by the
<a class="reference internal" href="user.html#pyop2.DataSet" title="pyop2.DataSet"><tt class="xref py py-class docutils literal"><span class="pre">DataSet</span></tt></a> <tt class="docutils literal"><span class="pre">dim</span></tt> and the datatype of the
<a class="reference internal" href="user.html#pyop2.Dat" title="pyop2.Dat"><tt class="xref py py-class docutils literal"><span class="pre">Dat</span></tt></a>.  The size of this chunk is the product of the
extents of the <tt class="docutils literal"><span class="pre">dim</span></tt> tuple times the size of the datatype.</p>
<p>During execution of the <a class="reference internal" href="user.html#pyop2.par_loop" title="pyop2.par_loop"><tt class="xref py py-func docutils literal"><span class="pre">par_loop()</span></tt></a>, the kernel is called
for each element of the iteration set and passed data for each of its
arguments corresponding to the current set element <tt class="docutils literal"><span class="pre">i</span></tt> only.</p>
<p>For a directly accessed argument such as <tt class="docutils literal"><span class="pre">midpoints</span></tt> above, the
kernel is passed a pointer to the beginning of the chunk of data for
the element <tt class="docutils literal"><span class="pre">i</span></tt> the kernel is currently called for. In CUDA/OpenCL
<tt class="docutils literal"><span class="pre">i</span></tt> is the global thread id since the kernel is launched in parallel
for all elements.</p>
<div class="figure align-center">
<img src="_images/direct_arg.svg" /><p class="caption">Data layout for a directly accessed <a class="reference internal" href="user.html#pyop2.Dat" title="pyop2.Dat"><tt class="xref py py-class docutils literal"><span class="pre">Dat</span></tt></a> argument with
<tt class="docutils literal"><span class="pre">dim</span></tt> 2</p>
</div>
<p>For an indirectly accessed argument such as <tt class="docutils literal"><span class="pre">coordinates</span></tt> above,
PyOP2 gathers pointers to the data via the <a class="reference internal" href="user.html#pyop2.Map" title="pyop2.Map"><tt class="xref py py-class docutils literal"><span class="pre">Map</span></tt></a>
<tt class="docutils literal"><span class="pre">cell2vertex</span></tt> used for the indirection. The kernel is passed a list
of pointers of length corresponding to the <em>arity</em> of the
<a class="reference internal" href="user.html#pyop2.Map" title="pyop2.Map"><tt class="xref py py-class docutils literal"><span class="pre">Map</span></tt></a>, in the example above 3. Each of these points to
the data chunk for the element in the target <a class="reference internal" href="user.html#pyop2.Set" title="pyop2.Set"><tt class="xref py py-class docutils literal"><span class="pre">Set</span></tt></a> given
by <a class="reference internal" href="user.html#pyop2.Map" title="pyop2.Map"><tt class="xref py py-class docutils literal"><span class="pre">Map</span></tt></a> entries <tt class="docutils literal"><span class="pre">(i,</span> <span class="pre">0)</span></tt>, <tt class="docutils literal"><span class="pre">(i,</span> <span class="pre">1)</span></tt> and <tt class="docutils literal"><span class="pre">(i,</span> <span class="pre">2)</span></tt>.</p>
<div class="figure align-center">
<img src="_images/indirect_arg.svg" /><p class="caption">Data layout for a <a class="reference internal" href="user.html#pyop2.Dat" title="pyop2.Dat"><tt class="xref py py-class docutils literal"><span class="pre">Dat</span></tt></a> argument with <tt class="docutils literal"><span class="pre">dim</span></tt> 2 indirectly
accessed through a <a class="reference internal" href="user.html#pyop2.Map" title="pyop2.Map"><tt class="xref py py-class docutils literal"><span class="pre">Map</span></tt></a> of <tt class="docutils literal"><span class="pre">arity</span></tt> 3</p>
</div>
<p>If the argument is created with the keyword argument <tt class="docutils literal"><span class="pre">flatten</span></tt> set
to <tt class="docutils literal"><span class="pre">True</span></tt>, a flattened vector of pointers is passed to the kernel.
This vector is of length <tt class="docutils literal"><span class="pre">dim</span> <span class="pre">*</span> <span class="pre">arity</span></tt> (where <tt class="docutils literal"><span class="pre">dim</span></tt> is the product
of the extents of the <tt class="docutils literal"><span class="pre">dim</span></tt> tuple), which is 6 in the example above.
Each entry points to a single data value of the <a class="reference internal" href="user.html#pyop2.Dat" title="pyop2.Dat"><tt class="xref py py-class docutils literal"><span class="pre">Dat</span></tt></a>.
The ordering is by component of <tt class="docutils literal"><span class="pre">dim</span></tt> i.e. the first component of
each data item for each element in the target set pointed to by the
map followed by the second component etc.</p>
<div class="figure align-center">
<img src="_images/indirect_arg_flattened.svg" /><p class="caption">Data layout for a flattened <a class="reference internal" href="user.html#pyop2.Dat" title="pyop2.Dat"><tt class="xref py py-class docutils literal"><span class="pre">Dat</span></tt></a> argument with <tt class="docutils literal"><span class="pre">dim</span></tt> 2
indirectly accessed through a <a class="reference internal" href="user.html#pyop2.Map" title="pyop2.Map"><tt class="xref py py-class docutils literal"><span class="pre">Map</span></tt></a> of <tt class="docutils literal"><span class="pre">arity</span></tt> 3</p>
</div>
</div>
<div class="section" id="local-iteration-spaces">
<span id="id3"></span><h2>Local iteration spaces<a class="headerlink" href="#local-iteration-spaces" title="Permalink to this headline">¶</a></h2>
<p>PyOP2 supports complex kernels with large local working set sizes, which may
not run very efficiently on architectures with a limited amount of registers
and on-chip resources. In many cases the resource usage is proportional to the
size of the <em>local iteration space</em> the kernel operates on.</p>
<p>Consider a finite-element local assembly kernel for vector-valued basis
functions of second order on triangles.  There are kernels more complex and
computing considerably larger local tensors commonly found in finite-element
computations, in particular for higher-order basis functions, and this kernel
only serves to illustrate the concept. For each element in the iteration set,
this kernel computes a 12x12 local tensor:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">kernel</span><span class="p">(</span><span class="kt">double</span> <span class="n">A</span><span class="p">[</span><span class="mi">12</span><span class="p">][</span><span class="mi">12</span><span class="p">],</span> <span class="p">...)</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="c1">// loops over the local iteration space</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">12</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="mi">12</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">+=</span> <span class="p">...</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>PyOP2 invokes this kernel for each element in the iteration set:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">ele</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">ele</span> <span class="o">&lt;</span> <span class="n">nele</span><span class="p">;</span> <span class="o">++</span><span class="n">ele</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">double</span> <span class="n">A</span><span class="p">[</span><span class="mi">12</span><span class="p">][</span><span class="mi">12</span><span class="p">];</span>
  <span class="p">...</span>
  <span class="n">kernel</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="p">...);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>To improve the efficiency of executing complex kernels on manycore
platforms, their operation can be distributed among several threads
which each compute a single point in this local iteration space to
increase the level of parallelism and to lower the amount of resources
required per thread. In the case of the kernel above we obtain:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">mass</span><span class="p">(</span><span class="kt">double</span> <span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="p">...,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Note how the doubly nested loop over basis function is hoisted out of the
kernel, which receives its position in the local iteration space to compute as
additional arguments <tt class="docutils literal"><span class="pre">j</span></tt> and <tt class="docutils literal"><span class="pre">k</span></tt>. PyOP2 then calls the kernel for
each element of the local iteration space for each set element:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">ele</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">ele</span> <span class="o">&lt;</span> <span class="n">nele</span><span class="p">;</span> <span class="o">++</span><span class="n">ele</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">double</span> <span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">];</span>
  <span class="p">...</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">12</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="mi">12</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">kernel</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="p">...,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>On manycore platforms, the local iteration space does not translate into a
loop nest, but rather into a larger number of threads being launched to
compute each of its elements:</p>
<div class="figure align-center">
<img src="_images/iteration_spaces.svg" /><p class="caption">Local iteration space for a kernel computing a 12x12 local tensor</p>
</div>
<p>PyOP2 needs to be told to loop over this local iteration space by
indexing the corresponding maps with an
<a class="reference internal" href="pyop2.html#pyop2.base.IterationIndex" title="pyop2.base.IterationIndex"><tt class="xref py py-class docutils literal"><span class="pre">IterationIndex</span></tt></a> <a class="reference internal" href="user.html#pyop2.i" title="pyop2.i"><tt class="xref py py-data docutils literal"><span class="pre">i</span></tt></a> in the
<a class="reference internal" href="user.html#pyop2.par_loop" title="pyop2.par_loop"><tt class="xref py py-func docutils literal"><span class="pre">par_loop()</span></tt></a> call.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">PyOP2 Kernels</a><ul>
<li><a class="reference internal" href="#kernel-api">Kernel API</a></li>
<li><a class="reference internal" href="#data-layout">Data layout</a></li>
<li><a class="reference internal" href="#local-iteration-spaces">Local iteration spaces</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="concepts.html"
                        title="previous chapter">PyOP2 Concepts</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="architecture.html"
                        title="next chapter">PyOP2 Architecture</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/kernels.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="architecture.html" title="PyOP2 Architecture"
             >next</a> |</li>
        <li class="right" >
          <a href="concepts.html" title="PyOP2 Concepts"
             >previous</a> |</li>
        <li><a href="index.html">PyOP2 0.10.0 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012-2013, Imperial College et al.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2b1.
    </div>
  </body>
</html>