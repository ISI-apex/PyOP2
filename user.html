<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>pyop2 user documentation &mdash; PyOP2 0.11.0 documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.11.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="PyOP2 0.11.0 documentation" href="index.html" />
    <link rel="next" title="pyop2 package" href="pyop2.html" />
    <link rel="prev" title="Profiling" href="profiling.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="pyop2.html" title="pyop2 package"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="profiling.html" title="Profiling"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">PyOP2 0.11.0 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="pyop2-user-documentation">
<h1>pyop2 user documentation<a class="headerlink" href="#pyop2-user-documentation" title="Permalink to this headline">¶</a></h1>
<div class="section" id="module-pyop2">
<span id="pyop2-package"></span><h2><a class="reference internal" href="#module-pyop2" title="pyop2"><tt class="xref py py-mod docutils literal"><span class="pre">pyop2</span></tt></a> Package<a class="headerlink" href="#module-pyop2" title="Permalink to this headline">¶</a></h2>
<p>PyOP2 is a library for parallel computations on unstructured meshes and
delivers performance-portability across a range of platforms:</p>
<ul class="simple">
<li>multi-core CPU (sequential, OpenMP, OpenCL and MPI)</li>
<li>GPU (CUDA and OpenCL)</li>
</ul>
<div class="section" id="initialization-and-finalization">
<h3>Initialization and finalization<a class="headerlink" href="#initialization-and-finalization" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="pyop2.init">
<tt class="descclassname">pyop2.</tt><tt class="descname">init</tt><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pyop2.init" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialise PyOP2: select the backend and potentially other configuration
options.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>backend</strong> &#8211; Set the hardware-specific backend. Current choices are
<tt class="docutils literal"><span class="pre">&quot;sequential&quot;</span></tt>, <tt class="docutils literal"><span class="pre">&quot;openmp&quot;</span></tt>, <tt class="docutils literal"><span class="pre">&quot;opencl&quot;</span></tt>, <tt class="docutils literal"><span class="pre">&quot;cuda&quot;</span></tt>.</li>
<li><strong>debug</strong> &#8211; The level of debugging output.</li>
<li><strong>comm</strong> &#8211; The MPI communicator to use for parallel communication,
defaults to <cite>MPI_COMM_WORLD</cite></li>
<li><strong>log_level</strong> &#8211; The log level. Options: DEBUG, INFO, WARNING, ERROR, CRITICAL</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>For debugging purposes, <cite>init</cite> accepts all keyword arguments
accepted by the PyOP2 <tt class="xref py py-class docutils literal"><span class="pre">Configuration</span></tt> object, see
<tt class="xref py py-meth docutils literal"><span class="pre">Configuration.__init__()</span></tt> for details of further accepted
options.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Calling <tt class="docutils literal"><span class="pre">init</span></tt> again with a different backend raises an exception.
Changing the backend is not possible. Calling <tt class="docutils literal"><span class="pre">init</span></tt> again with the
same backend or not specifying a backend will update the configuration.
Calling <tt class="docutils literal"><span class="pre">init</span></tt> after <tt class="docutils literal"><span class="pre">exit</span></tt> has been called is an error and will
raise an exception.</p>
</div>
<p>This function is logically collective over MPI ranks, it is an
error to call it on fewer than all the ranks in MPI communicator.</p>
</dd></dl>

<dl class="function">
<dt id="pyop2.exit">
<tt class="descclassname">pyop2.</tt><tt class="descname">exit</tt><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyop2.exit" title="Permalink to this definition">¶</a></dt>
<dd><p>Exit OP2 and clean up</p>
<p>This function is logically collective over MPI ranks, it is an
error to call it on fewer than all the ranks in MPI communicator.</p>
</dd></dl>

</div>
<div class="section" id="data-structures">
<h3>Data structures<a class="headerlink" href="#data-structures" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="pyop2.Set">
<em class="property">class </em><tt class="descclassname">pyop2.</tt><tt class="descname">Set</tt><span class="sig-paren">(</span><em>size=None</em>, <em>name=None</em>, <em>halo=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyop2.Set" title="Permalink to this definition">¶</a></dt>
<dd><p>OP2 set.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>size</strong> (<em>integer or list of four integers.</em>) &#8211; The size of the set.</li>
<li><strong>dim</strong> (<em>integer or tuple of integers</em>) &#8211; The shape of the data associated with each element of this <tt class="docutils literal"><span class="pre">Set</span></tt>.</li>
<li><strong>name</strong> (<em>string</em>) &#8211; The name of the set (optional).</li>
<li><strong>halo</strong> &#8211; An exisiting halo to use (optional).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>When the set is employed as an iteration space in a
<a class="reference internal" href="pyop2.html#pyop2.op2.par_loop" title="pyop2.op2.par_loop"><tt class="xref py py-func docutils literal"><span class="pre">pyop2.op2.par_loop()</span></tt></a>, the extent of any local iteration space within
each set entry is indicated in brackets. See the example in
<a class="reference internal" href="pyop2.html#pyop2.op2.par_loop" title="pyop2.op2.par_loop"><tt class="xref py py-func docutils literal"><span class="pre">pyop2.op2.par_loop()</span></tt></a> for more details.</p>
<p>The size of the set can either be an integer, or a list of four
integers.  The latter case is used for running in parallel where
we distinguish between:</p>
<blockquote>
<div><ul class="simple">
<li><cite>CORE</cite> (owned and not touching halo)</li>
<li><cite>OWNED</cite> (owned, touching halo)</li>
<li><cite>EXECUTE HALO</cite> (not owned, but executed over redundantly)</li>
<li><cite>NON EXECUTE HALO</cite> (not owned, read when executing in the execute halo)</li>
</ul>
</div></blockquote>
<p>If a single integer is passed, we assume that we&#8217;re running in
serial and there is no distinction.</p>
<p>The division of set elements is:</p>
<div class="highlight-python"><div class="highlight"><pre>[0, CORE)
[CORE, OWNED)
[OWNED, EXECUTE HALO)
[EXECUTE HALO, NON EXECUTE HALO).
</pre></div>
</div>
<p>Halo send/receive data is stored on sets in a <tt class="xref py py-class docutils literal"><span class="pre">Halo</span></tt>.</p>
<dl class="attribute">
<dt id="pyop2.Set.all_part">
<tt class="descname">all_part</tt><a class="headerlink" href="#pyop2.Set.all_part" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyop2.Set.core_part">
<tt class="descname">core_part</tt><a class="headerlink" href="#pyop2.Set.core_part" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyop2.Set.core_size">
<tt class="descname">core_size</tt><a class="headerlink" href="#pyop2.Set.core_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Core set size.  Owned elements not touching halo elements.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.Set.exec_part">
<tt class="descname">exec_part</tt><a class="headerlink" href="#pyop2.Set.exec_part" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyop2.Set.exec_size">
<tt class="descname">exec_size</tt><a class="headerlink" href="#pyop2.Set.exec_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Set size including execute halo elements.</p>
<p>If a <tt class="xref py py-class docutils literal"><span class="pre">ParLoop</span></tt> is indirect, we do redundant computation
by executing over these set elements as well as owned ones.</p>
</dd></dl>

<dl class="classmethod">
<dt id="pyop2.Set.fromhdf5">
<em class="property">classmethod </em><tt class="descname">fromhdf5</tt><span class="sig-paren">(</span><em>f</em>, <em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#pyop2.Set.fromhdf5" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a <a class="reference internal" href="#pyop2.Set" title="pyop2.Set"><tt class="xref py py-class docutils literal"><span class="pre">Set</span></tt></a> from set named <tt class="docutils literal"><span class="pre">name</span></tt> in HDF5 data <tt class="docutils literal"><span class="pre">f</span></tt></p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.Set.halo">
<tt class="descname">halo</tt><a class="headerlink" href="#pyop2.Set.halo" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="xref py py-class docutils literal"><span class="pre">Halo</span></tt> associated with this Set</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.Set.layers">
<tt class="descname">layers</tt><a class="headerlink" href="#pyop2.Set.layers" title="Permalink to this definition">¶</a></dt>
<dd><p>Return None (not an <a class="reference internal" href="#pyop2.ExtrudedSet" title="pyop2.ExtrudedSet"><tt class="xref py py-class docutils literal"><span class="pre">ExtrudedSet</span></tt></a>).</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.Set.name">
<tt class="descname">name</tt><a class="headerlink" href="#pyop2.Set.name" title="Permalink to this definition">¶</a></dt>
<dd><p>User-defined label</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.Set.owned_part">
<tt class="descname">owned_part</tt><a class="headerlink" href="#pyop2.Set.owned_part" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyop2.Set.partition_size">
<tt class="descname">partition_size</tt><a class="headerlink" href="#pyop2.Set.partition_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Default partition size</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.Set.size">
<tt class="descname">size</tt><a class="headerlink" href="#pyop2.Set.size" title="Permalink to this definition">¶</a></dt>
<dd><p>Set size, owned elements.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.Set.sizes">
<tt class="descname">sizes</tt><a class="headerlink" href="#pyop2.Set.sizes" title="Permalink to this definition">¶</a></dt>
<dd><p>Set sizes: core, owned, execute halo, total.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.Set.total_size">
<tt class="descname">total_size</tt><a class="headerlink" href="#pyop2.Set.total_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Total set size, including halo elements.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyop2.ExtrudedSet">
<em class="property">class </em><tt class="descclassname">pyop2.</tt><tt class="descname">ExtrudedSet</tt><span class="sig-paren">(</span><em>size=None</em>, <em>name=None</em>, <em>halo=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyop2.ExtrudedSet" title="Permalink to this definition">¶</a></dt>
<dd><p>OP2 set.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>size</strong> (<em>integer or list of four integers.</em>) &#8211; The size of the set.</li>
<li><strong>dim</strong> (<em>integer or tuple of integers</em>) &#8211; The shape of the data associated with each element of this <tt class="docutils literal"><span class="pre">Set</span></tt>.</li>
<li><strong>name</strong> (<em>string</em>) &#8211; The name of the set (optional).</li>
<li><strong>halo</strong> &#8211; An exisiting halo to use (optional).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>When the set is employed as an iteration space in a
<a class="reference internal" href="pyop2.html#pyop2.op2.par_loop" title="pyop2.op2.par_loop"><tt class="xref py py-func docutils literal"><span class="pre">pyop2.op2.par_loop()</span></tt></a>, the extent of any local iteration space within
each set entry is indicated in brackets. See the example in
<a class="reference internal" href="pyop2.html#pyop2.op2.par_loop" title="pyop2.op2.par_loop"><tt class="xref py py-func docutils literal"><span class="pre">pyop2.op2.par_loop()</span></tt></a> for more details.</p>
<p>The size of the set can either be an integer, or a list of four
integers.  The latter case is used for running in parallel where
we distinguish between:</p>
<blockquote>
<div><ul class="simple">
<li><cite>CORE</cite> (owned and not touching halo)</li>
<li><cite>OWNED</cite> (owned, touching halo)</li>
<li><cite>EXECUTE HALO</cite> (not owned, but executed over redundantly)</li>
<li><cite>NON EXECUTE HALO</cite> (not owned, read when executing in the execute halo)</li>
</ul>
</div></blockquote>
<p>If a single integer is passed, we assume that we&#8217;re running in
serial and there is no distinction.</p>
<p>The division of set elements is:</p>
<div class="highlight-python"><div class="highlight"><pre>[0, CORE)
[CORE, OWNED)
[OWNED, EXECUTE HALO)
[EXECUTE HALO, NON EXECUTE HALO).
</pre></div>
</div>
<p>Halo send/receive data is stored on sets in a <tt class="xref py py-class docutils literal"><span class="pre">Halo</span></tt>.</p>
<dl class="attribute">
<dt id="pyop2.ExtrudedSet.all_part">
<tt class="descname">all_part</tt><a class="headerlink" href="#pyop2.ExtrudedSet.all_part" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyop2.ExtrudedSet.core_part">
<tt class="descname">core_part</tt><a class="headerlink" href="#pyop2.ExtrudedSet.core_part" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyop2.ExtrudedSet.core_size">
<tt class="descname">core_size</tt><a class="headerlink" href="#pyop2.ExtrudedSet.core_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Core set size.  Owned elements not touching halo elements.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.ExtrudedSet.exec_part">
<tt class="descname">exec_part</tt><a class="headerlink" href="#pyop2.ExtrudedSet.exec_part" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyop2.ExtrudedSet.exec_size">
<tt class="descname">exec_size</tt><a class="headerlink" href="#pyop2.ExtrudedSet.exec_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Set size including execute halo elements.</p>
<p>If a <tt class="xref py py-class docutils literal"><span class="pre">ParLoop</span></tt> is indirect, we do redundant computation
by executing over these set elements as well as owned ones.</p>
</dd></dl>

<dl class="classmethod">
<dt id="pyop2.ExtrudedSet.fromhdf5">
<em class="property">classmethod </em><tt class="descname">fromhdf5</tt><span class="sig-paren">(</span><em>f</em>, <em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#pyop2.ExtrudedSet.fromhdf5" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a <a class="reference internal" href="#pyop2.Set" title="pyop2.Set"><tt class="xref py py-class docutils literal"><span class="pre">Set</span></tt></a> from set named <tt class="docutils literal"><span class="pre">name</span></tt> in HDF5 data <tt class="docutils literal"><span class="pre">f</span></tt></p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.ExtrudedSet.halo">
<tt class="descname">halo</tt><a class="headerlink" href="#pyop2.ExtrudedSet.halo" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="xref py py-class docutils literal"><span class="pre">Halo</span></tt> associated with this Set</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.ExtrudedSet.layers">
<tt class="descname">layers</tt><a class="headerlink" href="#pyop2.ExtrudedSet.layers" title="Permalink to this definition">¶</a></dt>
<dd><p>Return None (not an <a class="reference internal" href="#pyop2.ExtrudedSet" title="pyop2.ExtrudedSet"><tt class="xref py py-class docutils literal"><span class="pre">ExtrudedSet</span></tt></a>).</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.ExtrudedSet.name">
<tt class="descname">name</tt><a class="headerlink" href="#pyop2.ExtrudedSet.name" title="Permalink to this definition">¶</a></dt>
<dd><p>User-defined label</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.ExtrudedSet.owned_part">
<tt class="descname">owned_part</tt><a class="headerlink" href="#pyop2.ExtrudedSet.owned_part" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyop2.ExtrudedSet.partition_size">
<tt class="descname">partition_size</tt><a class="headerlink" href="#pyop2.ExtrudedSet.partition_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Default partition size</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.ExtrudedSet.size">
<tt class="descname">size</tt><a class="headerlink" href="#pyop2.ExtrudedSet.size" title="Permalink to this definition">¶</a></dt>
<dd><p>Set size, owned elements.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.ExtrudedSet.sizes">
<tt class="descname">sizes</tt><a class="headerlink" href="#pyop2.ExtrudedSet.sizes" title="Permalink to this definition">¶</a></dt>
<dd><p>Set sizes: core, owned, execute halo, total.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.ExtrudedSet.total_size">
<tt class="descname">total_size</tt><a class="headerlink" href="#pyop2.ExtrudedSet.total_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Total set size, including halo elements.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyop2.Subset">
<em class="property">class </em><tt class="descclassname">pyop2.</tt><tt class="descname">Subset</tt><span class="sig-paren">(</span><em>superset</em>, <em>indices</em><span class="sig-paren">)</span><a class="headerlink" href="#pyop2.Subset" title="Permalink to this definition">¶</a></dt>
<dd><p>OP2 subset.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>superset</strong> (a <a class="reference internal" href="#pyop2.Set" title="pyop2.Set"><tt class="xref py py-class docutils literal"><span class="pre">Set</span></tt></a> or a <a class="reference internal" href="#pyop2.Subset" title="pyop2.Subset"><tt class="xref py py-class docutils literal"><span class="pre">Subset</span></tt></a>.) &#8211; The superset of the subset.</li>
<li><strong>indices</strong> (<em>a list of integers, or a numpy array.</em>) &#8211; Elements of the superset that form the
subset. Duplicate values are removed when constructing the subset.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="pyop2.Subset.all_part">
<tt class="descname">all_part</tt><a class="headerlink" href="#pyop2.Subset.all_part" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyop2.Subset.core_part">
<tt class="descname">core_part</tt><a class="headerlink" href="#pyop2.Subset.core_part" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyop2.Subset.core_size">
<tt class="descname">core_size</tt><a class="headerlink" href="#pyop2.Subset.core_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Core set size.  Owned elements not touching halo elements.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.Subset.exec_part">
<tt class="descname">exec_part</tt><a class="headerlink" href="#pyop2.Subset.exec_part" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyop2.Subset.exec_size">
<tt class="descname">exec_size</tt><a class="headerlink" href="#pyop2.Subset.exec_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Set size including execute halo elements.</p>
<p>If a <tt class="xref py py-class docutils literal"><span class="pre">ParLoop</span></tt> is indirect, we do redundant computation
by executing over these set elements as well as owned ones.</p>
</dd></dl>

<dl class="classmethod">
<dt id="pyop2.Subset.fromhdf5">
<em class="property">classmethod </em><tt class="descname">fromhdf5</tt><span class="sig-paren">(</span><em>f</em>, <em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#pyop2.Subset.fromhdf5" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a <a class="reference internal" href="#pyop2.Set" title="pyop2.Set"><tt class="xref py py-class docutils literal"><span class="pre">Set</span></tt></a> from set named <tt class="docutils literal"><span class="pre">name</span></tt> in HDF5 data <tt class="docutils literal"><span class="pre">f</span></tt></p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.Subset.halo">
<tt class="descname">halo</tt><a class="headerlink" href="#pyop2.Subset.halo" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="xref py py-class docutils literal"><span class="pre">Halo</span></tt> associated with this Set</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.Subset.indices">
<tt class="descname">indices</tt><a class="headerlink" href="#pyop2.Subset.indices" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the indices pointing in the superset.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.Subset.layers">
<tt class="descname">layers</tt><a class="headerlink" href="#pyop2.Subset.layers" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of layers in this extruded set.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.Subset.name">
<tt class="descname">name</tt><a class="headerlink" href="#pyop2.Subset.name" title="Permalink to this definition">¶</a></dt>
<dd><p>User-defined label</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.Subset.owned_part">
<tt class="descname">owned_part</tt><a class="headerlink" href="#pyop2.Subset.owned_part" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyop2.Subset.parent">
<tt class="descname">parent</tt><a class="headerlink" href="#pyop2.Subset.parent" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyop2.Subset.partition_size">
<tt class="descname">partition_size</tt><a class="headerlink" href="#pyop2.Subset.partition_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Default partition size</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.Subset.size">
<tt class="descname">size</tt><a class="headerlink" href="#pyop2.Subset.size" title="Permalink to this definition">¶</a></dt>
<dd><p>Set size, owned elements.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.Subset.sizes">
<tt class="descname">sizes</tt><a class="headerlink" href="#pyop2.Subset.sizes" title="Permalink to this definition">¶</a></dt>
<dd><p>Set sizes: core, owned, execute halo, total.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.Subset.superset">
<tt class="descname">superset</tt><a class="headerlink" href="#pyop2.Subset.superset" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the superset Set</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.Subset.total_size">
<tt class="descname">total_size</tt><a class="headerlink" href="#pyop2.Subset.total_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Total set size, including halo elements.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyop2.MixedSet">
<em class="property">class </em><tt class="descclassname">pyop2.</tt><tt class="descname">MixedSet</tt><span class="sig-paren">(</span><em>sets</em><span class="sig-paren">)</span><a class="headerlink" href="#pyop2.MixedSet" title="Permalink to this definition">¶</a></dt>
<dd><p>A container for a bag of <a class="reference internal" href="#pyop2.Set" title="pyop2.Set"><tt class="xref py py-class docutils literal"><span class="pre">Set</span></tt></a>s.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>sets</strong> (<em>iterable</em>) &#8211; Iterable of <a class="reference internal" href="#pyop2.Set" title="pyop2.Set"><tt class="xref py py-class docutils literal"><span class="pre">Set</span></tt></a>s or <a class="reference internal" href="#pyop2.ExtrudedSet" title="pyop2.ExtrudedSet"><tt class="xref py py-class docutils literal"><span class="pre">ExtrudedSet</span></tt></a>s</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="pyop2.MixedSet.all_part">
<tt class="descname">all_part</tt><a class="headerlink" href="#pyop2.MixedSet.all_part" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyop2.MixedSet.core_part">
<tt class="descname">core_part</tt><a class="headerlink" href="#pyop2.MixedSet.core_part" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyop2.MixedSet.core_size">
<tt class="descname">core_size</tt><a class="headerlink" href="#pyop2.MixedSet.core_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Core set size. Owned elements not touching halo elements.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.MixedSet.exec_part">
<tt class="descname">exec_part</tt><a class="headerlink" href="#pyop2.MixedSet.exec_part" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyop2.MixedSet.exec_size">
<tt class="descname">exec_size</tt><a class="headerlink" href="#pyop2.MixedSet.exec_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Set size including execute halo elements.</p>
</dd></dl>

<dl class="classmethod">
<dt id="pyop2.MixedSet.fromhdf5">
<em class="property">classmethod </em><tt class="descname">fromhdf5</tt><span class="sig-paren">(</span><em>f</em>, <em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#pyop2.MixedSet.fromhdf5" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a <a class="reference internal" href="#pyop2.Set" title="pyop2.Set"><tt class="xref py py-class docutils literal"><span class="pre">Set</span></tt></a> from set named <tt class="docutils literal"><span class="pre">name</span></tt> in HDF5 data <tt class="docutils literal"><span class="pre">f</span></tt></p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.MixedSet.halo">
<tt class="descname">halo</tt><a class="headerlink" href="#pyop2.MixedSet.halo" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="xref py py-class docutils literal"><span class="pre">Halo</span></tt>s associated with these <a class="reference internal" href="#pyop2.Set" title="pyop2.Set"><tt class="xref py py-class docutils literal"><span class="pre">Set</span></tt></a>s.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.MixedSet.layers">
<tt class="descname">layers</tt><a class="headerlink" href="#pyop2.MixedSet.layers" title="Permalink to this definition">¶</a></dt>
<dd><p>Numbers of layers in the extruded mesh (or None if this MixedSet is not extruded).</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.MixedSet.name">
<tt class="descname">name</tt><a class="headerlink" href="#pyop2.MixedSet.name" title="Permalink to this definition">¶</a></dt>
<dd><p>User-defined labels.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.MixedSet.owned_part">
<tt class="descname">owned_part</tt><a class="headerlink" href="#pyop2.MixedSet.owned_part" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyop2.MixedSet.partition_size">
<tt class="descname">partition_size</tt><a class="headerlink" href="#pyop2.MixedSet.partition_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Default partition size</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.MixedSet.size">
<tt class="descname">size</tt><a class="headerlink" href="#pyop2.MixedSet.size" title="Permalink to this definition">¶</a></dt>
<dd><p>Set size, owned elements.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.MixedSet.sizes">
<tt class="descname">sizes</tt><a class="headerlink" href="#pyop2.MixedSet.sizes" title="Permalink to this definition">¶</a></dt>
<dd><p>Set sizes: core, owned, execute halo, total.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.MixedSet.split">
<tt class="descname">split</tt><a class="headerlink" href="#pyop2.MixedSet.split" title="Permalink to this definition">¶</a></dt>
<dd><p>The underlying tuple of <a class="reference internal" href="#pyop2.Set" title="pyop2.Set"><tt class="xref py py-class docutils literal"><span class="pre">Set</span></tt></a>s.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.MixedSet.total_size">
<tt class="descname">total_size</tt><a class="headerlink" href="#pyop2.MixedSet.total_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Total set size, including halo elements.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyop2.DataSet">
<em class="property">class </em><tt class="descclassname">pyop2.</tt><tt class="descname">DataSet</tt><span class="sig-paren">(</span><em>iter_set</em>, <em>dim=1</em>, <em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyop2.DataSet" title="Permalink to this definition">¶</a></dt>
<dd><p>PyOP2 Data Set</p>
<p>Set used in the op2.Dat structures to specify the dimension of the data.</p>
<dl class="attribute">
<dt id="pyop2.DataSet.cdim">
<tt class="descname">cdim</tt><a class="headerlink" href="#pyop2.DataSet.cdim" title="Permalink to this definition">¶</a></dt>
<dd><p>The scalar number of values for each member of the set. This is
the product of the dim tuple.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.DataSet.dim">
<tt class="descname">dim</tt><a class="headerlink" href="#pyop2.DataSet.dim" title="Permalink to this definition">¶</a></dt>
<dd><p>The shape tuple of the values for each element of the set.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.DataSet.name">
<tt class="descname">name</tt><a class="headerlink" href="#pyop2.DataSet.name" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the name of the data set.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.DataSet.set">
<tt class="descname">set</tt><a class="headerlink" href="#pyop2.DataSet.set" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the parent set of the data set.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyop2.MixedDataSet">
<em class="property">class </em><tt class="descclassname">pyop2.</tt><tt class="descname">MixedDataSet</tt><span class="sig-paren">(</span><em>arg</em>, <em>dims=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyop2.MixedDataSet" title="Permalink to this definition">¶</a></dt>
<dd><p>A container for a bag of <a class="reference internal" href="#pyop2.DataSet" title="pyop2.DataSet"><tt class="xref py py-class docutils literal"><span class="pre">DataSet</span></tt></a>s.</p>
<p>Initialized either from a <a class="reference internal" href="#pyop2.MixedSet" title="pyop2.MixedSet"><tt class="xref py py-class docutils literal"><span class="pre">MixedSet</span></tt></a> and an iterable or iterator of
<tt class="docutils literal"><span class="pre">dims</span></tt> of corresponding length</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">mdset</span> <span class="o">=</span> <span class="n">op2</span><span class="o">.</span><span class="n">MixedDataSet</span><span class="p">(</span><span class="n">mset</span><span class="p">,</span> <span class="p">[</span><span class="n">dim1</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">dimN</span><span class="p">])</span>
</pre></div>
</div>
<p>or from a tuple of <a class="reference internal" href="#pyop2.Set" title="pyop2.Set"><tt class="xref py py-class docutils literal"><span class="pre">Set</span></tt></a>s and an iterable of <tt class="docutils literal"><span class="pre">dims</span></tt> of
corresponding length</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">mdset</span> <span class="o">=</span> <span class="n">op2</span><span class="o">.</span><span class="n">MixedDataSet</span><span class="p">([</span><span class="n">set1</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">setN</span><span class="p">],</span> <span class="p">[</span><span class="n">dim1</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">dimN</span><span class="p">])</span>
</pre></div>
</div>
<p>If all <tt class="docutils literal"><span class="pre">dims</span></tt> are to be the same, they can also be given as an
<tt class="xref py py-class docutils literal"><span class="pre">int</span></tt> for either of above invocations</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">mdset</span> <span class="o">=</span> <span class="n">op2</span><span class="o">.</span><span class="n">MixedDataSet</span><span class="p">(</span><span class="n">mset</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span>
<span class="n">mdset</span> <span class="o">=</span> <span class="n">op2</span><span class="o">.</span><span class="n">MixedDataSet</span><span class="p">([</span><span class="n">set1</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">setN</span><span class="p">],</span> <span class="n">dim</span><span class="p">)</span>
</pre></div>
</div>
<p>Initialized from a <a class="reference internal" href="#pyop2.MixedSet" title="pyop2.MixedSet"><tt class="xref py py-class docutils literal"><span class="pre">MixedSet</span></tt></a> without explicitly specifying <tt class="docutils literal"><span class="pre">dims</span></tt>
they default to 1</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">mdset</span> <span class="o">=</span> <span class="n">op2</span><span class="o">.</span><span class="n">MixedDataSet</span><span class="p">(</span><span class="n">mset</span><span class="p">)</span>
</pre></div>
</div>
<p>Initialized from an iterable or iterator of <a class="reference internal" href="#pyop2.DataSet" title="pyop2.DataSet"><tt class="xref py py-class docutils literal"><span class="pre">DataSet</span></tt></a>s and/or
<a class="reference internal" href="#pyop2.Set" title="pyop2.Set"><tt class="xref py py-class docutils literal"><span class="pre">Set</span></tt></a>s, where <a class="reference internal" href="#pyop2.Set" title="pyop2.Set"><tt class="xref py py-class docutils literal"><span class="pre">Set</span></tt></a>s are implicitly upcast to
<a class="reference internal" href="#pyop2.DataSet" title="pyop2.DataSet"><tt class="xref py py-class docutils literal"><span class="pre">DataSet</span></tt></a>s of dim 1</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">mdset</span> <span class="o">=</span> <span class="n">op2</span><span class="o">.</span><span class="n">MixedDataSet</span><span class="p">([</span><span class="n">dset1</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">dsetN</span><span class="p">])</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>arg</strong> &#8211; a <a class="reference internal" href="#pyop2.MixedSet" title="pyop2.MixedSet"><tt class="xref py py-class docutils literal"><span class="pre">MixedSet</span></tt></a> or an iterable or a generator
expression of <a class="reference internal" href="#pyop2.Set" title="pyop2.Set"><tt class="xref py py-class docutils literal"><span class="pre">Set</span></tt></a>s or <a class="reference internal" href="#pyop2.DataSet" title="pyop2.DataSet"><tt class="xref py py-class docutils literal"><span class="pre">DataSet</span></tt></a>s or a
mixture of both</li>
<li><strong>dims</strong> &#8211; <cite>None</cite> (the default) or an <tt class="xref py py-class docutils literal"><span class="pre">int</span></tt> or an iterable or
generator expression of <tt class="xref py py-class docutils literal"><span class="pre">int</span></tt>s, which <strong>must</strong> be
of same length as <cite>arg</cite></li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">When using generator expressions for <tt class="docutils literal"><span class="pre">arg</span></tt> or <tt class="docutils literal"><span class="pre">dims</span></tt>, these
<strong>must</strong> terminate or else will cause an infinite loop.</p>
</div>
<dl class="attribute">
<dt id="pyop2.MixedDataSet.cdim">
<tt class="descname">cdim</tt><a class="headerlink" href="#pyop2.MixedDataSet.cdim" title="Permalink to this definition">¶</a></dt>
<dd><p>The sum of the scalar number of values for each member of the sets.
This is the sum of products of the dim tuples.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.MixedDataSet.dim">
<tt class="descname">dim</tt><a class="headerlink" href="#pyop2.MixedDataSet.dim" title="Permalink to this definition">¶</a></dt>
<dd><p>The shape tuple of the values for each element of the sets.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.MixedDataSet.name">
<tt class="descname">name</tt><a class="headerlink" href="#pyop2.MixedDataSet.name" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the name of the data sets.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.MixedDataSet.set">
<tt class="descname">set</tt><a class="headerlink" href="#pyop2.MixedDataSet.set" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the <a class="reference internal" href="#pyop2.MixedSet" title="pyop2.MixedSet"><tt class="xref py py-class docutils literal"><span class="pre">MixedSet</span></tt></a> this <a class="reference internal" href="#pyop2.MixedDataSet" title="pyop2.MixedDataSet"><tt class="xref py py-class docutils literal"><span class="pre">MixedDataSet</span></tt></a> is
defined on.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.MixedDataSet.split">
<tt class="descname">split</tt><a class="headerlink" href="#pyop2.MixedDataSet.split" title="Permalink to this definition">¶</a></dt>
<dd><p>The underlying tuple of <a class="reference internal" href="#pyop2.DataSet" title="pyop2.DataSet"><tt class="xref py py-class docutils literal"><span class="pre">DataSet</span></tt></a>s.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyop2.Map">
<em class="property">class </em><tt class="descclassname">pyop2.</tt><tt class="descname">Map</tt><span class="sig-paren">(</span><em>iterset</em>, <em>toset</em>, <em>arity</em>, <em>values=None</em>, <em>name=None</em>, <em>offset=None</em>, <em>parent=None</em>, <em>bt_masks=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyop2.Map" title="Permalink to this definition">¶</a></dt>
<dd><p>OP2 map, a relation between two <a class="reference internal" href="#pyop2.Set" title="pyop2.Set"><tt class="xref py py-class docutils literal"><span class="pre">Set</span></tt></a> objects.</p>
<p>Each entry in the <tt class="docutils literal"><span class="pre">iterset</span></tt> maps to <tt class="docutils literal"><span class="pre">arity</span></tt> entries in the
<tt class="docutils literal"><span class="pre">toset</span></tt>. When a map is used in a <a class="reference internal" href="pyop2.html#pyop2.op2.par_loop" title="pyop2.op2.par_loop"><tt class="xref py py-func docutils literal"><span class="pre">pyop2.op2.par_loop()</span></tt></a>, it is
possible to use Python index notation to select an individual entry on the
right hand side of this map. There are three possibilities:</p>
<ul class="simple">
<li>No index. All <tt class="docutils literal"><span class="pre">arity</span></tt> <a class="reference internal" href="#pyop2.Dat" title="pyop2.Dat"><tt class="xref py py-class docutils literal"><span class="pre">Dat</span></tt></a> entries will be passed to the
kernel.</li>
<li>An integer: <tt class="docutils literal"><span class="pre">some_map[n]</span></tt>. The <tt class="docutils literal"><span class="pre">n</span></tt> th entry of the
map result will be passed to the kernel.</li>
<li>An <tt class="xref py py-class docutils literal"><span class="pre">IterationIndex</span></tt>, <tt class="docutils literal"><span class="pre">some_map[pyop2.i[n]]</span></tt>. <tt class="docutils literal"><span class="pre">n</span></tt>
will take each value from <tt class="docutils literal"><span class="pre">0</span></tt> to <tt class="docutils literal"><span class="pre">e-1</span></tt> where <tt class="docutils literal"><span class="pre">e</span></tt> is the
<tt class="docutils literal"><span class="pre">n</span></tt> th extent passed to the iteration space for this
<a class="reference internal" href="pyop2.html#pyop2.op2.par_loop" title="pyop2.op2.par_loop"><tt class="xref py py-func docutils literal"><span class="pre">pyop2.op2.par_loop()</span></tt></a>. See also <a class="reference internal" href="#pyop2.i" title="pyop2.i"><tt class="xref py py-data docutils literal"><span class="pre">i</span></tt></a>.</li>
</ul>
<p>For extruded problems (where <tt class="docutils literal"><span class="pre">iterset</span></tt> is an
<a class="reference internal" href="#pyop2.ExtrudedSet" title="pyop2.ExtrudedSet"><tt class="xref py py-class docutils literal"><span class="pre">ExtrudedSet</span></tt></a>) with boundary conditions applied at the top
and bottom of the domain, one needs to provide a list of which of
the <cite>arity</cite> values in each map entry correspond to values on the
bottom boundary and which correspond to the top.  This is done by
supplying two lists of indices in <cite>bt_masks</cite>, the first provides
indices for the bottom, the second for the top.</p>
<dl class="attribute">
<dt id="pyop2.Map.arange">
<tt class="descname">arange</tt><a class="headerlink" href="#pyop2.Map.arange" title="Permalink to this definition">¶</a></dt>
<dd><p>Tuple of arity offsets for each constituent <a class="reference internal" href="#pyop2.Map" title="pyop2.Map"><tt class="xref py py-class docutils literal"><span class="pre">Map</span></tt></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.Map.arities">
<tt class="descname">arities</tt><a class="headerlink" href="#pyop2.Map.arities" title="Permalink to this definition">¶</a></dt>
<dd><p>Arity of the mapping: number of toset elements mapped to per
iterset element.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">tuple</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.Map.arity">
<tt class="descname">arity</tt><a class="headerlink" href="#pyop2.Map.arity" title="Permalink to this definition">¶</a></dt>
<dd><p>Arity of the mapping: number of toset elements mapped to per
iterset element.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.Map.bottom_mask">
<tt class="descname">bottom_mask</tt><a class="headerlink" href="#pyop2.Map.bottom_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>The bottom layer mask to be applied on a mesh cell.</p>
</dd></dl>

<dl class="classmethod">
<dt id="pyop2.Map.fromhdf5">
<em class="property">classmethod </em><tt class="descname">fromhdf5</tt><span class="sig-paren">(</span><em>iterset</em>, <em>toset</em>, <em>f</em>, <em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#pyop2.Map.fromhdf5" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a <a class="reference internal" href="#pyop2.Map" title="pyop2.Map"><tt class="xref py py-class docutils literal"><span class="pre">Map</span></tt></a> from set named <tt class="docutils literal"><span class="pre">name</span></tt> in HDF5 data <tt class="docutils literal"><span class="pre">f</span></tt></p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.Map.implicit_bcs">
<tt class="descname">implicit_bcs</tt><a class="headerlink" href="#pyop2.Map.implicit_bcs" title="Permalink to this definition">¶</a></dt>
<dd><p>Return any implicit (extruded &#8220;top&#8221; or &#8220;bottom&#8221;) bcs to
apply to this <a class="reference internal" href="#pyop2.Map" title="pyop2.Map"><tt class="xref py py-class docutils literal"><span class="pre">Map</span></tt></a>.  Normally empty except in the case of
some <tt class="xref py py-class docutils literal"><span class="pre">DecoratedMap</span></tt>s.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.Map.iteration_region">
<tt class="descname">iteration_region</tt><a class="headerlink" href="#pyop2.Map.iteration_region" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the iteration region for the current map. For a normal map it
will always be ALL. For a <tt class="xref py py-class docutils literal"><span class="pre">DecoratedMap</span></tt> it will specify over which mesh
region the iteration will take place.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.Map.iterset">
<tt class="descname">iterset</tt><a class="headerlink" href="#pyop2.Map.iterset" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#pyop2.Set" title="pyop2.Set"><tt class="xref py py-class docutils literal"><span class="pre">Set</span></tt></a> mapped from.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.Map.name">
<tt class="descname">name</tt><a class="headerlink" href="#pyop2.Map.name" title="Permalink to this definition">¶</a></dt>
<dd><p>User-defined label</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.Map.offset">
<tt class="descname">offset</tt><a class="headerlink" href="#pyop2.Map.offset" title="Permalink to this definition">¶</a></dt>
<dd><p>The vertical offset.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.Map.split">
<tt class="descname">split</tt><a class="headerlink" href="#pyop2.Map.split" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyop2.Map.top_mask">
<tt class="descname">top_mask</tt><a class="headerlink" href="#pyop2.Map.top_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>The top layer mask to be applied on a mesh cell.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.Map.toset">
<tt class="descname">toset</tt><a class="headerlink" href="#pyop2.Map.toset" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#pyop2.Set" title="pyop2.Set"><tt class="xref py py-class docutils literal"><span class="pre">Set</span></tt></a> mapped to.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.Map.values">
<tt class="descname">values</tt><a class="headerlink" href="#pyop2.Map.values" title="Permalink to this definition">¶</a></dt>
<dd><p>Mapping array.</p>
<p>This only returns the map values for local points, to see the
halo points too, use <a class="reference internal" href="#pyop2.Map.values_with_halo" title="pyop2.Map.values_with_halo"><tt class="xref py py-meth docutils literal"><span class="pre">values_with_halo()</span></tt></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.Map.values_with_halo">
<tt class="descname">values_with_halo</tt><a class="headerlink" href="#pyop2.Map.values_with_halo" title="Permalink to this definition">¶</a></dt>
<dd><p>Mapping array.</p>
<p>This returns all map values (including halo points), see
<a class="reference internal" href="#pyop2.Map.values" title="pyop2.Map.values"><tt class="xref py py-meth docutils literal"><span class="pre">values()</span></tt></a> if you only need to look at the local
points.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyop2.MixedMap">
<em class="property">class </em><tt class="descclassname">pyop2.</tt><tt class="descname">MixedMap</tt><span class="sig-paren">(</span><em>maps</em><span class="sig-paren">)</span><a class="headerlink" href="#pyop2.MixedMap" title="Permalink to this definition">¶</a></dt>
<dd><p>A container for a bag of <a class="reference internal" href="#pyop2.Map" title="pyop2.Map"><tt class="xref py py-class docutils literal"><span class="pre">Map</span></tt></a>s.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>maps</strong> (<em>iterable</em>) &#8211; Iterable of <a class="reference internal" href="#pyop2.Map" title="pyop2.Map"><tt class="xref py py-class docutils literal"><span class="pre">Map</span></tt></a>s</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="pyop2.MixedMap.arange">
<tt class="descname">arange</tt><a class="headerlink" href="#pyop2.MixedMap.arange" title="Permalink to this definition">¶</a></dt>
<dd><p>Tuple of arity offsets for each constituent <a class="reference internal" href="#pyop2.Map" title="pyop2.Map"><tt class="xref py py-class docutils literal"><span class="pre">Map</span></tt></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.MixedMap.arities">
<tt class="descname">arities</tt><a class="headerlink" href="#pyop2.MixedMap.arities" title="Permalink to this definition">¶</a></dt>
<dd><p>Arity of the mapping: number of toset elements mapped to per
iterset element.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">tuple</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.MixedMap.arity">
<tt class="descname">arity</tt><a class="headerlink" href="#pyop2.MixedMap.arity" title="Permalink to this definition">¶</a></dt>
<dd><p>Arity of the mapping: total number of toset elements mapped to per
iterset element.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.MixedMap.bottom_mask">
<tt class="descname">bottom_mask</tt><a class="headerlink" href="#pyop2.MixedMap.bottom_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>The bottom layer mask to be applied on a mesh cell.</p>
</dd></dl>

<dl class="classmethod">
<dt id="pyop2.MixedMap.fromhdf5">
<em class="property">classmethod </em><tt class="descname">fromhdf5</tt><span class="sig-paren">(</span><em>iterset</em>, <em>toset</em>, <em>f</em>, <em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#pyop2.MixedMap.fromhdf5" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a <a class="reference internal" href="#pyop2.Map" title="pyop2.Map"><tt class="xref py py-class docutils literal"><span class="pre">Map</span></tt></a> from set named <tt class="docutils literal"><span class="pre">name</span></tt> in HDF5 data <tt class="docutils literal"><span class="pre">f</span></tt></p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.MixedMap.implicit_bcs">
<tt class="descname">implicit_bcs</tt><a class="headerlink" href="#pyop2.MixedMap.implicit_bcs" title="Permalink to this definition">¶</a></dt>
<dd><p>Return any implicit (extruded &#8220;top&#8221; or &#8220;bottom&#8221;) bcs to
apply to this <a class="reference internal" href="#pyop2.Map" title="pyop2.Map"><tt class="xref py py-class docutils literal"><span class="pre">Map</span></tt></a>.  Normally empty except in the case of
some <tt class="xref py py-class docutils literal"><span class="pre">DecoratedMap</span></tt>s.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.MixedMap.iteration_region">
<tt class="descname">iteration_region</tt><a class="headerlink" href="#pyop2.MixedMap.iteration_region" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the iteration region for the current map. For a normal map it
will always be ALL. For a <tt class="xref py py-class docutils literal"><span class="pre">DecoratedMap</span></tt> it will specify over which mesh
region the iteration will take place.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.MixedMap.iterset">
<tt class="descname">iterset</tt><a class="headerlink" href="#pyop2.MixedMap.iterset" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#pyop2.MixedSet" title="pyop2.MixedSet"><tt class="xref py py-class docutils literal"><span class="pre">MixedSet</span></tt></a> mapped from.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.MixedMap.name">
<tt class="descname">name</tt><a class="headerlink" href="#pyop2.MixedMap.name" title="Permalink to this definition">¶</a></dt>
<dd><p>User-defined labels</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.MixedMap.offset">
<tt class="descname">offset</tt><a class="headerlink" href="#pyop2.MixedMap.offset" title="Permalink to this definition">¶</a></dt>
<dd><p>Vertical offsets.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.MixedMap.split">
<tt class="descname">split</tt><a class="headerlink" href="#pyop2.MixedMap.split" title="Permalink to this definition">¶</a></dt>
<dd><p>The underlying tuple of <a class="reference internal" href="#pyop2.Map" title="pyop2.Map"><tt class="xref py py-class docutils literal"><span class="pre">Map</span></tt></a>s.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.MixedMap.top_mask">
<tt class="descname">top_mask</tt><a class="headerlink" href="#pyop2.MixedMap.top_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>The top layer mask to be applied on a mesh cell.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.MixedMap.toset">
<tt class="descname">toset</tt><a class="headerlink" href="#pyop2.MixedMap.toset" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#pyop2.MixedSet" title="pyop2.MixedSet"><tt class="xref py py-class docutils literal"><span class="pre">MixedSet</span></tt></a> mapped to.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.MixedMap.values">
<tt class="descname">values</tt><a class="headerlink" href="#pyop2.MixedMap.values" title="Permalink to this definition">¶</a></dt>
<dd><p>Mapping arrays excluding data for halos.</p>
<p>This only returns the map values for local points, to see the
halo points too, use <a class="reference internal" href="#pyop2.MixedMap.values_with_halo" title="pyop2.MixedMap.values_with_halo"><tt class="xref py py-meth docutils literal"><span class="pre">values_with_halo()</span></tt></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.MixedMap.values_with_halo">
<tt class="descname">values_with_halo</tt><a class="headerlink" href="#pyop2.MixedMap.values_with_halo" title="Permalink to this definition">¶</a></dt>
<dd><p>Mapping arrays including data for halos.</p>
<p>This returns all map values (including halo points), see
<a class="reference internal" href="#pyop2.MixedMap.values" title="pyop2.MixedMap.values"><tt class="xref py py-meth docutils literal"><span class="pre">values()</span></tt></a> if you only need to look at the local
points.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyop2.Sparsity">
<em class="property">class </em><tt class="descclassname">pyop2.</tt><tt class="descname">Sparsity</tt><span class="sig-paren">(</span><em>dsets</em>, <em>maps</em>, <em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyop2.Sparsity" title="Permalink to this definition">¶</a></dt>
<dd><p>OP2 Sparsity, the non-zero structure a matrix derived from the union of
the outer product of pairs of <a class="reference internal" href="#pyop2.Map" title="pyop2.Map"><tt class="xref py py-class docutils literal"><span class="pre">Map</span></tt></a> objects.</p>
<p>Examples of constructing a Sparsity:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Sparsity</span><span class="p">(</span><span class="n">single_dset</span><span class="p">,</span> <span class="n">single_map</span><span class="p">,</span> <span class="s">&#39;mass&#39;</span><span class="p">)</span>
<span class="n">Sparsity</span><span class="p">((</span><span class="n">row_dset</span><span class="p">,</span> <span class="n">col_dset</span><span class="p">),</span> <span class="p">(</span><span class="n">single_rowmap</span><span class="p">,</span> <span class="n">single_colmap</span><span class="p">))</span>
<span class="n">Sparsity</span><span class="p">((</span><span class="n">row_dset</span><span class="p">,</span> <span class="n">col_dset</span><span class="p">),</span>
         <span class="p">[(</span><span class="n">first_rowmap</span><span class="p">,</span> <span class="n">first_colmap</span><span class="p">),</span> <span class="p">(</span><span class="n">second_rowmap</span><span class="p">,</span> <span class="n">second_colmap</span><span class="p">)])</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>dsets</strong> &#8211; <a class="reference internal" href="#pyop2.DataSet" title="pyop2.DataSet"><tt class="xref py py-class docutils literal"><span class="pre">DataSet</span></tt></a>s for the left and right function
spaces this <a class="reference internal" href="#pyop2.Sparsity" title="pyop2.Sparsity"><tt class="xref py py-class docutils literal"><span class="pre">Sparsity</span></tt></a> maps between</li>
<li><strong>maps</strong> (a pair of <a class="reference internal" href="#pyop2.Map" title="pyop2.Map"><tt class="xref py py-class docutils literal"><span class="pre">Map</span></tt></a>s specifying a row map and a column
map, or an iterable of pairs of <a class="reference internal" href="#pyop2.Map" title="pyop2.Map"><tt class="xref py py-class docutils literal"><span class="pre">Map</span></tt></a>s specifying multiple
row and column maps - if a single <a class="reference internal" href="#pyop2.Map" title="pyop2.Map"><tt class="xref py py-class docutils literal"><span class="pre">Map</span></tt></a> is passed, it is
used as both a row map and a column map) &#8211; <a class="reference internal" href="#pyop2.Map" title="pyop2.Map"><tt class="xref py py-class docutils literal"><span class="pre">Map</span></tt></a>s to build the <a class="reference internal" href="#pyop2.Sparsity" title="pyop2.Sparsity"><tt class="xref py py-class docutils literal"><span class="pre">Sparsity</span></tt></a> from</li>
<li><strong>name</strong> (<em>string</em>) &#8211; user-defined label (optional)</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="pyop2.Sparsity.cmaps">
<tt class="descname">cmaps</tt><a class="headerlink" href="#pyop2.Sparsity.cmaps" title="Permalink to this definition">¶</a></dt>
<dd><p>The list of column maps this sparsity is assembled from.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.Sparsity.colidx">
<tt class="descname">colidx</tt><a class="headerlink" href="#pyop2.Sparsity.colidx" title="Permalink to this definition">¶</a></dt>
<dd><p>Column indices array of CSR data structure.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.Sparsity.dims">
<tt class="descname">dims</tt><a class="headerlink" href="#pyop2.Sparsity.dims" title="Permalink to this definition">¶</a></dt>
<dd><p>A pair giving the number of rows per entry of the row
<a class="reference internal" href="#pyop2.Set" title="pyop2.Set"><tt class="xref py py-class docutils literal"><span class="pre">Set</span></tt></a> and the number of columns per entry of the column
<a class="reference internal" href="#pyop2.Set" title="pyop2.Set"><tt class="xref py py-class docutils literal"><span class="pre">Set</span></tt></a> of the <tt class="docutils literal"><span class="pre">Sparsity</span></tt>.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.Sparsity.dsets">
<tt class="descname">dsets</tt><a class="headerlink" href="#pyop2.Sparsity.dsets" title="Permalink to this definition">¶</a></dt>
<dd><p>A pair of <a class="reference internal" href="#pyop2.DataSet" title="pyop2.DataSet"><tt class="xref py py-class docutils literal"><span class="pre">DataSet</span></tt></a>s for the left and right function
spaces this <a class="reference internal" href="#pyop2.Sparsity" title="pyop2.Sparsity"><tt class="xref py py-class docutils literal"><span class="pre">Sparsity</span></tt></a> maps between.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.Sparsity.maps">
<tt class="descname">maps</tt><a class="headerlink" href="#pyop2.Sparsity.maps" title="Permalink to this definition">¶</a></dt>
<dd><p>A list of pairs (rmap, cmap) where each pair of
<a class="reference internal" href="#pyop2.Map" title="pyop2.Map"><tt class="xref py py-class docutils literal"><span class="pre">Map</span></tt></a> objects will later be used to assemble into this
matrix. The iterset of each of the maps in a pair must be the
same, while the toset of all the maps which appear first
must be common, this will form the row <a class="reference internal" href="#pyop2.Set" title="pyop2.Set"><tt class="xref py py-class docutils literal"><span class="pre">Set</span></tt></a> of the
sparsity. Similarly, the toset of all the maps which appear
second must be common and will form the column <a class="reference internal" href="#pyop2.Set" title="pyop2.Set"><tt class="xref py py-class docutils literal"><span class="pre">Set</span></tt></a> of
the <tt class="docutils literal"><span class="pre">Sparsity</span></tt>.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.Sparsity.name">
<tt class="descname">name</tt><a class="headerlink" href="#pyop2.Sparsity.name" title="Permalink to this definition">¶</a></dt>
<dd><p>A user-defined label.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.Sparsity.ncols">
<tt class="descname">ncols</tt><a class="headerlink" href="#pyop2.Sparsity.ncols" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of columns in the <tt class="docutils literal"><span class="pre">Sparsity</span></tt>.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.Sparsity.nnz">
<tt class="descname">nnz</tt><a class="headerlink" href="#pyop2.Sparsity.nnz" title="Permalink to this definition">¶</a></dt>
<dd><p>Array containing the number of non-zeroes in the various rows of the
diagonal portion of the local submatrix.</p>
<p>This is the same as the parameter <cite>d_nnz</cite> used for preallocation in
PETSc&#8217;s <a class="reference external" href="http://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/Mat/MatMPIAIJSetPreallocation.html">MatMPIAIJSetPreallocation</a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.Sparsity.nrows">
<tt class="descname">nrows</tt><a class="headerlink" href="#pyop2.Sparsity.nrows" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of rows in the <tt class="docutils literal"><span class="pre">Sparsity</span></tt>.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.Sparsity.nz">
<tt class="descname">nz</tt><a class="headerlink" href="#pyop2.Sparsity.nz" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of non-zeroes in the diagonal portion of the local
submatrix.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.Sparsity.onnz">
<tt class="descname">onnz</tt><a class="headerlink" href="#pyop2.Sparsity.onnz" title="Permalink to this definition">¶</a></dt>
<dd><p>Array containing the number of non-zeroes in the various rows of the
off-diagonal portion of the local submatrix.</p>
<p>This is the same as the parameter <cite>o_nnz</cite> used for preallocation in
PETSc&#8217;s <a class="reference external" href="http://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/Mat/MatMPIAIJSetPreallocation.html">MatMPIAIJSetPreallocation</a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.Sparsity.onz">
<tt class="descname">onz</tt><a class="headerlink" href="#pyop2.Sparsity.onz" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of non-zeroes in the off-diagonal portion of the local
submatrix.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.Sparsity.rmaps">
<tt class="descname">rmaps</tt><a class="headerlink" href="#pyop2.Sparsity.rmaps" title="Permalink to this definition">¶</a></dt>
<dd><p>The list of row maps this sparsity is assembled from.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.Sparsity.rowptr">
<tt class="descname">rowptr</tt><a class="headerlink" href="#pyop2.Sparsity.rowptr" title="Permalink to this definition">¶</a></dt>
<dd><p>Row pointer array of CSR data structure.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.Sparsity.shape">
<tt class="descname">shape</tt><a class="headerlink" href="#pyop2.Sparsity.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of block rows and columns.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyop2.Const">
<em class="property">class </em><tt class="descclassname">pyop2.</tt><tt class="descname">Const</tt><span class="sig-paren">(</span><em>dim</em>, <em>data=None</em>, <em>name=None</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyop2.Const" title="Permalink to this definition">¶</a></dt>
<dd><p>Data that is constant for any element of any set.</p>
<dl class="exception">
<dt id="pyop2.Const.NonUniqueNameError">
<em class="property">exception </em><tt class="descname">NonUniqueNameError</tt><a class="headerlink" href="#pyop2.Const.NonUniqueNameError" title="Permalink to this definition">¶</a></dt>
<dd><p>The Names of const variables are required to be globally unique.
This exception is raised if the name is already in use.</p>
<dl class="attribute">
<dt id="pyop2.Const.NonUniqueNameError.args">
<tt class="descname">args</tt><a class="headerlink" href="#pyop2.Const.NonUniqueNameError.args" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyop2.Const.NonUniqueNameError.message">
<tt class="descname">message</tt><a class="headerlink" href="#pyop2.Const.NonUniqueNameError.message" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyop2.Const.Snapshot">
<em class="property">class </em><tt class="descclassname">Const.</tt><tt class="descname">Snapshot</tt><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#pyop2.Const.Snapshot" title="Permalink to this definition">¶</a></dt>
<dd><p>Overridden from DataCarrier; a snapshot is always valid as long as
the Const object still exists</p>
<dl class="method">
<dt id="pyop2.Const.Snapshot.is_valid">
<tt class="descname">is_valid</tt><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyop2.Const.Snapshot.is_valid" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="pyop2.Const.cdim">
<tt class="descclassname">Const.</tt><tt class="descname">cdim</tt><a class="headerlink" href="#pyop2.Const.cdim" title="Permalink to this definition">¶</a></dt>
<dd><p>The scalar number of values for each member of the object. This is
the product of the dim tuple.</p>
</dd></dl>

<dl class="method">
<dt id="pyop2.Const.create_snapshot">
<tt class="descclassname">Const.</tt><tt class="descname">create_snapshot</tt><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyop2.Const.create_snapshot" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a snapshot of the current object. If not overriden, this
method will return a full duplicate object.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.Const.ctype">
<tt class="descclassname">Const.</tt><tt class="descname">ctype</tt><a class="headerlink" href="#pyop2.Const.ctype" title="Permalink to this definition">¶</a></dt>
<dd><p>The c type of the data.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.Const.data">
<tt class="descclassname">Const.</tt><tt class="descname">data</tt><a class="headerlink" href="#pyop2.Const.data" title="Permalink to this definition">¶</a></dt>
<dd><p>Data array.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.Const.dim">
<tt class="descclassname">Const.</tt><tt class="descname">dim</tt><a class="headerlink" href="#pyop2.Const.dim" title="Permalink to this definition">¶</a></dt>
<dd><p>The shape tuple of the values for each element of the object.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.Const.dtype">
<tt class="descclassname">Const.</tt><tt class="descname">dtype</tt><a class="headerlink" href="#pyop2.Const.dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>The Python type of the data.</p>
</dd></dl>

<dl class="method">
<dt id="pyop2.Const.duplicate">
<tt class="descclassname">Const.</tt><tt class="descname">duplicate</tt><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyop2.Const.duplicate" title="Permalink to this definition">¶</a></dt>
<dd><p>A Const duplicate can always refer to the same data vector, since
it&#8217;s read-only</p>
</dd></dl>

<dl class="classmethod">
<dt id="pyop2.Const.fromhdf5">
<em class="property">classmethod </em><tt class="descclassname">Const.</tt><tt class="descname">fromhdf5</tt><span class="sig-paren">(</span><em>f</em>, <em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#pyop2.Const.fromhdf5" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a <a class="reference internal" href="#pyop2.Const" title="pyop2.Const"><tt class="xref py py-class docutils literal"><span class="pre">Const</span></tt></a> from const named <tt class="docutils literal"><span class="pre">name</span></tt> in HDF5 data <tt class="docutils literal"><span class="pre">f</span></tt></p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.Const.name">
<tt class="descclassname">Const.</tt><tt class="descname">name</tt><a class="headerlink" href="#pyop2.Const.name" title="Permalink to this definition">¶</a></dt>
<dd><p>User-defined label.</p>
</dd></dl>

<dl class="method">
<dt id="pyop2.Const.remove_from_namespace">
<tt class="descclassname">Const.</tt><tt class="descname">remove_from_namespace</tt><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyop2.Const.remove_from_namespace" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove this Const object from the namespace</p>
<p>This allows the same name to be redeclared with a different shape.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyop2.Global">
<em class="property">class </em><tt class="descclassname">pyop2.</tt><tt class="descname">Global</tt><span class="sig-paren">(</span><em>dim</em>, <em>data=None</em>, <em>dtype=None</em>, <em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyop2.Global" title="Permalink to this definition">¶</a></dt>
<dd><p>OP2 global value.</p>
<p>When a <tt class="docutils literal"><span class="pre">Global</span></tt> is passed to a <a class="reference internal" href="pyop2.html#pyop2.op2.par_loop" title="pyop2.op2.par_loop"><tt class="xref py py-func docutils literal"><span class="pre">pyop2.op2.par_loop()</span></tt></a>, the access
descriptor is passed by <cite>calling</cite> the <tt class="docutils literal"><span class="pre">Global</span></tt>.  For example, if
a <tt class="docutils literal"><span class="pre">Global</span></tt> named <tt class="docutils literal"><span class="pre">G</span></tt> is to be accessed for reading, this is
accomplished by:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">G</span><span class="p">(</span><span class="n">pyop2</span><span class="o">.</span><span class="n">READ</span><span class="p">)</span>
</pre></div>
</div>
<p>It is permissible to pass <cite>None</cite> as the <cite>data</cite> argument.  In this
case, allocation of the data buffer is postponed until it is
accessed.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If the data buffer is not passed in, it is implicitly
initialised to be zero.</p>
</div>
<dl class="class">
<dt id="pyop2.Global.Snapshot">
<em class="property">class </em><tt class="descname">Snapshot</tt><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#pyop2.Global.Snapshot" title="Permalink to this definition">¶</a></dt>
<dd><p>A snapshot of the current state of the DataCarrier object. If
is_valid() returns True, then the object hasn&#8217;t changed since this
snapshot was taken (and still exists).</p>
<dl class="method">
<dt id="pyop2.Global.Snapshot.is_valid">
<tt class="descname">is_valid</tt><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyop2.Global.Snapshot.is_valid" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="pyop2.Global.cdim">
<tt class="descclassname">Global.</tt><tt class="descname">cdim</tt><a class="headerlink" href="#pyop2.Global.cdim" title="Permalink to this definition">¶</a></dt>
<dd><p>The scalar number of values for each member of the object. This is
the product of the dim tuple.</p>
</dd></dl>

<dl class="method">
<dt id="pyop2.Global.create_snapshot">
<tt class="descclassname">Global.</tt><tt class="descname">create_snapshot</tt><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyop2.Global.create_snapshot" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a snapshot of the current object. If not overriden, this
method will return a full duplicate object.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.Global.ctype">
<tt class="descclassname">Global.</tt><tt class="descname">ctype</tt><a class="headerlink" href="#pyop2.Global.ctype" title="Permalink to this definition">¶</a></dt>
<dd><p>The c type of the data.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.Global.data">
<tt class="descclassname">Global.</tt><tt class="descname">data</tt><a class="headerlink" href="#pyop2.Global.data" title="Permalink to this definition">¶</a></dt>
<dd><p>Data array.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.Global.data_ro">
<tt class="descclassname">Global.</tt><tt class="descname">data_ro</tt><a class="headerlink" href="#pyop2.Global.data_ro" title="Permalink to this definition">¶</a></dt>
<dd><p>Data array.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.Global.dim">
<tt class="descclassname">Global.</tt><tt class="descname">dim</tt><a class="headerlink" href="#pyop2.Global.dim" title="Permalink to this definition">¶</a></dt>
<dd><p>The shape tuple of the values for each element of the object.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.Global.dtype">
<tt class="descclassname">Global.</tt><tt class="descname">dtype</tt><a class="headerlink" href="#pyop2.Global.dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyop2.Global.duplicate">
<tt class="descclassname">Global.</tt><tt class="descname">duplicate</tt><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyop2.Global.duplicate" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a deep copy of self.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.Global.name">
<tt class="descclassname">Global.</tt><tt class="descname">name</tt><a class="headerlink" href="#pyop2.Global.name" title="Permalink to this definition">¶</a></dt>
<dd><p>User-defined label.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.Global.nbytes">
<tt class="descclassname">Global.</tt><tt class="descname">nbytes</tt><a class="headerlink" href="#pyop2.Global.nbytes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an estimate of the size of the data associated with this
<a class="reference internal" href="#pyop2.Global" title="pyop2.Global"><tt class="xref py py-class docutils literal"><span class="pre">Global</span></tt></a> in bytes. This will be the correct size of the
data payload, but does not take into account the overhead of
the object and its metadata. This renders this method of
little statistical significance, however it is included to
make the interface consistent.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.Global.shape">
<tt class="descclassname">Global.</tt><tt class="descname">shape</tt><a class="headerlink" href="#pyop2.Global.shape" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyop2.Global.soa">
<tt class="descclassname">Global.</tt><tt class="descname">soa</tt><a class="headerlink" href="#pyop2.Global.soa" title="Permalink to this definition">¶</a></dt>
<dd><p>Are the data in SoA format? This is always false for <a class="reference internal" href="#pyop2.Global" title="pyop2.Global"><tt class="xref py py-class docutils literal"><span class="pre">Global</span></tt></a>
objects.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyop2.Dat">
<em class="property">class </em><tt class="descclassname">pyop2.</tt><tt class="descname">Dat</tt><span class="sig-paren">(</span><em>dataset</em>, <em>data=None</em>, <em>dtype=None</em>, <em>name=None</em>, <em>soa=None</em>, <em>uid=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyop2.Dat" title="Permalink to this definition">¶</a></dt>
<dd><p>OP2 vector data. A <a class="reference internal" href="#pyop2.Dat" title="pyop2.Dat"><tt class="xref py py-class docutils literal"><span class="pre">Dat</span></tt></a> holds values on every element of a
<a class="reference internal" href="#pyop2.DataSet" title="pyop2.DataSet"><tt class="xref py py-class docutils literal"><span class="pre">DataSet</span></tt></a>.</p>
<p>If a <a class="reference internal" href="#pyop2.Set" title="pyop2.Set"><tt class="xref py py-class docutils literal"><span class="pre">Set</span></tt></a> is passed as the <tt class="docutils literal"><span class="pre">dataset</span></tt> argument, rather
than a <a class="reference internal" href="#pyop2.DataSet" title="pyop2.DataSet"><tt class="xref py py-class docutils literal"><span class="pre">DataSet</span></tt></a>, the <a class="reference internal" href="#pyop2.Dat" title="pyop2.Dat"><tt class="xref py py-class docutils literal"><span class="pre">Dat</span></tt></a> is created with a default
<a class="reference internal" href="#pyop2.DataSet" title="pyop2.DataSet"><tt class="xref py py-class docutils literal"><span class="pre">DataSet</span></tt></a> dimension of 1.</p>
<p>If a <a class="reference internal" href="#pyop2.Dat" title="pyop2.Dat"><tt class="xref py py-class docutils literal"><span class="pre">Dat</span></tt></a> is passed as the <tt class="docutils literal"><span class="pre">dataset</span></tt> argument, a copy is
returned.</p>
<p>It is permissible to pass <cite>None</cite> as the <cite>data</cite> argument.  In this
case, allocation of the data buffer is postponed until it is
accessed.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If the data buffer is not passed in, it is implicitly
initialised to be zero.</p>
</div>
<p>When a <a class="reference internal" href="#pyop2.Dat" title="pyop2.Dat"><tt class="xref py py-class docutils literal"><span class="pre">Dat</span></tt></a> is passed to <a class="reference internal" href="pyop2.html#pyop2.op2.par_loop" title="pyop2.op2.par_loop"><tt class="xref py py-func docutils literal"><span class="pre">pyop2.op2.par_loop()</span></tt></a>, the map via
which indirection occurs and the access descriptor are passed by
calling the <a class="reference internal" href="#pyop2.Dat" title="pyop2.Dat"><tt class="xref py py-class docutils literal"><span class="pre">Dat</span></tt></a>. For instance, if a <a class="reference internal" href="#pyop2.Dat" title="pyop2.Dat"><tt class="xref py py-class docutils literal"><span class="pre">Dat</span></tt></a> named <tt class="docutils literal"><span class="pre">D</span></tt> is
to be accessed for reading via a <a class="reference internal" href="#pyop2.Map" title="pyop2.Map"><tt class="xref py py-class docutils literal"><span class="pre">Map</span></tt></a> named <tt class="docutils literal"><span class="pre">M</span></tt>, this is
accomplished by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">D</span><span class="p">(</span><span class="n">pyop2</span><span class="o">.</span><span class="n">READ</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="#pyop2.Map" title="pyop2.Map"><tt class="xref py py-class docutils literal"><span class="pre">Map</span></tt></a> through which indirection occurs can be indexed
using the index notation described in the documentation for the
<a class="reference internal" href="#pyop2.Map" title="pyop2.Map"><tt class="xref py py-class docutils literal"><span class="pre">Map</span></tt></a>. Direct access to a Dat is accomplished by
omitting the path argument.</p>
<p><a class="reference internal" href="#pyop2.Dat" title="pyop2.Dat"><tt class="xref py py-class docutils literal"><span class="pre">Dat</span></tt></a> objects support the pointwise linear algebra operations
<tt class="docutils literal"><span class="pre">+=</span></tt>, <tt class="docutils literal"><span class="pre">*=</span></tt>, <tt class="docutils literal"><span class="pre">-=</span></tt>, <tt class="docutils literal"><span class="pre">/=</span></tt>, where <tt class="docutils literal"><span class="pre">*=</span></tt> and <tt class="docutils literal"><span class="pre">/=</span></tt> also support
multiplication / division by a scalar.</p>
<dl class="class">
<dt id="pyop2.Dat.Snapshot">
<em class="property">class </em><tt class="descname">Snapshot</tt><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#pyop2.Dat.Snapshot" title="Permalink to this definition">¶</a></dt>
<dd><p>A snapshot for SetAssociated objects is valid if the snapshot
version is the same as the current version of the object</p>
<dl class="method">
<dt id="pyop2.Dat.Snapshot.is_valid">
<tt class="descname">is_valid</tt><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyop2.Dat.Snapshot.is_valid" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="pyop2.Dat.cdim">
<tt class="descclassname">Dat.</tt><tt class="descname">cdim</tt><a class="headerlink" href="#pyop2.Dat.cdim" title="Permalink to this definition">¶</a></dt>
<dd><p>The scalar number of values for each member of the object. This is
the product of the dim tuple.</p>
</dd></dl>

<dl class="method">
<dt id="pyop2.Dat.copy">
<tt class="descclassname">Dat.</tt><tt class="descname">copy</tt><span class="sig-paren">(</span><em>other</em>, <em>subset=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyop2.Dat.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy the data in this <a class="reference internal" href="#pyop2.Dat" title="pyop2.Dat"><tt class="xref py py-class docutils literal"><span class="pre">Dat</span></tt></a> into another.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>other</strong> &#8211; The destination <a class="reference internal" href="#pyop2.Dat" title="pyop2.Dat"><tt class="xref py py-class docutils literal"><span class="pre">Dat</span></tt></a></li>
<li><strong>subset</strong> &#8211; A <a class="reference internal" href="#pyop2.Subset" title="pyop2.Subset"><tt class="xref py py-class docutils literal"><span class="pre">Subset</span></tt></a> of elements to copy (optional)</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>This function is logically collective over MPI ranks, it is an
error to call it on fewer than all the ranks in MPI communicator.</p>
</dd></dl>

<dl class="method">
<dt id="pyop2.Dat.create_snapshot">
<tt class="descclassname">Dat.</tt><tt class="descname">create_snapshot</tt><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyop2.Dat.create_snapshot" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a snapshot of the current object. If not overriden, this
method will return a full duplicate object.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.Dat.ctype">
<tt class="descclassname">Dat.</tt><tt class="descname">ctype</tt><a class="headerlink" href="#pyop2.Dat.ctype" title="Permalink to this definition">¶</a></dt>
<dd><p>The c type of the data.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.Dat.data">
<tt class="descclassname">Dat.</tt><tt class="descname">data</tt><a class="headerlink" href="#pyop2.Dat.data" title="Permalink to this definition">¶</a></dt>
<dd><p>Numpy array containing the data values.</p>
<p>With this accessor you are claiming that you will modify
the values you get back.  If you only need to look at the
values, use <a class="reference internal" href="#pyop2.Dat.data_ro" title="pyop2.Dat.data_ro"><tt class="xref py py-meth docutils literal"><span class="pre">data_ro()</span></tt></a> instead.</p>
<p>This only shows local values, to see the halo values too use
<a class="reference internal" href="#pyop2.Dat.data_with_halos" title="pyop2.Dat.data_with_halos"><tt class="xref py py-meth docutils literal"><span class="pre">data_with_halos()</span></tt></a>.</p>
<p>This function is logically collective over MPI ranks, it is an
error to call it on fewer than all the ranks in MPI communicator.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.Dat.data_ro">
<tt class="descclassname">Dat.</tt><tt class="descname">data_ro</tt><a class="headerlink" href="#pyop2.Dat.data_ro" title="Permalink to this definition">¶</a></dt>
<dd><p>Numpy array containing the data values.  Read-only.</p>
<p>With this accessor you are not allowed to modify the values
you get back.  If you need to do so, use <a class="reference internal" href="#pyop2.Dat.data" title="pyop2.Dat.data"><tt class="xref py py-meth docutils literal"><span class="pre">data()</span></tt></a> instead.</p>
<p>This only shows local values, to see the halo values too use
<a class="reference internal" href="#pyop2.Dat.data_ro_with_halos" title="pyop2.Dat.data_ro_with_halos"><tt class="xref py py-meth docutils literal"><span class="pre">data_ro_with_halos()</span></tt></a>.</p>
<p>This function is logically collective over MPI ranks, it is an
error to call it on fewer than all the ranks in MPI communicator.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.Dat.data_ro_with_halos">
<tt class="descclassname">Dat.</tt><tt class="descname">data_ro_with_halos</tt><a class="headerlink" href="#pyop2.Dat.data_ro_with_halos" title="Permalink to this definition">¶</a></dt>
<dd><p>A view of this <a class="reference internal" href="#pyop2.Dat" title="pyop2.Dat"><tt class="xref py py-class docutils literal"><span class="pre">Dat</span></tt></a>s data.</p>
<p>This accessor does not mark the <a class="reference internal" href="#pyop2.Dat" title="pyop2.Dat"><tt class="xref py py-class docutils literal"><span class="pre">Dat</span></tt></a> as dirty, and is
a read only view, see <a class="reference internal" href="#pyop2.Dat.data_ro" title="pyop2.Dat.data_ro"><tt class="xref py py-meth docutils literal"><span class="pre">data_ro()</span></tt></a> for more details on the
semantics.</p>
<p>With this accessor, you get to see up to date halo values, but
you should not try and modify them, because they will be
overwritten by the next halo exchange.</p>
<p>This function is logically collective over MPI ranks, it is an
error to call it on fewer than all the ranks in MPI communicator.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.Dat.data_with_halos">
<tt class="descclassname">Dat.</tt><tt class="descname">data_with_halos</tt><a class="headerlink" href="#pyop2.Dat.data_with_halos" title="Permalink to this definition">¶</a></dt>
<dd><p>A view of this <a class="reference internal" href="#pyop2.Dat" title="pyop2.Dat"><tt class="xref py py-class docutils literal"><span class="pre">Dat</span></tt></a>s data.</p>
<p>This accessor marks the <a class="reference internal" href="#pyop2.Dat" title="pyop2.Dat"><tt class="xref py py-class docutils literal"><span class="pre">Dat</span></tt></a> as dirty, see
<a class="reference internal" href="#pyop2.Dat.data" title="pyop2.Dat.data"><tt class="xref py py-meth docutils literal"><span class="pre">data()</span></tt></a> for more details on the semantics.</p>
<p>With this accessor, you get to see up to date halo values, but
you should not try and modify them, because they will be
overwritten by the next halo exchange.</p>
<p>This function is logically collective over MPI ranks, it is an
error to call it on fewer than all the ranks in MPI communicator.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.Dat.dataset">
<tt class="descclassname">Dat.</tt><tt class="descname">dataset</tt><a class="headerlink" href="#pyop2.Dat.dataset" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#pyop2.DataSet" title="pyop2.DataSet"><tt class="xref py py-class docutils literal"><span class="pre">DataSet</span></tt></a> on which the Dat is defined.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.Dat.dim">
<tt class="descclassname">Dat.</tt><tt class="descname">dim</tt><a class="headerlink" href="#pyop2.Dat.dim" title="Permalink to this definition">¶</a></dt>
<dd><p>The shape of the values for each element of the object.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.Dat.dtype">
<tt class="descclassname">Dat.</tt><tt class="descname">dtype</tt><a class="headerlink" href="#pyop2.Dat.dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyop2.Dat.duplicate">
<tt class="descclassname">Dat.</tt><tt class="descname">duplicate</tt><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyop2.Dat.duplicate" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="classmethod">
<dt id="pyop2.Dat.fromhdf5">
<em class="property">classmethod </em><tt class="descclassname">Dat.</tt><tt class="descname">fromhdf5</tt><span class="sig-paren">(</span><em>dataset</em>, <em>f</em>, <em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#pyop2.Dat.fromhdf5" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a <a class="reference internal" href="#pyop2.Dat" title="pyop2.Dat"><tt class="xref py py-class docutils literal"><span class="pre">Dat</span></tt></a> from a Dat named <tt class="docutils literal"><span class="pre">name</span></tt> in HDF5 data <tt class="docutils literal"><span class="pre">f</span></tt></p>
</dd></dl>

<dl class="method">
<dt id="pyop2.Dat.halo_exchange_begin">
<tt class="descclassname">Dat.</tt><tt class="descname">halo_exchange_begin</tt><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyop2.Dat.halo_exchange_begin" title="Permalink to this definition">¶</a></dt>
<dd><p>Begin halo exchange.</p>
<p>This function is logically collective over MPI ranks, it is an
error to call it on fewer than all the ranks in MPI communicator.</p>
</dd></dl>

<dl class="method">
<dt id="pyop2.Dat.halo_exchange_end">
<tt class="descclassname">Dat.</tt><tt class="descname">halo_exchange_end</tt><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyop2.Dat.halo_exchange_end" title="Permalink to this definition">¶</a></dt>
<dd><p>End halo exchange. Waits on MPI recv.</p>
<p>This function is logically collective over MPI ranks, it is an
error to call it on fewer than all the ranks in MPI communicator.</p>
</dd></dl>

<dl class="method">
<dt id="pyop2.Dat.inner">
<tt class="descclassname">Dat.</tt><tt class="descname">inner</tt><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#pyop2.Dat.inner" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the l2 inner product of the flattened <a class="reference internal" href="#pyop2.Dat" title="pyop2.Dat"><tt class="xref py py-class docutils literal"><span class="pre">Dat</span></tt></a></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>other</strong> &#8211; the other <a class="reference internal" href="#pyop2.Dat" title="pyop2.Dat"><tt class="xref py py-class docutils literal"><span class="pre">Dat</span></tt></a> to compute the inner
product against.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyop2.Dat.load">
<tt class="descclassname">Dat.</tt><tt class="descname">load</tt><span class="sig-paren">(</span><em>filename</em><span class="sig-paren">)</span><a class="headerlink" href="#pyop2.Dat.load" title="Permalink to this definition">¶</a></dt>
<dd><p>Read the data stored in file <tt class="docutils literal"><span class="pre">filename</span></tt> into a NumPy array
and store the values in <tt class="xref py py-meth docutils literal"><span class="pre">_data()</span></tt>.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.Dat.name">
<tt class="descclassname">Dat.</tt><tt class="descname">name</tt><a class="headerlink" href="#pyop2.Dat.name" title="Permalink to this definition">¶</a></dt>
<dd><p>User-defined label.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.Dat.nbytes">
<tt class="descclassname">Dat.</tt><tt class="descname">nbytes</tt><a class="headerlink" href="#pyop2.Dat.nbytes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an estimate of the size of the data associated with this
<a class="reference internal" href="#pyop2.Dat" title="pyop2.Dat"><tt class="xref py py-class docutils literal"><span class="pre">Dat</span></tt></a> in bytes. This will be the correct size of the data
payload, but does not take into account the (presumably small)
overhead of the object and its metadata.</p>
<p>Note that this is the process local memory usage, not the sum
over all MPI processes.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.Dat.needs_halo_update">
<tt class="descclassname">Dat.</tt><tt class="descname">needs_halo_update</tt><a class="headerlink" href="#pyop2.Dat.needs_halo_update" title="Permalink to this definition">¶</a></dt>
<dd><p>Has this <a class="reference internal" href="#pyop2.Dat" title="pyop2.Dat"><tt class="xref py py-class docutils literal"><span class="pre">Dat</span></tt></a> been written to since the last halo exchange?</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.Dat.norm">
<tt class="descclassname">Dat.</tt><tt class="descname">norm</tt><a class="headerlink" href="#pyop2.Dat.norm" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the l2 norm of this <a class="reference internal" href="#pyop2.Dat" title="pyop2.Dat"><tt class="xref py py-class docutils literal"><span class="pre">Dat</span></tt></a></p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This acts on the flattened data (see also <a class="reference internal" href="#pyop2.Dat.inner" title="pyop2.Dat.inner"><tt class="xref py py-meth docutils literal"><span class="pre">inner()</span></tt></a>).</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pyop2.Dat.save">
<tt class="descclassname">Dat.</tt><tt class="descname">save</tt><span class="sig-paren">(</span><em>filename</em><span class="sig-paren">)</span><a class="headerlink" href="#pyop2.Dat.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Write the data array to file <tt class="docutils literal"><span class="pre">filename</span></tt> in NumPy format.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.Dat.shape">
<tt class="descclassname">Dat.</tt><tt class="descname">shape</tt><a class="headerlink" href="#pyop2.Dat.shape" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyop2.Dat.soa">
<tt class="descclassname">Dat.</tt><tt class="descname">soa</tt><a class="headerlink" href="#pyop2.Dat.soa" title="Permalink to this definition">¶</a></dt>
<dd><p>Are the data in SoA format?</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.Dat.split">
<tt class="descclassname">Dat.</tt><tt class="descname">split</tt><a class="headerlink" href="#pyop2.Dat.split" title="Permalink to this definition">¶</a></dt>
<dd><p>Tuple containing only this <a class="reference internal" href="#pyop2.Dat" title="pyop2.Dat"><tt class="xref py py-class docutils literal"><span class="pre">Dat</span></tt></a>.</p>
</dd></dl>

<dl class="method">
<dt id="pyop2.Dat.zero">
<tt class="descclassname">Dat.</tt><tt class="descname">zero</tt><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyop2.Dat.zero" title="Permalink to this definition">¶</a></dt>
<dd><p>Zero the data associated with this <a class="reference internal" href="#pyop2.Dat" title="pyop2.Dat"><tt class="xref py py-class docutils literal"><span class="pre">Dat</span></tt></a></p>
<p>This function is logically collective over MPI ranks, it is an
error to call it on fewer than all the ranks in MPI communicator.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyop2.MixedDat">
<em class="property">class </em><tt class="descclassname">pyop2.</tt><tt class="descname">MixedDat</tt><span class="sig-paren">(</span><em>mdset_or_dats</em><span class="sig-paren">)</span><a class="headerlink" href="#pyop2.MixedDat" title="Permalink to this definition">¶</a></dt>
<dd><p>A container for a bag of <a class="reference internal" href="#pyop2.Dat" title="pyop2.Dat"><tt class="xref py py-class docutils literal"><span class="pre">Dat</span></tt></a>s.</p>
<p>Initialized either from a <a class="reference internal" href="#pyop2.MixedDataSet" title="pyop2.MixedDataSet"><tt class="xref py py-class docutils literal"><span class="pre">MixedDataSet</span></tt></a>, a <a class="reference internal" href="#pyop2.MixedSet" title="pyop2.MixedSet"><tt class="xref py py-class docutils literal"><span class="pre">MixedSet</span></tt></a>, or
an iterable of <a class="reference internal" href="#pyop2.DataSet" title="pyop2.DataSet"><tt class="xref py py-class docutils literal"><span class="pre">DataSet</span></tt></a>s and/or <a class="reference internal" href="#pyop2.Set" title="pyop2.Set"><tt class="xref py py-class docutils literal"><span class="pre">Set</span></tt></a>s, where all the
<a class="reference internal" href="#pyop2.Set" title="pyop2.Set"><tt class="xref py py-class docutils literal"><span class="pre">Set</span></tt></a>s are implcitly upcast to <a class="reference internal" href="#pyop2.DataSet" title="pyop2.DataSet"><tt class="xref py py-class docutils literal"><span class="pre">DataSet</span></tt></a>s</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">mdat</span> <span class="o">=</span> <span class="n">op2</span><span class="o">.</span><span class="n">MixedDat</span><span class="p">(</span><span class="n">mdset</span><span class="p">)</span>
<span class="n">mdat</span> <span class="o">=</span> <span class="n">op2</span><span class="o">.</span><span class="n">MixedDat</span><span class="p">([</span><span class="n">dset1</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">dsetN</span><span class="p">])</span>
</pre></div>
</div>
<p>or from an iterable of <a class="reference internal" href="#pyop2.Dat" title="pyop2.Dat"><tt class="xref py py-class docutils literal"><span class="pre">Dat</span></tt></a>s</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">mdat</span> <span class="o">=</span> <span class="n">op2</span><span class="o">.</span><span class="n">MixedDat</span><span class="p">([</span><span class="n">dat1</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">datN</span><span class="p">])</span>
</pre></div>
</div>
<dl class="class">
<dt id="pyop2.MixedDat.Snapshot">
<em class="property">class </em><tt class="descname">Snapshot</tt><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#pyop2.MixedDat.Snapshot" title="Permalink to this definition">¶</a></dt>
<dd><p>A snapshot for SetAssociated objects is valid if the snapshot
version is the same as the current version of the object</p>
<dl class="method">
<dt id="pyop2.MixedDat.Snapshot.is_valid">
<tt class="descname">is_valid</tt><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyop2.MixedDat.Snapshot.is_valid" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="pyop2.MixedDat.cdim">
<tt class="descclassname">MixedDat.</tt><tt class="descname">cdim</tt><a class="headerlink" href="#pyop2.MixedDat.cdim" title="Permalink to this definition">¶</a></dt>
<dd><p>The scalar number of values for each member of the object. This is
the product of the dim tuple.</p>
</dd></dl>

<dl class="method">
<dt id="pyop2.MixedDat.copy">
<tt class="descclassname">MixedDat.</tt><tt class="descname">copy</tt><span class="sig-paren">(</span><em>other</em>, <em>subset=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyop2.MixedDat.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy the data in this <a class="reference internal" href="#pyop2.MixedDat" title="pyop2.MixedDat"><tt class="xref py py-class docutils literal"><span class="pre">MixedDat</span></tt></a> into another.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>other</strong> &#8211; The destination <a class="reference internal" href="#pyop2.MixedDat" title="pyop2.MixedDat"><tt class="xref py py-class docutils literal"><span class="pre">MixedDat</span></tt></a></li>
<li><strong>subset</strong> &#8211; Subsets are not supported, this must be <tt class="xref py py-class docutils literal"><span class="pre">None</span></tt></li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>This function is logically collective over MPI ranks, it is an
error to call it on fewer than all the ranks in MPI communicator.</p>
</dd></dl>

<dl class="method">
<dt id="pyop2.MixedDat.create_snapshot">
<tt class="descclassname">MixedDat.</tt><tt class="descname">create_snapshot</tt><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyop2.MixedDat.create_snapshot" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a snapshot of the current object. If not overriden, this
method will return a full duplicate object.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.MixedDat.ctype">
<tt class="descclassname">MixedDat.</tt><tt class="descname">ctype</tt><a class="headerlink" href="#pyop2.MixedDat.ctype" title="Permalink to this definition">¶</a></dt>
<dd><p>The c type of the data.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.MixedDat.data">
<tt class="descclassname">MixedDat.</tt><tt class="descname">data</tt><a class="headerlink" href="#pyop2.MixedDat.data" title="Permalink to this definition">¶</a></dt>
<dd><p>Numpy arrays containing the data excluding halos.</p>
<p>This function is logically collective over MPI ranks, it is an
error to call it on fewer than all the ranks in MPI communicator.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.MixedDat.data_ro">
<tt class="descclassname">MixedDat.</tt><tt class="descname">data_ro</tt><a class="headerlink" href="#pyop2.MixedDat.data_ro" title="Permalink to this definition">¶</a></dt>
<dd><p>Numpy arrays with read-only data excluding halos.</p>
<p>This function is logically collective over MPI ranks, it is an
error to call it on fewer than all the ranks in MPI communicator.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.MixedDat.data_ro_with_halos">
<tt class="descclassname">MixedDat.</tt><tt class="descname">data_ro_with_halos</tt><a class="headerlink" href="#pyop2.MixedDat.data_ro_with_halos" title="Permalink to this definition">¶</a></dt>
<dd><p>Numpy arrays with read-only data including halos.</p>
<p>This function is logically collective over MPI ranks, it is an
error to call it on fewer than all the ranks in MPI communicator.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.MixedDat.data_with_halos">
<tt class="descclassname">MixedDat.</tt><tt class="descname">data_with_halos</tt><a class="headerlink" href="#pyop2.MixedDat.data_with_halos" title="Permalink to this definition">¶</a></dt>
<dd><p>Numpy arrays containing the data including halos.</p>
<p>This function is logically collective over MPI ranks, it is an
error to call it on fewer than all the ranks in MPI communicator.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.MixedDat.dataset">
<tt class="descclassname">MixedDat.</tt><tt class="descname">dataset</tt><a class="headerlink" href="#pyop2.MixedDat.dataset" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#pyop2.MixedDataSet" title="pyop2.MixedDataSet"><tt class="xref py py-class docutils literal"><span class="pre">MixedDataSet</span></tt></a>s this <a class="reference internal" href="#pyop2.MixedDat" title="pyop2.MixedDat"><tt class="xref py py-class docutils literal"><span class="pre">MixedDat</span></tt></a> is defined on.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.MixedDat.dim">
<tt class="descclassname">MixedDat.</tt><tt class="descname">dim</tt><a class="headerlink" href="#pyop2.MixedDat.dim" title="Permalink to this definition">¶</a></dt>
<dd><p>The shape of the values for each element of the object.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.MixedDat.dtype">
<tt class="descclassname">MixedDat.</tt><tt class="descname">dtype</tt><a class="headerlink" href="#pyop2.MixedDat.dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>The NumPy dtype of the data.</p>
</dd></dl>

<dl class="method">
<dt id="pyop2.MixedDat.duplicate">
<tt class="descclassname">MixedDat.</tt><tt class="descname">duplicate</tt><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyop2.MixedDat.duplicate" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="classmethod">
<dt id="pyop2.MixedDat.fromhdf5">
<em class="property">classmethod </em><tt class="descclassname">MixedDat.</tt><tt class="descname">fromhdf5</tt><span class="sig-paren">(</span><em>dataset</em>, <em>f</em>, <em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#pyop2.MixedDat.fromhdf5" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a <a class="reference internal" href="#pyop2.Dat" title="pyop2.Dat"><tt class="xref py py-class docutils literal"><span class="pre">Dat</span></tt></a> from a Dat named <tt class="docutils literal"><span class="pre">name</span></tt> in HDF5 data <tt class="docutils literal"><span class="pre">f</span></tt></p>
</dd></dl>

<dl class="method">
<dt id="pyop2.MixedDat.halo_exchange_begin">
<tt class="descclassname">MixedDat.</tt><tt class="descname">halo_exchange_begin</tt><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyop2.MixedDat.halo_exchange_begin" title="Permalink to this definition">¶</a></dt>
<dd><p>This function is logically collective over MPI ranks, it is an
error to call it on fewer than all the ranks in MPI communicator.</p>
</dd></dl>

<dl class="method">
<dt id="pyop2.MixedDat.halo_exchange_end">
<tt class="descclassname">MixedDat.</tt><tt class="descname">halo_exchange_end</tt><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyop2.MixedDat.halo_exchange_end" title="Permalink to this definition">¶</a></dt>
<dd><p>This function is logically collective over MPI ranks, it is an
error to call it on fewer than all the ranks in MPI communicator.</p>
</dd></dl>

<dl class="method">
<dt id="pyop2.MixedDat.inner">
<tt class="descclassname">MixedDat.</tt><tt class="descname">inner</tt><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#pyop2.MixedDat.inner" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the l2 inner product.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>other</strong> &#8211; the other <a class="reference internal" href="#pyop2.MixedDat" title="pyop2.MixedDat"><tt class="xref py py-class docutils literal"><span class="pre">MixedDat</span></tt></a> to compute the inner product against</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyop2.MixedDat.load">
<tt class="descclassname">MixedDat.</tt><tt class="descname">load</tt><span class="sig-paren">(</span><em>filename</em><span class="sig-paren">)</span><a class="headerlink" href="#pyop2.MixedDat.load" title="Permalink to this definition">¶</a></dt>
<dd><p>Read the data stored in file <tt class="docutils literal"><span class="pre">filename</span></tt> into a NumPy array
and store the values in <tt class="xref py py-meth docutils literal"><span class="pre">_data()</span></tt>.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.MixedDat.name">
<tt class="descclassname">MixedDat.</tt><tt class="descname">name</tt><a class="headerlink" href="#pyop2.MixedDat.name" title="Permalink to this definition">¶</a></dt>
<dd><p>User-defined label.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.MixedDat.nbytes">
<tt class="descclassname">MixedDat.</tt><tt class="descname">nbytes</tt><a class="headerlink" href="#pyop2.MixedDat.nbytes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an estimate of the size of the data associated with this
<a class="reference internal" href="#pyop2.MixedDat" title="pyop2.MixedDat"><tt class="xref py py-class docutils literal"><span class="pre">MixedDat</span></tt></a> in bytes. This will be the correct size of the data
payload, but does not take into account the (presumably small)
overhead of the object and its metadata.</p>
<p>Note that this is the process local memory usage, not the sum
over all MPI processes.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.MixedDat.needs_halo_update">
<tt class="descclassname">MixedDat.</tt><tt class="descname">needs_halo_update</tt><a class="headerlink" href="#pyop2.MixedDat.needs_halo_update" title="Permalink to this definition">¶</a></dt>
<dd><p>Has this Dat been written to since the last halo exchange?</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.MixedDat.norm">
<tt class="descclassname">MixedDat.</tt><tt class="descname">norm</tt><a class="headerlink" href="#pyop2.MixedDat.norm" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the l2 norm of this <a class="reference internal" href="#pyop2.Dat" title="pyop2.Dat"><tt class="xref py py-class docutils literal"><span class="pre">Dat</span></tt></a></p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This acts on the flattened data (see also <a class="reference internal" href="#pyop2.MixedDat.inner" title="pyop2.MixedDat.inner"><tt class="xref py py-meth docutils literal"><span class="pre">inner()</span></tt></a>).</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pyop2.MixedDat.save">
<tt class="descclassname">MixedDat.</tt><tt class="descname">save</tt><span class="sig-paren">(</span><em>filename</em><span class="sig-paren">)</span><a class="headerlink" href="#pyop2.MixedDat.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Write the data array to file <tt class="docutils literal"><span class="pre">filename</span></tt> in NumPy format.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.MixedDat.shape">
<tt class="descclassname">MixedDat.</tt><tt class="descname">shape</tt><a class="headerlink" href="#pyop2.MixedDat.shape" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyop2.MixedDat.soa">
<tt class="descclassname">MixedDat.</tt><tt class="descname">soa</tt><a class="headerlink" href="#pyop2.MixedDat.soa" title="Permalink to this definition">¶</a></dt>
<dd><p>Are the data in SoA format?</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.MixedDat.split">
<tt class="descclassname">MixedDat.</tt><tt class="descname">split</tt><a class="headerlink" href="#pyop2.MixedDat.split" title="Permalink to this definition">¶</a></dt>
<dd><p>The underlying tuple of <a class="reference internal" href="#pyop2.Dat" title="pyop2.Dat"><tt class="xref py py-class docutils literal"><span class="pre">Dat</span></tt></a>s.</p>
</dd></dl>

<dl class="method">
<dt id="pyop2.MixedDat.zero">
<tt class="descclassname">MixedDat.</tt><tt class="descname">zero</tt><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyop2.MixedDat.zero" title="Permalink to this definition">¶</a></dt>
<dd><p>Zero the data associated with this <a class="reference internal" href="#pyop2.MixedDat" title="pyop2.MixedDat"><tt class="xref py py-class docutils literal"><span class="pre">MixedDat</span></tt></a>.</p>
<p>This function is logically collective over MPI ranks, it is an
error to call it on fewer than all the ranks in MPI communicator.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyop2.Mat">
<em class="property">class </em><tt class="descclassname">pyop2.</tt><tt class="descname">Mat</tt><span class="sig-paren">(</span><em>sparsity</em>, <em>dtype=None</em>, <em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyop2.Mat" title="Permalink to this definition">¶</a></dt>
<dd><p>OP2 matrix data. A <tt class="docutils literal"><span class="pre">Mat</span></tt> is defined on a sparsity pattern and holds a value
for each element in the <a class="reference internal" href="#pyop2.Sparsity" title="pyop2.Sparsity"><tt class="xref py py-class docutils literal"><span class="pre">Sparsity</span></tt></a>.</p>
<p>When a <tt class="docutils literal"><span class="pre">Mat</span></tt> is passed to <a class="reference internal" href="pyop2.html#pyop2.op2.par_loop" title="pyop2.op2.par_loop"><tt class="xref py py-func docutils literal"><span class="pre">pyop2.op2.par_loop()</span></tt></a>, the maps via which
indirection occurs for the row and column space, and the access
descriptor are passed by <cite>calling</cite> the <tt class="docutils literal"><span class="pre">Mat</span></tt>. For instance, if a
<tt class="docutils literal"><span class="pre">Mat</span></tt> named <tt class="docutils literal"><span class="pre">A</span></tt> is to be accessed for reading via a row <a class="reference internal" href="#pyop2.Map" title="pyop2.Map"><tt class="xref py py-class docutils literal"><span class="pre">Map</span></tt></a>
named <tt class="docutils literal"><span class="pre">R</span></tt> and a column <a class="reference internal" href="#pyop2.Map" title="pyop2.Map"><tt class="xref py py-class docutils literal"><span class="pre">Map</span></tt></a> named <tt class="docutils literal"><span class="pre">C</span></tt>, this is accomplished by:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">A</span><span class="p">(</span><span class="n">pyop2</span><span class="o">.</span><span class="n">READ</span><span class="p">,</span> <span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="n">pyop2</span><span class="o">.</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">C</span><span class="p">[</span><span class="n">pyop2</span><span class="o">.</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]]))</span>
</pre></div>
</div>
<p>Notice that it is <cite>always</cite> necessary to index the indirection maps
for a <tt class="docutils literal"><span class="pre">Mat</span></tt>. See the <a class="reference internal" href="#pyop2.Mat" title="pyop2.Mat"><tt class="xref py py-class docutils literal"><span class="pre">Mat</span></tt></a> documentation for more
details.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">After executing <a class="reference internal" href="#pyop2.par_loop" title="pyop2.par_loop"><tt class="xref py py-func docutils literal"><span class="pre">par_loop()</span></tt></a>s that write to a <tt class="docutils literal"><span class="pre">Mat</span></tt> and
before using it (for example to view its values), you must call
<a class="reference internal" href="#pyop2.Mat.assemble" title="pyop2.Mat.assemble"><tt class="xref py py-meth docutils literal"><span class="pre">assemble()</span></tt></a> to finalise the writes.</p>
</div>
<dl class="class">
<dt id="pyop2.Mat.Snapshot">
<em class="property">class </em><tt class="descname">Snapshot</tt><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#pyop2.Mat.Snapshot" title="Permalink to this definition">¶</a></dt>
<dd><p>A snapshot for SetAssociated objects is valid if the snapshot
version is the same as the current version of the object</p>
<dl class="method">
<dt id="pyop2.Mat.Snapshot.is_valid">
<tt class="descname">is_valid</tt><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyop2.Mat.Snapshot.is_valid" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="method">
<dt id="pyop2.Mat.assemble">
<tt class="descclassname">Mat.</tt><tt class="descname">assemble</tt><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyop2.Mat.assemble" title="Permalink to this definition">¶</a></dt>
<dd><p>Finalise this <a class="reference internal" href="#pyop2.Mat" title="pyop2.Mat"><tt class="xref py py-class docutils literal"><span class="pre">Mat</span></tt></a> ready for use.</p>
<p>Call this /after/ executing all the par_loops that write to
the matrix before you want to look at it.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.Mat.cdim">
<tt class="descclassname">Mat.</tt><tt class="descname">cdim</tt><a class="headerlink" href="#pyop2.Mat.cdim" title="Permalink to this definition">¶</a></dt>
<dd><p>The scalar number of values for each member of the object. This is
the product of the dim tuple.</p>
</dd></dl>

<dl class="method">
<dt id="pyop2.Mat.create_snapshot">
<tt class="descclassname">Mat.</tt><tt class="descname">create_snapshot</tt><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyop2.Mat.create_snapshot" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a snapshot of the current object. If not overriden, this
method will return a full duplicate object.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.Mat.ctype">
<tt class="descclassname">Mat.</tt><tt class="descname">ctype</tt><a class="headerlink" href="#pyop2.Mat.ctype" title="Permalink to this definition">¶</a></dt>
<dd><p>The c type of the data.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.Mat.dim">
<tt class="descclassname">Mat.</tt><tt class="descname">dim</tt><a class="headerlink" href="#pyop2.Mat.dim" title="Permalink to this definition">¶</a></dt>
<dd><p>The shape tuple of the values for each element of the object.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.Mat.dims">
<tt class="descclassname">Mat.</tt><tt class="descname">dims</tt><a class="headerlink" href="#pyop2.Mat.dims" title="Permalink to this definition">¶</a></dt>
<dd><p>A pair of integers giving the number of matrix rows and columns for
each member of the row <a class="reference internal" href="#pyop2.Set" title="pyop2.Set"><tt class="xref py py-class docutils literal"><span class="pre">Set</span></tt></a> and column <a class="reference internal" href="#pyop2.Set" title="pyop2.Set"><tt class="xref py py-class docutils literal"><span class="pre">Set</span></tt></a>
respectively. This corresponds to the <tt class="docutils literal"><span class="pre">cdim</span></tt> member of a
<a class="reference internal" href="#pyop2.DataSet" title="pyop2.DataSet"><tt class="xref py py-class docutils literal"><span class="pre">DataSet</span></tt></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.Mat.dtype">
<tt class="descclassname">Mat.</tt><tt class="descname">dtype</tt><a class="headerlink" href="#pyop2.Mat.dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>The Python type of the data.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.Mat.name">
<tt class="descclassname">Mat.</tt><tt class="descname">name</tt><a class="headerlink" href="#pyop2.Mat.name" title="Permalink to this definition">¶</a></dt>
<dd><p>User-defined label.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.Mat.nbytes">
<tt class="descclassname">Mat.</tt><tt class="descname">nbytes</tt><a class="headerlink" href="#pyop2.Mat.nbytes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an estimate of the size of the data associated with this
<a class="reference internal" href="#pyop2.Mat" title="pyop2.Mat"><tt class="xref py py-class docutils literal"><span class="pre">Mat</span></tt></a> in bytes. This will be the correct size of the
data payload, but does not take into account the (presumably
small) overhead of the object and its metadata. The memory
associated with the sparsity pattern is also not recorded.</p>
<p>Note that this is the process local memory usage, not the sum
over all MPI processes.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.Mat.sparsity">
<tt class="descclassname">Mat.</tt><tt class="descname">sparsity</tt><a class="headerlink" href="#pyop2.Mat.sparsity" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#pyop2.Sparsity" title="pyop2.Sparsity"><tt class="xref py py-class docutils literal"><span class="pre">Sparsity</span></tt></a> on which the <tt class="docutils literal"><span class="pre">Mat</span></tt> is defined.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.Mat.values">
<tt class="descclassname">Mat.</tt><tt class="descname">values</tt><a class="headerlink" href="#pyop2.Mat.values" title="Permalink to this definition">¶</a></dt>
<dd><p>A numpy array of matrix values.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This is a dense array, so will need a lot of memory.  It&#8217;s
probably not a good idea to access this property if your
matrix has more than around 10000 degrees of freedom.</p>
</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="parallel-loops-kernels-and-linear-solves">
<h3>Parallel loops, kernels and linear solves<a class="headerlink" href="#parallel-loops-kernels-and-linear-solves" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="pyop2.par_loop">
<tt class="descclassname">pyop2.</tt><tt class="descname">par_loop</tt><span class="sig-paren">(</span><em>kernel</em>, <em>iterset</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pyop2.par_loop" title="Permalink to this definition">¶</a></dt>
<dd><p>Invocation of an OP2 kernel</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>kernel</strong> &#8211; The <a class="reference internal" href="#pyop2.Kernel" title="pyop2.Kernel"><tt class="xref py py-class docutils literal"><span class="pre">Kernel</span></tt></a> to be executed.</li>
<li><strong>iterset</strong> &#8211; The iteration <a class="reference internal" href="#pyop2.Set" title="pyop2.Set"><tt class="xref py py-class docutils literal"><span class="pre">Set</span></tt></a> over which the kernel should be
executed.</li>
<li><strong>*args</strong> &#8211; One or more <a class="reference internal" href="pyop2.html#pyop2.base.Arg" title="pyop2.base.Arg"><tt class="xref py py-class docutils literal"><span class="pre">base.Arg</span></tt></a>s constructed from a
<a class="reference internal" href="#pyop2.Global" title="pyop2.Global"><tt class="xref py py-class docutils literal"><span class="pre">Global</span></tt></a>, <a class="reference internal" href="#pyop2.Dat" title="pyop2.Dat"><tt class="xref py py-class docutils literal"><span class="pre">Dat</span></tt></a> or <a class="reference internal" href="#pyop2.Mat" title="pyop2.Mat"><tt class="xref py py-class docutils literal"><span class="pre">Mat</span></tt></a> using the call
syntax and passing in an optionally indexed <a class="reference internal" href="#pyop2.Map" title="pyop2.Map"><tt class="xref py py-class docutils literal"><span class="pre">Map</span></tt></a>
through which this <a class="reference internal" href="pyop2.html#pyop2.base.Arg" title="pyop2.base.Arg"><tt class="xref py py-class docutils literal"><span class="pre">base.Arg</span></tt></a> is accessed and the
<a class="reference internal" href="pyop2.html#pyop2.base.Access" title="pyop2.base.Access"><tt class="xref py py-class docutils literal"><span class="pre">base.Access</span></tt></a> descriptor indicating how the
<a class="reference internal" href="#pyop2.Kernel" title="pyop2.Kernel"><tt class="xref py py-class docutils literal"><span class="pre">Kernel</span></tt></a> is going to access this data (see the example
below). These are the global data structures from and to
which the kernel will read and write.</li>
<li><strong>iterate</strong> &#8211; <p>Optionally specify which region of an
<a class="reference internal" href="#pyop2.ExtrudedSet" title="pyop2.ExtrudedSet"><tt class="xref py py-class docutils literal"><span class="pre">ExtrudedSet</span></tt></a> to iterate over.
Valid values are:</p>
<blockquote>
<div><ul>
<li><tt class="docutils literal"><span class="pre">ON_BOTTOM</span></tt>: iterate over the bottom layer of cells.</li>
<li><tt class="docutils literal"><span class="pre">ON_TOP</span></tt> iterate over the top layer of cells.</li>
<li><tt class="docutils literal"><span class="pre">ALL</span></tt> iterate over all cells (the default if unspecified)</li>
<li><dl class="first docutils">
<dt><tt class="docutils literal"><span class="pre">ON_INTERIOR_FACETS</span></tt> iterate over all the layers</dt>
<dd>except the top layer, accessing data two adjacent (in
the extruded direction) cells at a time.</dd>
</dl>
</li>
</ul>
</div></blockquote>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">It is the caller&#8217;s responsibility that the number and type of all
<a class="reference internal" href="pyop2.html#pyop2.base.Arg" title="pyop2.base.Arg"><tt class="xref py py-class docutils literal"><span class="pre">base.Arg</span></tt></a>s passed to the <a class="reference internal" href="#pyop2.par_loop" title="pyop2.par_loop"><tt class="xref py py-func docutils literal"><span class="pre">par_loop()</span></tt></a> match those expected
by the <a class="reference internal" href="#pyop2.Kernel" title="pyop2.Kernel"><tt class="xref py py-class docutils literal"><span class="pre">Kernel</span></tt></a>. No runtime check is performed to ensure this!</p>
</div>
<p>If a <a class="reference internal" href="#pyop2.par_loop" title="pyop2.par_loop"><tt class="xref py py-func docutils literal"><span class="pre">par_loop()</span></tt></a> argument indexes into a <a class="reference internal" href="#pyop2.Map" title="pyop2.Map"><tt class="xref py py-class docutils literal"><span class="pre">Map</span></tt></a> using an
<a class="reference internal" href="pyop2.html#pyop2.base.IterationIndex" title="pyop2.base.IterationIndex"><tt class="xref py py-class docutils literal"><span class="pre">base.IterationIndex</span></tt></a>, this implies the use of a local
<a class="reference internal" href="pyop2.html#pyop2.base.IterationSpace" title="pyop2.base.IterationSpace"><tt class="xref py py-class docutils literal"><span class="pre">base.IterationSpace</span></tt></a> of a size given by the arity of the
<a class="reference internal" href="#pyop2.Map" title="pyop2.Map"><tt class="xref py py-class docutils literal"><span class="pre">Map</span></tt></a>. It is an error to have several arguments using local
iteration spaces of different size.</p>
<p><a class="reference internal" href="#pyop2.par_loop" title="pyop2.par_loop"><tt class="xref py py-func docutils literal"><span class="pre">par_loop()</span></tt></a> invocation is illustrated by the following example</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">pyop2</span><span class="o">.</span><span class="n">par_loop</span><span class="p">(</span><span class="n">mass</span><span class="p">,</span> <span class="n">elements</span><span class="p">,</span>
               <span class="n">mat</span><span class="p">(</span><span class="n">pyop2</span><span class="o">.</span><span class="n">INC</span><span class="p">,</span> <span class="p">(</span><span class="n">elem_node</span><span class="p">[</span><span class="n">pyop2</span><span class="o">.</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]]),</span> <span class="n">elem_node</span><span class="p">[</span><span class="n">pyop2</span><span class="o">.</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]]),</span>
               <span class="n">coords</span><span class="p">(</span><span class="n">pyop2</span><span class="o">.</span><span class="n">READ</span><span class="p">,</span> <span class="n">elem_node</span><span class="p">))</span>
</pre></div>
</div>
<p>This example will execute the <a class="reference internal" href="#pyop2.Kernel" title="pyop2.Kernel"><tt class="xref py py-class docutils literal"><span class="pre">Kernel</span></tt></a> <tt class="docutils literal"><span class="pre">mass</span></tt> over the
<a class="reference internal" href="#pyop2.Set" title="pyop2.Set"><tt class="xref py py-class docutils literal"><span class="pre">Set</span></tt></a> <tt class="docutils literal"><span class="pre">elements</span></tt> executing 3x3 times for each
<a class="reference internal" href="#pyop2.Set" title="pyop2.Set"><tt class="xref py py-class docutils literal"><span class="pre">Set</span></tt></a> member, assuming the <a class="reference internal" href="#pyop2.Map" title="pyop2.Map"><tt class="xref py py-class docutils literal"><span class="pre">Map</span></tt></a> <tt class="docutils literal"><span class="pre">elem_node</span></tt> is of arity 3.
The <a class="reference internal" href="#pyop2.Kernel" title="pyop2.Kernel"><tt class="xref py py-class docutils literal"><span class="pre">Kernel</span></tt></a> takes four arguments, the first is a <a class="reference internal" href="#pyop2.Mat" title="pyop2.Mat"><tt class="xref py py-class docutils literal"><span class="pre">Mat</span></tt></a> named
<tt class="docutils literal"><span class="pre">mat</span></tt>, the second is a field named <tt class="docutils literal"><span class="pre">coords</span></tt>. The remaining two arguments
indicate which local iteration space point the kernel is to execute.</p>
<p>A <a class="reference internal" href="#pyop2.Mat" title="pyop2.Mat"><tt class="xref py py-class docutils literal"><span class="pre">Mat</span></tt></a> requires a pair of <a class="reference internal" href="#pyop2.Map" title="pyop2.Map"><tt class="xref py py-class docutils literal"><span class="pre">Map</span></tt></a> objects, one each
for the row and column spaces. In this case both are the same
<tt class="docutils literal"><span class="pre">elem_node</span></tt> map. The row <a class="reference internal" href="#pyop2.Map" title="pyop2.Map"><tt class="xref py py-class docutils literal"><span class="pre">Map</span></tt></a> is indexed by the first
index in the local iteration space, indicated by the <tt class="docutils literal"><span class="pre">0</span></tt> index
to <a class="reference internal" href="#pyop2.i" title="pyop2.i"><tt class="xref py py-data docutils literal"><span class="pre">pyop2.i</span></tt></a>, while the column space is indexed by
the second local index.  The matrix is accessed to increment
values using the <tt class="docutils literal"><span class="pre">pyop2.INC</span></tt> access descriptor.</p>
<p>The <tt class="docutils literal"><span class="pre">coords</span></tt> <a class="reference internal" href="#pyop2.Dat" title="pyop2.Dat"><tt class="xref py py-class docutils literal"><span class="pre">Dat</span></tt></a> is also accessed via the <tt class="docutils literal"><span class="pre">elem_node</span></tt>
<a class="reference internal" href="#pyop2.Map" title="pyop2.Map"><tt class="xref py py-class docutils literal"><span class="pre">Map</span></tt></a>, however no indices are passed so all entries of
<tt class="docutils literal"><span class="pre">elem_node</span></tt> for the relevant member of <tt class="docutils literal"><span class="pre">elements</span></tt> will be
passed to the kernel as a vector.</p>
<p>This function is logically collective over MPI ranks, it is an
error to call it on fewer than all the ranks in MPI communicator.</p>
</dd></dl>

<dl class="function">
<dt id="pyop2.solve">
<tt class="descclassname">pyop2.</tt><tt class="descname">solve</tt><span class="sig-paren">(</span><em>A</em>, <em>x</em>, <em>b</em><span class="sig-paren">)</span><a class="headerlink" href="#pyop2.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve a matrix equation using the default <a class="reference internal" href="#pyop2.Solver" title="pyop2.Solver"><tt class="xref py py-class docutils literal"><span class="pre">Solver</span></tt></a></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>A</strong> &#8211; The <a class="reference internal" href="#pyop2.Mat" title="pyop2.Mat"><tt class="xref py py-class docutils literal"><span class="pre">Mat</span></tt></a> containing the matrix.</li>
<li><strong>x</strong> &#8211; The <a class="reference internal" href="#pyop2.Dat" title="pyop2.Dat"><tt class="xref py py-class docutils literal"><span class="pre">Dat</span></tt></a> to receive the solution.</li>
<li><strong>b</strong> &#8211; The <a class="reference internal" href="#pyop2.Dat" title="pyop2.Dat"><tt class="xref py py-class docutils literal"><span class="pre">Dat</span></tt></a> containing the RHS.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>This function is logically collective over MPI ranks, it is an
error to call it on fewer than all the ranks in MPI communicator.</p>
</dd></dl>

<dl class="class">
<dt id="pyop2.Kernel">
<em class="property">class </em><tt class="descclassname">pyop2.</tt><tt class="descname">Kernel</tt><span class="sig-paren">(</span><em>code</em>, <em>name</em>, <em>opts={}</em>, <em>include_dirs=</em>, <span class="optional">[</span><span class="optional">]</span><em>headers=</em>, <span class="optional">[</span><span class="optional">]</span><em>user_code=''</em><span class="sig-paren">)</span><a class="headerlink" href="#pyop2.Kernel" title="Permalink to this definition">¶</a></dt>
<dd><p>OP2 kernel type.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>code</strong> &#8211; kernel function definition, including signature; either a
string or an AST <a class="reference internal" href="pyop2.coffee.html#pyop2.coffee.ast_base.Node" title="pyop2.coffee.ast_base.Node"><tt class="xref py py-class docutils literal"><span class="pre">Node</span></tt></a></li>
<li><strong>name</strong> &#8211; kernel function name; must match the name of the kernel
function given in <cite>code</cite></li>
<li><strong>opts</strong> &#8211; options dictionary for <a class="reference internal" href="ir.html"><em>PyOP2 IR optimisations</em></a>
(optional, ignored if <cite>code</cite> is a string)</li>
<li><strong>include_dirs</strong> &#8211; list of additional include directories to be searched
when compiling the kernel (optional, defaults to empty)</li>
<li><strong>headers</strong> &#8211; list of system headers to include when compiling the kernel
in the form <tt class="docutils literal"><span class="pre">#include</span> <span class="pre">&lt;header.h&gt;</span></tt> (optional, defaults to empty)</li>
<li><strong>user_code</strong> &#8211; code snippet to be executed once at the very start of
the generated kernel wrapper code (optional, defaults to empty)</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Consider the case of initialising a <a class="reference internal" href="#pyop2.Dat" title="pyop2.Dat"><tt class="xref py py-class docutils literal"><span class="pre">Dat</span></tt></a> with seeded random
values in the interval 0 to 1. The corresponding <a class="reference internal" href="#pyop2.Kernel" title="pyop2.Kernel"><tt class="xref py py-class docutils literal"><span class="pre">Kernel</span></tt></a> is
constructed as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">op2</span><span class="o">.</span><span class="n">Kernel</span><span class="p">(</span><span class="s">&quot;void setrand(double *x) { x[0] = (double)random()/RAND_MAX); }&quot;</span><span class="p">,</span>
           <span class="n">name</span><span class="o">=</span><span class="s">&quot;setrand&quot;</span><span class="p">,</span>
           <span class="n">headers</span><span class="o">=</span><span class="p">[</span><span class="s">&quot;#include &lt;stdlib.h&gt;&quot;</span><span class="p">],</span> <span class="n">user_code</span><span class="o">=</span><span class="s">&quot;srandom(10001);&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">When running in parallel with MPI the generated code must be the same
on all ranks.</p>
</div>
<dl class="attribute">
<dt id="pyop2.Kernel.cache_key">
<tt class="descname">cache_key</tt><a class="headerlink" href="#pyop2.Kernel.cache_key" title="Permalink to this definition">¶</a></dt>
<dd><p>Cache key.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.Kernel.code">
<tt class="descname">code</tt><a class="headerlink" href="#pyop2.Kernel.code" title="Permalink to this definition">¶</a></dt>
<dd><p>String containing the c code for this kernel routine. This
code must conform to the OP2 user kernel API.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.Kernel.name">
<tt class="descname">name</tt><a class="headerlink" href="#pyop2.Kernel.name" title="Permalink to this definition">¶</a></dt>
<dd><p>Kernel name, must match the kernel function name in the code.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyop2.Solver">
<em class="property">class </em><tt class="descclassname">pyop2.</tt><tt class="descname">Solver</tt><span class="sig-paren">(</span><em>parameters=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pyop2.Solver" title="Permalink to this definition">¶</a></dt>
<dd><p>OP2 Solver object. The <a class="reference internal" href="#pyop2.Solver" title="pyop2.Solver"><tt class="xref py py-class docutils literal"><span class="pre">Solver</span></tt></a> holds a set of parameters that are
passed to the underlying linear algebra library when the <tt class="docutils literal"><span class="pre">solve</span></tt> method
is called. These can either be passed as a dictionary <tt class="docutils literal"><span class="pre">parameters</span></tt> <em>or</em>
as individual keyword arguments (combining both will cause an exception).</p>
<p>Recognized parameters either as dictionary keys or keyword arguments are:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>ksp_type</strong> &#8211; the solver type (&#8216;cg&#8217;)</li>
<li><strong>pc_type</strong> &#8211; the preconditioner type (&#8216;jacobi&#8217;)</li>
<li><strong>ksp_rtol</strong> &#8211; relative solver tolerance (1e-7)</li>
<li><strong>ksp_atol</strong> &#8211; absolute solver tolerance (1e-50)</li>
<li><strong>ksp_divtol</strong> &#8211; factor by which the residual norm may exceed the
right-hand-side norm before the solve is considered to have diverged:
<tt class="docutils literal"><span class="pre">norm(r)</span> <span class="pre">&gt;=</span> <span class="pre">dtol*norm(b)</span></tt> (1e4)</li>
<li><strong>ksp_max_it</strong> &#8211; maximum number of solver iterations (10000)</li>
<li><strong>error_on_nonconvergence</strong> &#8211; abort if the solve does not converge in the
maximum number of iterations (True, if False only a warning is printed)</li>
<li><strong>ksp_monitor</strong> &#8211; print the residual norm after each iteration
(False)</li>
<li><strong>plot_convergence</strong> &#8211; plot a graph of the convergence history after the
solve has finished and save it to file (False, implies <em>ksp_monitor</em>)</li>
<li><strong>plot_prefix</strong> &#8211; filename prefix for plot files (&#8216;&#8217;)</li>
<li><strong>ksp_gmres_restart</strong> &#8211; restart period when using GMRES</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="pyop2.Solver.solve">
<tt class="descname">solve</tt><span class="sig-paren">(</span><em>A</em>, <em>x</em>, <em>b</em><span class="sig-paren">)</span><a class="headerlink" href="#pyop2.Solver.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve a matrix equation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>A</strong> &#8211; The <a class="reference internal" href="#pyop2.Mat" title="pyop2.Mat"><tt class="xref py py-class docutils literal"><span class="pre">Mat</span></tt></a> containing the matrix.</li>
<li><strong>x</strong> &#8211; The <a class="reference internal" href="#pyop2.Dat" title="pyop2.Dat"><tt class="xref py py-class docutils literal"><span class="pre">Dat</span></tt></a> to receive the solution.</li>
<li><strong>b</strong> &#8211; The <a class="reference internal" href="#pyop2.Dat" title="pyop2.Dat"><tt class="xref py py-class docutils literal"><span class="pre">Dat</span></tt></a> containing the RHS.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>This function is logically collective over MPI ranks, it is an
error to call it on fewer than all the ranks in MPI communicator.</p>
</dd></dl>

<dl class="method">
<dt id="pyop2.Solver.update_parameters">
<tt class="descname">update_parameters</tt><span class="sig-paren">(</span><em>parameters</em><span class="sig-paren">)</span><a class="headerlink" href="#pyop2.Solver.update_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Update solver parameters</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>parameters</strong> &#8211; Dictionary containing the parameters to update.</td>
</tr>
</tbody>
</table>
<p>This function is logically collective over MPI ranks, it is an
error to call it on fewer than all the ranks in MPI communicator.</p>
</dd></dl>

</dd></dl>

<dl class="data">
<dt id="pyop2.i">
<tt class="descclassname">pyop2.</tt><tt class="descname">i</tt><em class="property"> = IterationIndex(None)</em><a class="headerlink" href="#pyop2.i" title="Permalink to this definition">¶</a></dt>
<dd><p>Shorthand for constructing <tt class="xref py py-class docutils literal"><span class="pre">IterationIndex</span></tt> objects.</p>
<p><tt class="docutils literal"><span class="pre">i[idx]</span></tt> builds an <tt class="xref py py-class docutils literal"><span class="pre">IterationIndex</span></tt> object for which the <cite>index</cite>
property is <cite>idx</cite>.</p>
</dd></dl>

<dl class="data">
<dt id="pyop2.READ">
<tt class="descclassname">pyop2.</tt><tt class="descname">READ</tt><em class="property"> = Access('READ')</em><a class="headerlink" href="#pyop2.READ" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="#pyop2.Global" title="pyop2.Global"><tt class="xref py py-class docutils literal"><span class="pre">Global</span></tt></a>, <a class="reference internal" href="#pyop2.Dat" title="pyop2.Dat"><tt class="xref py py-class docutils literal"><span class="pre">Dat</span></tt></a>, or <a class="reference internal" href="#pyop2.Mat" title="pyop2.Mat"><tt class="xref py py-class docutils literal"><span class="pre">Mat</span></tt></a> is accessed read-only.</p>
</dd></dl>

<dl class="data">
<dt id="pyop2.WRITE">
<tt class="descclassname">pyop2.</tt><tt class="descname">WRITE</tt><em class="property"> = Access('WRITE')</em><a class="headerlink" href="#pyop2.WRITE" title="Permalink to this definition">¶</a></dt>
<dd><p>The  <a class="reference internal" href="#pyop2.Global" title="pyop2.Global"><tt class="xref py py-class docutils literal"><span class="pre">Global</span></tt></a>, <a class="reference internal" href="#pyop2.Dat" title="pyop2.Dat"><tt class="xref py py-class docutils literal"><span class="pre">Dat</span></tt></a>, or <a class="reference internal" href="#pyop2.Mat" title="pyop2.Mat"><tt class="xref py py-class docutils literal"><span class="pre">Mat</span></tt></a> is accessed write-only,
and OP2 is not required to handle write conflicts.</p>
</dd></dl>

<dl class="data">
<dt id="pyop2.RW">
<tt class="descclassname">pyop2.</tt><tt class="descname">RW</tt><em class="property"> = Access('RW')</em><a class="headerlink" href="#pyop2.RW" title="Permalink to this definition">¶</a></dt>
<dd><p>The  <a class="reference internal" href="#pyop2.Global" title="pyop2.Global"><tt class="xref py py-class docutils literal"><span class="pre">Global</span></tt></a>, <a class="reference internal" href="#pyop2.Dat" title="pyop2.Dat"><tt class="xref py py-class docutils literal"><span class="pre">Dat</span></tt></a>, or <a class="reference internal" href="#pyop2.Mat" title="pyop2.Mat"><tt class="xref py py-class docutils literal"><span class="pre">Mat</span></tt></a> is accessed for reading
and writing, and OP2 is not required to handle write conflicts.</p>
</dd></dl>

<dl class="data">
<dt id="pyop2.INC">
<tt class="descclassname">pyop2.</tt><tt class="descname">INC</tt><em class="property"> = Access('INC')</em><a class="headerlink" href="#pyop2.INC" title="Permalink to this definition">¶</a></dt>
<dd><p>The kernel computes increments to be summed onto a <a class="reference internal" href="#pyop2.Global" title="pyop2.Global"><tt class="xref py py-class docutils literal"><span class="pre">Global</span></tt></a>,
<a class="reference internal" href="#pyop2.Dat" title="pyop2.Dat"><tt class="xref py py-class docutils literal"><span class="pre">Dat</span></tt></a>, or <a class="reference internal" href="#pyop2.Mat" title="pyop2.Mat"><tt class="xref py py-class docutils literal"><span class="pre">Mat</span></tt></a>. OP2 is responsible for managing the write
conflicts caused.</p>
</dd></dl>

<dl class="data">
<dt id="pyop2.MIN">
<tt class="descclassname">pyop2.</tt><tt class="descname">MIN</tt><em class="property"> = Access('MIN')</em><a class="headerlink" href="#pyop2.MIN" title="Permalink to this definition">¶</a></dt>
<dd><p>The kernel contributes to a reduction into a <a class="reference internal" href="#pyop2.Global" title="pyop2.Global"><tt class="xref py py-class docutils literal"><span class="pre">Global</span></tt></a> using a <tt class="docutils literal"><span class="pre">min</span></tt>
operation. OP2 is responsible for reducing over the different kernel
invocations.</p>
</dd></dl>

<dl class="data">
<dt id="pyop2.MAX">
<tt class="descclassname">pyop2.</tt><tt class="descname">MAX</tt><em class="property"> = Access('MAX')</em><a class="headerlink" href="#pyop2.MAX" title="Permalink to this definition">¶</a></dt>
<dd><p>The kernel contributes to a reduction into a <a class="reference internal" href="#pyop2.Global" title="pyop2.Global"><tt class="xref py py-class docutils literal"><span class="pre">Global</span></tt></a> using a <tt class="docutils literal"><span class="pre">max</span></tt>
operation. OP2 is responsible for reducing over the different kernel
invocations.</p>
</dd></dl>

</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">pyop2 user documentation</a><ul>
<li><a class="reference internal" href="#module-pyop2"><tt class="docutils literal"><span class="pre">pyop2</span></tt> Package</a><ul>
<li><a class="reference internal" href="#initialization-and-finalization">Initialization and finalization</a></li>
<li><a class="reference internal" href="#data-structures">Data structures</a></li>
<li><a class="reference internal" href="#parallel-loops-kernels-and-linear-solves">Parallel loops, kernels and linear solves</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="profiling.html"
                        title="previous chapter">Profiling</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="pyop2.html"
                        title="next chapter">pyop2 package</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/user.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="pyop2.html" title="pyop2 package"
             >next</a> |</li>
        <li class="right" >
          <a href="profiling.html" title="Profiling"
             >previous</a> |</li>
        <li><a href="index.html">PyOP2 0.11.0 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2012-2013, Imperial College et al.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3a0.
    </div>
  </body>
</html>