<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>pyop2 Package &mdash; PyOP2 0.10.0 documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.10.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="PyOP2 0.10.0 documentation" href="index.html" />
    <link rel="next" title="ir Package" href="pyop2.ir.html" />
    <link rel="prev" title="pyop2 user documentation" href="user.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="pyop2.ir.html" title="ir Package"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="user.html" title="pyop2 user documentation"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">PyOP2 0.10.0 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="pyop2-package">
<h1>pyop2 Package<a class="headerlink" href="#pyop2-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="id1">
<h2><a class="reference internal" href="user.html#module-pyop2" title="pyop2"><tt class="xref py py-mod docutils literal"><span class="pre">pyop2</span></tt></a> Package<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<span class="target" id="module-pyop2.__init__"></span><p>PyOP2 is a library for parallel computations on unstructured meshes and
delivers performance-portability across a range of platforms:</p>
<ul class="simple">
<li>multi-core CPU (sequential, OpenMP, OpenCL and MPI)</li>
<li>GPU (CUDA and OpenCL)</li>
</ul>
</div>
<div class="section" id="module-pyop2.backends">
<span id="backends-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">backends</span></tt> Module<a class="headerlink" href="#module-pyop2.backends" title="Permalink to this headline">¶</a></h2>
<p>OP2 backend configuration and auxiliaries.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">User code should usually set the backend via <a class="reference internal" href="#pyop2.op2.init" title="pyop2.op2.init"><tt class="xref py py-func docutils literal"><span class="pre">pyop2.op2.init()</span></tt></a></p>
</div>
<dl class="function">
<dt id="pyop2.backends.get_backend">
<tt class="descclassname">pyop2.backends.</tt><tt class="descname">get_backend</tt><big>(</big><big>)</big><a class="headerlink" href="#pyop2.backends.get_backend" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the OP2 backend</p>
</dd></dl>

<dl class="function">
<dt id="pyop2.backends.set_backend">
<tt class="descclassname">pyop2.backends.</tt><tt class="descname">set_backend</tt><big>(</big><em>backend</em><big>)</big><a class="headerlink" href="#pyop2.backends.set_backend" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the OP2 backend</p>
<p>This function is logically collective over MPI ranks, it is an
error to call it on fewer than all the ranks in MPI communicator.</p>
</dd></dl>

<dl class="function">
<dt id="pyop2.backends.unset_backend">
<tt class="descclassname">pyop2.backends.</tt><tt class="descname">unset_backend</tt><big>(</big><big>)</big><a class="headerlink" href="#pyop2.backends.unset_backend" title="Permalink to this definition">¶</a></dt>
<dd><p>Unset the OP2 backend</p>
<p>This function is logically collective over MPI ranks, it is an
error to call it on fewer than all the ranks in MPI communicator.</p>
</dd></dl>

</div>
<div class="section" id="module-pyop2.base">
<span id="base-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">base</span></tt> Module<a class="headerlink" href="#module-pyop2.base" title="Permalink to this headline">¶</a></h2>
<p>Base classes for OP2 objects, containing metadata and runtime data
information which is backend independent. Individual runtime backends should
subclass these as required to implement backend-specific features.</p>
<dl class="class">
<dt id="pyop2.base.LazyComputation">
<em class="property">class </em><tt class="descclassname">pyop2.base.</tt><tt class="descname">LazyComputation</tt><big>(</big><em>reads</em>, <em>writes</em><big>)</big><a class="headerlink" href="#pyop2.base.LazyComputation" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Helper class holding computation to be carried later on.</p>
<dl class="method">
<dt id="pyop2.base.LazyComputation.enqueue">
<tt class="descname">enqueue</tt><big>(</big><big>)</big><a class="headerlink" href="#pyop2.base.LazyComputation.enqueue" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyop2.base.ExecutionTrace">
<em class="property">class </em><tt class="descclassname">pyop2.base.</tt><tt class="descname">ExecutionTrace</tt><a class="headerlink" href="#pyop2.base.ExecutionTrace" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Container maintaining delayed computation until they are executed.</p>
<dl class="method">
<dt id="pyop2.base.ExecutionTrace.append">
<tt class="descname">append</tt><big>(</big><em>computation</em><big>)</big><a class="headerlink" href="#pyop2.base.ExecutionTrace.append" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyop2.base.ExecutionTrace.in_queue">
<tt class="descname">in_queue</tt><big>(</big><em>computation</em><big>)</big><a class="headerlink" href="#pyop2.base.ExecutionTrace.in_queue" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyop2.base.ExecutionTrace.clear">
<tt class="descname">clear</tt><big>(</big><big>)</big><a class="headerlink" href="#pyop2.base.ExecutionTrace.clear" title="Permalink to this definition">¶</a></dt>
<dd><p>Forcefully drops delayed computation. Only use this if you know what you
are doing.</p>
</dd></dl>

<dl class="method">
<dt id="pyop2.base.ExecutionTrace.evaluate_all">
<tt class="descname">evaluate_all</tt><big>(</big><big>)</big><a class="headerlink" href="#pyop2.base.ExecutionTrace.evaluate_all" title="Permalink to this definition">¶</a></dt>
<dd><p>Forces the evaluation of all delayed computations.</p>
</dd></dl>

<dl class="method">
<dt id="pyop2.base.ExecutionTrace.evaluate">
<tt class="descname">evaluate</tt><big>(</big><em>reads=None</em>, <em>writes=None</em><big>)</big><a class="headerlink" href="#pyop2.base.ExecutionTrace.evaluate" title="Permalink to this definition">¶</a></dt>
<dd><p>Force the evaluation of delayed computation on which reads and writes
depend.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>reads</strong> &#8211; the <a class="reference internal" href="#pyop2.base.DataCarrier" title="pyop2.base.DataCarrier"><tt class="xref py py-class docutils literal"><span class="pre">DataCarrier</span></tt></a>s which you wish to read from.
This forces evaluation of all <a class="reference internal" href="#pyop2.base.par_loop" title="pyop2.base.par_loop"><tt class="xref py py-func docutils literal"><span class="pre">par_loop()</span></tt></a>s that write to
the <a class="reference internal" href="#pyop2.base.DataCarrier" title="pyop2.base.DataCarrier"><tt class="xref py py-class docutils literal"><span class="pre">DataCarrier</span></tt></a> (and any other dependent computation).</li>
<li><strong>writes</strong> &#8211; the <a class="reference internal" href="#pyop2.base.DataCarrier" title="pyop2.base.DataCarrier"><tt class="xref py py-class docutils literal"><span class="pre">DataCarrier</span></tt></a>s which you will write to (i.e. modify values).
This forces evaluation of all <a class="reference internal" href="#pyop2.base.par_loop" title="pyop2.base.par_loop"><tt class="xref py py-func docutils literal"><span class="pre">par_loop()</span></tt></a>s that read from the
<a class="reference internal" href="#pyop2.base.DataCarrier" title="pyop2.base.DataCarrier"><tt class="xref py py-class docutils literal"><span class="pre">DataCarrier</span></tt></a> (and any other dependent computation).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyop2.base.Access">
<em class="property">class </em><tt class="descclassname">pyop2.base.</tt><tt class="descname">Access</tt><big>(</big><em>mode</em><big>)</big><a class="headerlink" href="#pyop2.base.Access" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>OP2 access type. In an <a class="reference internal" href="#pyop2.base.Arg" title="pyop2.base.Arg"><tt class="xref py py-class docutils literal"><span class="pre">Arg</span></tt></a>, this describes how the
<a class="reference internal" href="#pyop2.base.DataCarrier" title="pyop2.base.DataCarrier"><tt class="xref py py-class docutils literal"><span class="pre">DataCarrier</span></tt></a> will be accessed.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Access should not be instantiated by user code. Instead, use
the predefined values: <a class="reference internal" href="#pyop2.base.READ" title="pyop2.base.READ"><tt class="xref py py-const docutils literal"><span class="pre">READ</span></tt></a>, <a class="reference internal" href="#pyop2.base.WRITE" title="pyop2.base.WRITE"><tt class="xref py py-const docutils literal"><span class="pre">WRITE</span></tt></a>, <a class="reference internal" href="#pyop2.base.RW" title="pyop2.base.RW"><tt class="xref py py-const docutils literal"><span class="pre">RW</span></tt></a>,
<a class="reference internal" href="#pyop2.base.INC" title="pyop2.base.INC"><tt class="xref py py-const docutils literal"><span class="pre">INC</span></tt></a>, <a class="reference internal" href="#pyop2.base.MIN" title="pyop2.base.MIN"><tt class="xref py py-const docutils literal"><span class="pre">MIN</span></tt></a>, <a class="reference internal" href="#pyop2.base.MAX" title="pyop2.base.MAX"><tt class="xref py py-const docutils literal"><span class="pre">MAX</span></tt></a></p>
</div>
</dd></dl>

<dl class="data">
<dt id="pyop2.base.READ">
<tt class="descclassname">pyop2.base.</tt><tt class="descname">READ</tt><em class="property"> = Access('READ')</em><a class="headerlink" href="#pyop2.base.READ" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="#pyop2.base.Global" title="pyop2.base.Global"><tt class="xref py py-class docutils literal"><span class="pre">Global</span></tt></a>, <a class="reference internal" href="#pyop2.base.Dat" title="pyop2.base.Dat"><tt class="xref py py-class docutils literal"><span class="pre">Dat</span></tt></a>, or <a class="reference internal" href="#pyop2.base.Mat" title="pyop2.base.Mat"><tt class="xref py py-class docutils literal"><span class="pre">Mat</span></tt></a> is accessed read-only.</p>
</dd></dl>

<dl class="data">
<dt id="pyop2.base.WRITE">
<tt class="descclassname">pyop2.base.</tt><tt class="descname">WRITE</tt><em class="property"> = Access('WRITE')</em><a class="headerlink" href="#pyop2.base.WRITE" title="Permalink to this definition">¶</a></dt>
<dd><p>The  <a class="reference internal" href="#pyop2.base.Global" title="pyop2.base.Global"><tt class="xref py py-class docutils literal"><span class="pre">Global</span></tt></a>, <a class="reference internal" href="#pyop2.base.Dat" title="pyop2.base.Dat"><tt class="xref py py-class docutils literal"><span class="pre">Dat</span></tt></a>, or <a class="reference internal" href="#pyop2.base.Mat" title="pyop2.base.Mat"><tt class="xref py py-class docutils literal"><span class="pre">Mat</span></tt></a> is accessed write-only,
and OP2 is not required to handle write conflicts.</p>
</dd></dl>

<dl class="data">
<dt id="pyop2.base.RW">
<tt class="descclassname">pyop2.base.</tt><tt class="descname">RW</tt><em class="property"> = Access('RW')</em><a class="headerlink" href="#pyop2.base.RW" title="Permalink to this definition">¶</a></dt>
<dd><p>The  <a class="reference internal" href="#pyop2.base.Global" title="pyop2.base.Global"><tt class="xref py py-class docutils literal"><span class="pre">Global</span></tt></a>, <a class="reference internal" href="#pyop2.base.Dat" title="pyop2.base.Dat"><tt class="xref py py-class docutils literal"><span class="pre">Dat</span></tt></a>, or <a class="reference internal" href="#pyop2.base.Mat" title="pyop2.base.Mat"><tt class="xref py py-class docutils literal"><span class="pre">Mat</span></tt></a> is accessed for reading
and writing, and OP2 is not required to handle write conflicts.</p>
</dd></dl>

<dl class="data">
<dt id="pyop2.base.INC">
<tt class="descclassname">pyop2.base.</tt><tt class="descname">INC</tt><em class="property"> = Access('INC')</em><a class="headerlink" href="#pyop2.base.INC" title="Permalink to this definition">¶</a></dt>
<dd><p>The kernel computes increments to be summed onto a <a class="reference internal" href="#pyop2.base.Global" title="pyop2.base.Global"><tt class="xref py py-class docutils literal"><span class="pre">Global</span></tt></a>,
<a class="reference internal" href="#pyop2.base.Dat" title="pyop2.base.Dat"><tt class="xref py py-class docutils literal"><span class="pre">Dat</span></tt></a>, or <a class="reference internal" href="#pyop2.base.Mat" title="pyop2.base.Mat"><tt class="xref py py-class docutils literal"><span class="pre">Mat</span></tt></a>. OP2 is responsible for managing the write
conflicts caused.</p>
</dd></dl>

<dl class="data">
<dt id="pyop2.base.MIN">
<tt class="descclassname">pyop2.base.</tt><tt class="descname">MIN</tt><em class="property"> = Access('MIN')</em><a class="headerlink" href="#pyop2.base.MIN" title="Permalink to this definition">¶</a></dt>
<dd><p>The kernel contributes to a reduction into a <a class="reference internal" href="#pyop2.base.Global" title="pyop2.base.Global"><tt class="xref py py-class docutils literal"><span class="pre">Global</span></tt></a> using a <tt class="docutils literal"><span class="pre">min</span></tt>
operation. OP2 is responsible for reducing over the different kernel
invocations.</p>
</dd></dl>

<dl class="data">
<dt id="pyop2.base.MAX">
<tt class="descclassname">pyop2.base.</tt><tt class="descname">MAX</tt><em class="property"> = Access('MAX')</em><a class="headerlink" href="#pyop2.base.MAX" title="Permalink to this definition">¶</a></dt>
<dd><p>The kernel contributes to a reduction into a <a class="reference internal" href="#pyop2.base.Global" title="pyop2.base.Global"><tt class="xref py py-class docutils literal"><span class="pre">Global</span></tt></a> using a <tt class="docutils literal"><span class="pre">max</span></tt>
operation. OP2 is responsible for reducing over the different kernel
invocations.</p>
</dd></dl>

<dl class="class">
<dt id="pyop2.base.Arg">
<em class="property">class </em><tt class="descclassname">pyop2.base.</tt><tt class="descname">Arg</tt><big>(</big><em>data=None</em>, <em>map=None</em>, <em>idx=None</em>, <em>access=None</em>, <em>flatten=False</em><big>)</big><a class="headerlink" href="#pyop2.base.Arg" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>An argument to a <a class="reference internal" href="#pyop2.op2.par_loop" title="pyop2.op2.par_loop"><tt class="xref py py-func docutils literal"><span class="pre">pyop2.op2.par_loop()</span></tt></a>.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">User code should not directly instantiate <a class="reference internal" href="#pyop2.base.Arg" title="pyop2.base.Arg"><tt class="xref py py-class docutils literal"><span class="pre">Arg</span></tt></a>.
Instead, use the call syntax on the <a class="reference internal" href="#pyop2.base.DataCarrier" title="pyop2.base.DataCarrier"><tt class="xref py py-class docutils literal"><span class="pre">DataCarrier</span></tt></a>.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>data</strong> &#8211; A data-carrying object, either <a class="reference internal" href="#pyop2.base.Dat" title="pyop2.base.Dat"><tt class="xref py py-class docutils literal"><span class="pre">Dat</span></tt></a> or class:<cite>Mat</cite></li>
<li><strong>map</strong> &#8211; A <a class="reference internal" href="#pyop2.base.Map" title="pyop2.base.Map"><tt class="xref py py-class docutils literal"><span class="pre">Map</span></tt></a> to access this <a class="reference internal" href="#pyop2.base.Arg" title="pyop2.base.Arg"><tt class="xref py py-class docutils literal"><span class="pre">Arg</span></tt></a> or the default
if the identity map is to be used.</li>
<li><strong>idx</strong> &#8211; An index into the <a class="reference internal" href="#pyop2.base.Map" title="pyop2.base.Map"><tt class="xref py py-class docutils literal"><span class="pre">Map</span></tt></a>: an <a class="reference internal" href="#pyop2.base.IterationIndex" title="pyop2.base.IterationIndex"><tt class="xref py py-class docutils literal"><span class="pre">IterationIndex</span></tt></a>
when using an iteration space, an <tt class="xref py py-class docutils literal"><span class="pre">int</span></tt> to use a
given component of the mapping or the default to use all
components of the mapping.</li>
<li><strong>access</strong> &#8211; An access descriptor of type <a class="reference internal" href="#pyop2.base.Access" title="pyop2.base.Access"><tt class="xref py py-class docutils literal"><span class="pre">Access</span></tt></a></li>
<li><strong>flatten</strong> &#8211; Treat the data dimensions of this <a class="reference internal" href="#pyop2.base.Arg" title="pyop2.base.Arg"><tt class="xref py py-class docutils literal"><span class="pre">Arg</span></tt></a> as flat
s.t. the kernel is passed a flat vector of length
<tt class="docutils literal"><span class="pre">map.arity</span> <span class="pre">*</span> <span class="pre">data.dataset.cdim</span></tt>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Checks that:</p>
<ol class="arabic simple">
<li>the maps used are initialized i.e. have mapping data associated, and</li>
<li>the to Set of the map used to access it matches the Set it is
defined on.</li>
</ol>
<p>A <tt class="xref py py-class docutils literal"><span class="pre">MapValueError</span></tt> is raised if these conditions are not met.</p>
<dl class="attribute">
<dt id="pyop2.base.Arg.split">
<tt class="descname">split</tt><a class="headerlink" href="#pyop2.base.Arg.split" title="Permalink to this definition">¶</a></dt>
<dd><p>Split a mixed argument into a tuple of constituent arguments.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.Arg.name">
<tt class="descname">name</tt><a class="headerlink" href="#pyop2.base.Arg.name" title="Permalink to this definition">¶</a></dt>
<dd><p>The generated argument name.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.Arg.position">
<tt class="descname">position</tt><a class="headerlink" href="#pyop2.base.Arg.position" title="Permalink to this definition">¶</a></dt>
<dd><p>The position of this <a class="reference internal" href="#pyop2.base.Arg" title="pyop2.base.Arg"><tt class="xref py py-class docutils literal"><span class="pre">Arg</span></tt></a> in the <a class="reference internal" href="#pyop2.base.ParLoop" title="pyop2.base.ParLoop"><tt class="xref py py-class docutils literal"><span class="pre">ParLoop</span></tt></a> argument list</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.Arg.indirect_position">
<tt class="descname">indirect_position</tt><a class="headerlink" href="#pyop2.base.Arg.indirect_position" title="Permalink to this definition">¶</a></dt>
<dd><p>The position of the first unique occurence of this
indirect <a class="reference internal" href="#pyop2.base.Arg" title="pyop2.base.Arg"><tt class="xref py py-class docutils literal"><span class="pre">Arg</span></tt></a> in the <a class="reference internal" href="#pyop2.base.ParLoop" title="pyop2.base.ParLoop"><tt class="xref py py-class docutils literal"><span class="pre">ParLoop</span></tt></a> argument list.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.Arg.ctype">
<tt class="descname">ctype</tt><a class="headerlink" href="#pyop2.base.Arg.ctype" title="Permalink to this definition">¶</a></dt>
<dd><p>String representing the C type of the data in this <tt class="docutils literal"><span class="pre">Arg</span></tt>.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.Arg.dtype">
<tt class="descname">dtype</tt><a class="headerlink" href="#pyop2.base.Arg.dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Numpy datatype of this Arg</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.Arg.map">
<tt class="descname">map</tt><a class="headerlink" href="#pyop2.base.Arg.map" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="#pyop2.base.Map" title="pyop2.base.Map"><tt class="xref py py-class docutils literal"><span class="pre">Map</span></tt></a> via which the data is to be accessed.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.Arg.idx">
<tt class="descname">idx</tt><a class="headerlink" href="#pyop2.base.Arg.idx" title="Permalink to this definition">¶</a></dt>
<dd><p>Index into the mapping.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.Arg.access">
<tt class="descname">access</tt><a class="headerlink" href="#pyop2.base.Arg.access" title="Permalink to this definition">¶</a></dt>
<dd><p>Access descriptor. One of the constants of type <a class="reference internal" href="#pyop2.base.Access" title="pyop2.base.Access"><tt class="xref py py-class docutils literal"><span class="pre">Access</span></tt></a></p>
</dd></dl>

<dl class="method">
<dt id="pyop2.base.Arg.halo_exchange_begin">
<tt class="descname">halo_exchange_begin</tt><big>(</big><big>)</big><a class="headerlink" href="#pyop2.base.Arg.halo_exchange_begin" title="Permalink to this definition">¶</a></dt>
<dd><p>Begin halo exchange for the argument if a halo update is required.
Doing halo exchanges only makes sense for <a class="reference internal" href="#pyop2.base.Dat" title="pyop2.base.Dat"><tt class="xref py py-class docutils literal"><span class="pre">Dat</span></tt></a> objects.</p>
<p>This function is logically collective over MPI ranks, it is an
error to call it on fewer than all the ranks in MPI communicator.</p>
</dd></dl>

<dl class="method">
<dt id="pyop2.base.Arg.halo_exchange_end">
<tt class="descname">halo_exchange_end</tt><big>(</big><big>)</big><a class="headerlink" href="#pyop2.base.Arg.halo_exchange_end" title="Permalink to this definition">¶</a></dt>
<dd><p>End halo exchange if it is in flight.
Doing halo exchanges only makes sense for <a class="reference internal" href="#pyop2.base.Dat" title="pyop2.base.Dat"><tt class="xref py py-class docutils literal"><span class="pre">Dat</span></tt></a> objects.</p>
<p>This function is logically collective over MPI ranks, it is an
error to call it on fewer than all the ranks in MPI communicator.</p>
</dd></dl>

<dl class="method">
<dt id="pyop2.base.Arg.reduction_begin">
<tt class="descname">reduction_begin</tt><big>(</big><big>)</big><a class="headerlink" href="#pyop2.base.Arg.reduction_begin" title="Permalink to this definition">¶</a></dt>
<dd><p>Begin reduction for the argument if its access is INC, MIN, or MAX.
Doing a reduction only makes sense for <a class="reference internal" href="#pyop2.base.Global" title="pyop2.base.Global"><tt class="xref py py-class docutils literal"><span class="pre">Global</span></tt></a> objects.</p>
<p>This function is logically collective over MPI ranks, it is an
error to call it on fewer than all the ranks in MPI communicator.</p>
</dd></dl>

<dl class="method">
<dt id="pyop2.base.Arg.reduction_end">
<tt class="descname">reduction_end</tt><big>(</big><big>)</big><a class="headerlink" href="#pyop2.base.Arg.reduction_end" title="Permalink to this definition">¶</a></dt>
<dd><p>End reduction for the argument if it is in flight.
Doing a reduction only makes sense for <a class="reference internal" href="#pyop2.base.Global" title="pyop2.base.Global"><tt class="xref py py-class docutils literal"><span class="pre">Global</span></tt></a> objects.</p>
<p>This function is logically collective over MPI ranks, it is an
error to call it on fewer than all the ranks in MPI communicator.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.Arg.data">
<tt class="descname">data</tt><a class="headerlink" href="#pyop2.base.Arg.data" title="Permalink to this definition">¶</a></dt>
<dd><p>Data carrier of this argument: <a class="reference internal" href="#pyop2.base.Dat" title="pyop2.base.Dat"><tt class="xref py py-class docutils literal"><span class="pre">Dat</span></tt></a>, <a class="reference internal" href="#pyop2.base.Mat" title="pyop2.base.Mat"><tt class="xref py py-class docutils literal"><span class="pre">Mat</span></tt></a>,
<a class="reference internal" href="#pyop2.base.Const" title="pyop2.base.Const"><tt class="xref py py-class docutils literal"><span class="pre">Const</span></tt></a> or <a class="reference internal" href="#pyop2.base.Global" title="pyop2.base.Global"><tt class="xref py py-class docutils literal"><span class="pre">Global</span></tt></a>.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyop2.base.Set">
<em class="property">class </em><tt class="descclassname">pyop2.base.</tt><tt class="descname">Set</tt><big>(</big><em>size=None</em>, <em>name=None</em>, <em>halo=None</em><big>)</big><a class="headerlink" href="#pyop2.base.Set" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>OP2 set.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>size</strong> (<em>integer or list of four integers.</em>) &#8211; The size of the set.</li>
<li><strong>dim</strong> (<em>integer or tuple of integers</em>) &#8211; The shape of the data associated with each element of this <tt class="docutils literal"><span class="pre">Set</span></tt>.</li>
<li><strong>name</strong> (<em>string</em>) &#8211; The name of the set (optional).</li>
<li><strong>halo</strong> &#8211; An exisiting halo to use (optional).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>When the set is employed as an iteration space in a
<a class="reference internal" href="#pyop2.op2.par_loop" title="pyop2.op2.par_loop"><tt class="xref py py-func docutils literal"><span class="pre">pyop2.op2.par_loop()</span></tt></a>, the extent of any local iteration space within
each set entry is indicated in brackets. See the example in
<a class="reference internal" href="#pyop2.op2.par_loop" title="pyop2.op2.par_loop"><tt class="xref py py-func docutils literal"><span class="pre">pyop2.op2.par_loop()</span></tt></a> for more details.</p>
<p>The size of the set can either be an integer, or a list of four
integers.  The latter case is used for running in parallel where
we distinguish between:</p>
<blockquote>
<div><ul class="simple">
<li><cite>CORE</cite> (owned and not touching halo)</li>
<li><cite>OWNED</cite> (owned, touching halo)</li>
<li><cite>EXECUTE HALO</cite> (not owned, but executed over redundantly)</li>
<li><cite>NON EXECUTE HALO</cite> (not owned, read when executing in the execute halo)</li>
</ul>
</div></blockquote>
<p>If a single integer is passed, we assume that we&#8217;re running in
serial and there is no distinction.</p>
<p>The division of set elements is:</p>
<div class="highlight-python"><pre>[0, CORE)
[CORE, OWNED)
[OWNED, EXECUTE HALO)
[EXECUTE HALO, NON EXECUTE HALO).</pre>
</div>
<p>Halo send/receive data is stored on sets in a <a class="reference internal" href="#pyop2.base.Halo" title="pyop2.base.Halo"><tt class="xref py py-class docutils literal"><span class="pre">Halo</span></tt></a>.</p>
<dl class="attribute">
<dt id="pyop2.base.Set.core_size">
<tt class="descname">core_size</tt><a class="headerlink" href="#pyop2.base.Set.core_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Core set size.  Owned elements not touching halo elements.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.Set.size">
<tt class="descname">size</tt><a class="headerlink" href="#pyop2.base.Set.size" title="Permalink to this definition">¶</a></dt>
<dd><p>Set size, owned elements.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.Set.exec_size">
<tt class="descname">exec_size</tt><a class="headerlink" href="#pyop2.base.Set.exec_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Set size including execute halo elements.</p>
<p>If a <a class="reference internal" href="#pyop2.base.ParLoop" title="pyop2.base.ParLoop"><tt class="xref py py-class docutils literal"><span class="pre">ParLoop</span></tt></a> is indirect, we do redundant computation
by executing over these set elements as well as owned ones.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.Set.total_size">
<tt class="descname">total_size</tt><a class="headerlink" href="#pyop2.base.Set.total_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Total set size, including halo elements.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.Set.sizes">
<tt class="descname">sizes</tt><a class="headerlink" href="#pyop2.base.Set.sizes" title="Permalink to this definition">¶</a></dt>
<dd><p>Set sizes: core, owned, execute halo, total.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.Set.name">
<tt class="descname">name</tt><a class="headerlink" href="#pyop2.base.Set.name" title="Permalink to this definition">¶</a></dt>
<dd><p>User-defined label</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.Set.halo">
<tt class="descname">halo</tt><a class="headerlink" href="#pyop2.base.Set.halo" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#pyop2.base.Halo" title="pyop2.base.Halo"><tt class="xref py py-class docutils literal"><span class="pre">Halo</span></tt></a> associated with this Set</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.Set.partition_size">
<tt class="descname">partition_size</tt><a class="headerlink" href="#pyop2.base.Set.partition_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Default partition size</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.Set.layers">
<tt class="descname">layers</tt><a class="headerlink" href="#pyop2.base.Set.layers" title="Permalink to this definition">¶</a></dt>
<dd><p>Return None (not an <a class="reference internal" href="#pyop2.base.ExtrudedSet" title="pyop2.base.ExtrudedSet"><tt class="xref py py-class docutils literal"><span class="pre">ExtrudedSet</span></tt></a>).</p>
</dd></dl>

<dl class="classmethod">
<dt id="pyop2.base.Set.fromhdf5">
<em class="property">classmethod </em><tt class="descname">fromhdf5</tt><big>(</big><em>f</em>, <em>name</em><big>)</big><a class="headerlink" href="#pyop2.base.Set.fromhdf5" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a <a class="reference internal" href="#pyop2.base.Set" title="pyop2.base.Set"><tt class="xref py py-class docutils literal"><span class="pre">Set</span></tt></a> from set named <tt class="docutils literal"><span class="pre">name</span></tt> in HDF5 data <tt class="docutils literal"><span class="pre">f</span></tt></p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.Set.core_part">
<tt class="descname">core_part</tt><a class="headerlink" href="#pyop2.base.Set.core_part" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyop2.base.Set.owned_part">
<tt class="descname">owned_part</tt><a class="headerlink" href="#pyop2.base.Set.owned_part" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyop2.base.Set.exec_part">
<tt class="descname">exec_part</tt><a class="headerlink" href="#pyop2.base.Set.exec_part" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyop2.base.Set.all_part">
<tt class="descname">all_part</tt><a class="headerlink" href="#pyop2.base.Set.all_part" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyop2.base.ExtrudedSet">
<em class="property">class </em><tt class="descclassname">pyop2.base.</tt><tt class="descname">ExtrudedSet</tt><big>(</big><em>parent</em>, <em>layers</em><big>)</big><a class="headerlink" href="#pyop2.base.ExtrudedSet" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyop2.base.Set" title="pyop2.base.Set"><tt class="xref py py-class docutils literal"><span class="pre">pyop2.base.Set</span></tt></a></p>
<p>OP2 ExtrudedSet.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>parent</strong> (a <a class="reference internal" href="#pyop2.base.Set" title="pyop2.base.Set"><tt class="xref py py-class docutils literal"><span class="pre">Set</span></tt></a>.) &#8211; The parent <a class="reference internal" href="#pyop2.base.Set" title="pyop2.base.Set"><tt class="xref py py-class docutils literal"><span class="pre">Set</span></tt></a> to build this <a class="reference internal" href="#pyop2.base.ExtrudedSet" title="pyop2.base.ExtrudedSet"><tt class="xref py py-class docutils literal"><span class="pre">ExtrudedSet</span></tt></a> on top of</li>
<li><strong>layers</strong> (<em>an integer.</em>) &#8211; The number of layers in this <a class="reference internal" href="#pyop2.base.ExtrudedSet" title="pyop2.base.ExtrudedSet"><tt class="xref py py-class docutils literal"><span class="pre">ExtrudedSet</span></tt></a>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>The number of layers indicates the number of time the base set is
extruded in the direction of the <a class="reference internal" href="#pyop2.base.ExtrudedSet" title="pyop2.base.ExtrudedSet"><tt class="xref py py-class docutils literal"><span class="pre">ExtrudedSet</span></tt></a>.  As a
result, there are <tt class="docutils literal"><span class="pre">layers-1</span></tt> extruded &#8220;cells&#8221; in an extruded set.</p>
<dl class="attribute">
<dt id="pyop2.base.ExtrudedSet.parent">
<tt class="descname">parent</tt><a class="headerlink" href="#pyop2.base.ExtrudedSet.parent" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyop2.base.ExtrudedSet.layers">
<tt class="descname">layers</tt><a class="headerlink" href="#pyop2.base.ExtrudedSet.layers" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of layers in this extruded set.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyop2.base.Subset">
<em class="property">class </em><tt class="descclassname">pyop2.base.</tt><tt class="descname">Subset</tt><big>(</big><em>superset</em>, <em>indices</em><big>)</big><a class="headerlink" href="#pyop2.base.Subset" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyop2.base.ExtrudedSet" title="pyop2.base.ExtrudedSet"><tt class="xref py py-class docutils literal"><span class="pre">pyop2.base.ExtrudedSet</span></tt></a></p>
<p>OP2 subset.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>superset</strong> (a <a class="reference internal" href="#pyop2.base.Set" title="pyop2.base.Set"><tt class="xref py py-class docutils literal"><span class="pre">Set</span></tt></a> or a <a class="reference internal" href="#pyop2.base.Subset" title="pyop2.base.Subset"><tt class="xref py py-class docutils literal"><span class="pre">Subset</span></tt></a>.) &#8211; The superset of the subset.</li>
<li><strong>indices</strong> (<em>a list of integers, or a numpy array.</em>) &#8211; Elements of the superset that form the
subset. Duplicate values are removed when constructing the subset.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="pyop2.base.Subset.superset">
<tt class="descname">superset</tt><a class="headerlink" href="#pyop2.base.Subset.superset" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the superset Set</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.Subset.indices">
<tt class="descname">indices</tt><a class="headerlink" href="#pyop2.base.Subset.indices" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the indices pointing in the superset.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyop2.base.SetPartition">
<em class="property">class </em><tt class="descclassname">pyop2.base.</tt><tt class="descname">SetPartition</tt><big>(</big><em>set</em>, <em>offset</em>, <em>size</em><big>)</big><a class="headerlink" href="#pyop2.base.SetPartition" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
</dd></dl>

<dl class="class">
<dt id="pyop2.base.MixedSet">
<em class="property">class </em><tt class="descclassname">pyop2.base.</tt><tt class="descname">MixedSet</tt><big>(</big><em>sets</em><big>)</big><a class="headerlink" href="#pyop2.base.MixedSet" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyop2.base.Set" title="pyop2.base.Set"><tt class="xref py py-class docutils literal"><span class="pre">pyop2.base.Set</span></tt></a></p>
<p>A container for a bag of <a class="reference internal" href="#pyop2.base.Set" title="pyop2.base.Set"><tt class="xref py py-class docutils literal"><span class="pre">Set</span></tt></a>s.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>sets</strong> (<em>iterable</em>) &#8211; Iterable of <a class="reference internal" href="#pyop2.base.Set" title="pyop2.base.Set"><tt class="xref py py-class docutils literal"><span class="pre">Set</span></tt></a>s or <a class="reference internal" href="#pyop2.base.ExtrudedSet" title="pyop2.base.ExtrudedSet"><tt class="xref py py-class docutils literal"><span class="pre">ExtrudedSet</span></tt></a>s</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="pyop2.base.MixedSet.split">
<tt class="descname">split</tt><a class="headerlink" href="#pyop2.base.MixedSet.split" title="Permalink to this definition">¶</a></dt>
<dd><p>The underlying tuple of <a class="reference internal" href="#pyop2.base.Set" title="pyop2.base.Set"><tt class="xref py py-class docutils literal"><span class="pre">Set</span></tt></a>s.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.MixedSet.core_size">
<tt class="descname">core_size</tt><a class="headerlink" href="#pyop2.base.MixedSet.core_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Core set size. Owned elements not touching halo elements.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.MixedSet.size">
<tt class="descname">size</tt><a class="headerlink" href="#pyop2.base.MixedSet.size" title="Permalink to this definition">¶</a></dt>
<dd><p>Set size, owned elements.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.MixedSet.exec_size">
<tt class="descname">exec_size</tt><a class="headerlink" href="#pyop2.base.MixedSet.exec_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Set size including execute halo elements.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.MixedSet.total_size">
<tt class="descname">total_size</tt><a class="headerlink" href="#pyop2.base.MixedSet.total_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Total set size, including halo elements.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.MixedSet.sizes">
<tt class="descname">sizes</tt><a class="headerlink" href="#pyop2.base.MixedSet.sizes" title="Permalink to this definition">¶</a></dt>
<dd><p>Set sizes: core, owned, execute halo, total.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.MixedSet.name">
<tt class="descname">name</tt><a class="headerlink" href="#pyop2.base.MixedSet.name" title="Permalink to this definition">¶</a></dt>
<dd><p>User-defined labels.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.MixedSet.halo">
<tt class="descname">halo</tt><a class="headerlink" href="#pyop2.base.MixedSet.halo" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#pyop2.base.Halo" title="pyop2.base.Halo"><tt class="xref py py-class docutils literal"><span class="pre">Halo</span></tt></a>s associated with these <a class="reference internal" href="#pyop2.base.Set" title="pyop2.base.Set"><tt class="xref py py-class docutils literal"><span class="pre">Set</span></tt></a>s.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.MixedSet.layers">
<tt class="descname">layers</tt><a class="headerlink" href="#pyop2.base.MixedSet.layers" title="Permalink to this definition">¶</a></dt>
<dd><p>Numbers of layers in the extruded mesh (or None if this MixedSet is not extruded).</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyop2.base.DataSet">
<em class="property">class </em><tt class="descclassname">pyop2.base.</tt><tt class="descname">DataSet</tt><big>(</big><em>iter_set</em>, <em>dim=1</em>, <em>name=None</em><big>)</big><a class="headerlink" href="#pyop2.base.DataSet" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>PyOP2 Data Set</p>
<p>Set used in the op2.Dat structures to specify the dimension of the data.</p>
<dl class="attribute">
<dt id="pyop2.base.DataSet.dim">
<tt class="descname">dim</tt><a class="headerlink" href="#pyop2.base.DataSet.dim" title="Permalink to this definition">¶</a></dt>
<dd><p>The shape tuple of the values for each element of the set.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.DataSet.cdim">
<tt class="descname">cdim</tt><a class="headerlink" href="#pyop2.base.DataSet.cdim" title="Permalink to this definition">¶</a></dt>
<dd><p>The scalar number of values for each member of the set. This is
the product of the dim tuple.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.DataSet.name">
<tt class="descname">name</tt><a class="headerlink" href="#pyop2.base.DataSet.name" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the name of the data set.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.DataSet.set">
<tt class="descname">set</tt><a class="headerlink" href="#pyop2.base.DataSet.set" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the parent set of the data set.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyop2.base.MixedDataSet">
<em class="property">class </em><tt class="descclassname">pyop2.base.</tt><tt class="descname">MixedDataSet</tt><big>(</big><em>arg</em>, <em>dims=None</em><big>)</big><a class="headerlink" href="#pyop2.base.MixedDataSet" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyop2.base.DataSet" title="pyop2.base.DataSet"><tt class="xref py py-class docutils literal"><span class="pre">pyop2.base.DataSet</span></tt></a></p>
<p>A container for a bag of <a class="reference internal" href="#pyop2.base.DataSet" title="pyop2.base.DataSet"><tt class="xref py py-class docutils literal"><span class="pre">DataSet</span></tt></a>s.</p>
<p>Initialized either from a <a class="reference internal" href="#pyop2.base.MixedSet" title="pyop2.base.MixedSet"><tt class="xref py py-class docutils literal"><span class="pre">MixedSet</span></tt></a> and an iterable or iterator of
<tt class="docutils literal"><span class="pre">dims</span></tt> of corresponding length</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">mdset</span> <span class="o">=</span> <span class="n">op2</span><span class="o">.</span><span class="n">MixedDataSet</span><span class="p">(</span><span class="n">mset</span><span class="p">,</span> <span class="p">[</span><span class="n">dim1</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">dimN</span><span class="p">])</span>
</pre></div>
</div>
<p>or from a tuple of <a class="reference internal" href="#pyop2.base.Set" title="pyop2.base.Set"><tt class="xref py py-class docutils literal"><span class="pre">Set</span></tt></a>s and an iterable of <tt class="docutils literal"><span class="pre">dims</span></tt> of
corresponding length</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">mdset</span> <span class="o">=</span> <span class="n">op2</span><span class="o">.</span><span class="n">MixedDataSet</span><span class="p">([</span><span class="n">set1</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">setN</span><span class="p">],</span> <span class="p">[</span><span class="n">dim1</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">dimN</span><span class="p">])</span>
</pre></div>
</div>
<p>If all <tt class="docutils literal"><span class="pre">dims</span></tt> are to be the same, they can also be given as an
<tt class="xref py py-class docutils literal"><span class="pre">int</span></tt> for either of above invocations</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">mdset</span> <span class="o">=</span> <span class="n">op2</span><span class="o">.</span><span class="n">MixedDataSet</span><span class="p">(</span><span class="n">mset</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span>
<span class="n">mdset</span> <span class="o">=</span> <span class="n">op2</span><span class="o">.</span><span class="n">MixedDataSet</span><span class="p">([</span><span class="n">set1</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">setN</span><span class="p">],</span> <span class="n">dim</span><span class="p">)</span>
</pre></div>
</div>
<p>Initialized from a <a class="reference internal" href="#pyop2.base.MixedSet" title="pyop2.base.MixedSet"><tt class="xref py py-class docutils literal"><span class="pre">MixedSet</span></tt></a> without explicitly specifying <tt class="docutils literal"><span class="pre">dims</span></tt>
they default to 1</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">mdset</span> <span class="o">=</span> <span class="n">op2</span><span class="o">.</span><span class="n">MixedDataSet</span><span class="p">(</span><span class="n">mset</span><span class="p">)</span>
</pre></div>
</div>
<p>Initialized from an iterable or iterator of <a class="reference internal" href="#pyop2.base.DataSet" title="pyop2.base.DataSet"><tt class="xref py py-class docutils literal"><span class="pre">DataSet</span></tt></a>s and/or
<a class="reference internal" href="#pyop2.base.Set" title="pyop2.base.Set"><tt class="xref py py-class docutils literal"><span class="pre">Set</span></tt></a>s, where <a class="reference internal" href="#pyop2.base.Set" title="pyop2.base.Set"><tt class="xref py py-class docutils literal"><span class="pre">Set</span></tt></a>s are implicitly upcast to
<a class="reference internal" href="#pyop2.base.DataSet" title="pyop2.base.DataSet"><tt class="xref py py-class docutils literal"><span class="pre">DataSet</span></tt></a>s of dim 1</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">mdset</span> <span class="o">=</span> <span class="n">op2</span><span class="o">.</span><span class="n">MixedDataSet</span><span class="p">([</span><span class="n">dset1</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">dsetN</span><span class="p">])</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>arg</strong> &#8211; a <a class="reference internal" href="#pyop2.base.MixedSet" title="pyop2.base.MixedSet"><tt class="xref py py-class docutils literal"><span class="pre">MixedSet</span></tt></a> or an iterable or a generator
expression of <a class="reference internal" href="#pyop2.base.Set" title="pyop2.base.Set"><tt class="xref py py-class docutils literal"><span class="pre">Set</span></tt></a>s or <a class="reference internal" href="#pyop2.base.DataSet" title="pyop2.base.DataSet"><tt class="xref py py-class docutils literal"><span class="pre">DataSet</span></tt></a>s or a
mixture of both</li>
<li><strong>dims</strong> &#8211; <cite>None</cite> (the default) or an <tt class="xref py py-class docutils literal"><span class="pre">int</span></tt> or an iterable or
generator expression of <tt class="xref py py-class docutils literal"><span class="pre">int</span></tt>s, which <strong>must</strong> be
of same length as <cite>arg</cite></li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">When using generator expressions for <tt class="docutils literal"><span class="pre">arg</span></tt> or <tt class="docutils literal"><span class="pre">dims</span></tt>, these
<strong>must</strong> terminate or else will cause an infinite loop.</p>
</div>
<dl class="attribute">
<dt id="pyop2.base.MixedDataSet.split">
<tt class="descname">split</tt><a class="headerlink" href="#pyop2.base.MixedDataSet.split" title="Permalink to this definition">¶</a></dt>
<dd><p>The underlying tuple of <a class="reference internal" href="#pyop2.base.DataSet" title="pyop2.base.DataSet"><tt class="xref py py-class docutils literal"><span class="pre">DataSet</span></tt></a>s.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.MixedDataSet.dim">
<tt class="descname">dim</tt><a class="headerlink" href="#pyop2.base.MixedDataSet.dim" title="Permalink to this definition">¶</a></dt>
<dd><p>The shape tuple of the values for each element of the sets.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.MixedDataSet.cdim">
<tt class="descname">cdim</tt><a class="headerlink" href="#pyop2.base.MixedDataSet.cdim" title="Permalink to this definition">¶</a></dt>
<dd><p>The scalar number of values for each member of the sets. This is
the product of the dim tuples.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.MixedDataSet.name">
<tt class="descname">name</tt><a class="headerlink" href="#pyop2.base.MixedDataSet.name" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the name of the data sets.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.MixedDataSet.set">
<tt class="descname">set</tt><a class="headerlink" href="#pyop2.base.MixedDataSet.set" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the <a class="reference internal" href="#pyop2.base.MixedSet" title="pyop2.base.MixedSet"><tt class="xref py py-class docutils literal"><span class="pre">MixedSet</span></tt></a> this <a class="reference internal" href="#pyop2.base.MixedDataSet" title="pyop2.base.MixedDataSet"><tt class="xref py py-class docutils literal"><span class="pre">MixedDataSet</span></tt></a> is
defined on.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyop2.base.Halo">
<em class="property">class </em><tt class="descclassname">pyop2.base.</tt><tt class="descname">Halo</tt><big>(</big><em>sends</em>, <em>receives</em>, <em>comm=None</em>, <em>gnn2unn=None</em><big>)</big><a class="headerlink" href="#pyop2.base.Halo" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>A description of a halo associated with a <a class="reference internal" href="#pyop2.base.Set" title="pyop2.base.Set"><tt class="xref py py-class docutils literal"><span class="pre">Set</span></tt></a>.</p>
<p>The halo object describes which <a class="reference internal" href="#pyop2.base.Set" title="pyop2.base.Set"><tt class="xref py py-class docutils literal"><span class="pre">Set</span></tt></a> elements are sent
where, and which <a class="reference internal" href="#pyop2.base.Set" title="pyop2.base.Set"><tt class="xref py py-class docutils literal"><span class="pre">Set</span></tt></a> elements are received from where.</p>
<p>The <cite>sends</cite> should be a dict whose key is the process we want to
send to, similarly the <cite>receives</cite> should be a dict whose key is the
process we want to receive from.  The value should in each case be
a numpy array of the set elements to send to/receive from each
<cite>process</cite>.</p>
<p>The gnn2unn array is a map from process-local set element
numbering to cross-process set element numbering.  It must
correctly number all the set elements in the halo region as well
as owned elements.  Providing this array is only necessary if you
will access <a class="reference internal" href="#pyop2.base.Mat" title="pyop2.base.Mat"><tt class="xref py py-class docutils literal"><span class="pre">Mat</span></tt></a> objects on the <a class="reference internal" href="#pyop2.base.Set" title="pyop2.base.Set"><tt class="xref py py-class docutils literal"><span class="pre">Set</span></tt></a> this <cite>Halo</cite>
lives on.  Insertion into <a class="reference internal" href="#pyop2.base.Dat" title="pyop2.base.Dat"><tt class="xref py py-class docutils literal"><span class="pre">Dat</span></tt></a>s always uses process-local
numbering, however insertion into <a class="reference internal" href="#pyop2.base.Mat" title="pyop2.base.Mat"><tt class="xref py py-class docutils literal"><span class="pre">Mat</span></tt></a>s uses cross-process
numbering under the hood.</p>
<dl class="attribute">
<dt id="pyop2.base.Halo.sends">
<tt class="descname">sends</tt><a class="headerlink" href="#pyop2.base.Halo.sends" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sends associated with this <a class="reference internal" href="#pyop2.base.Halo" title="pyop2.base.Halo"><tt class="xref py py-class docutils literal"><span class="pre">Halo</span></tt></a>.</p>
<p>A dict of numpy arrays, keyed by the rank to send to, with
each array indicating the <a class="reference internal" href="#pyop2.base.Set" title="pyop2.base.Set"><tt class="xref py py-class docutils literal"><span class="pre">Set</span></tt></a> elements to send.</p>
<p>For example, to send no elements to rank 0, elements 1 and 2 to rank 1
and no elements to rank 2 (with <tt class="docutils literal"><span class="pre">comm.size</span> <span class="pre">==</span> <span class="pre">3</span></tt>) we would have:</p>
<div class="highlight-python"><pre>{1: np.array([1,2], dtype=np.int32)}.</pre>
</div>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.Halo.receives">
<tt class="descname">receives</tt><a class="headerlink" href="#pyop2.base.Halo.receives" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the receives associated with this <a class="reference internal" href="#pyop2.base.Halo" title="pyop2.base.Halo"><tt class="xref py py-class docutils literal"><span class="pre">Halo</span></tt></a>.</p>
<p>A dict of numpy arrays, keyed by the rank to receive from,
with each array indicating the <a class="reference internal" href="#pyop2.base.Set" title="pyop2.base.Set"><tt class="xref py py-class docutils literal"><span class="pre">Set</span></tt></a> elements to
receive.</p>
<p>See <a class="reference internal" href="#pyop2.base.Halo.sends" title="pyop2.base.Halo.sends"><tt class="xref py py-func docutils literal"><span class="pre">Halo.sends()</span></tt></a> for an example.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.Halo.global_to_petsc_numbering">
<tt class="descname">global_to_petsc_numbering</tt><a class="headerlink" href="#pyop2.base.Halo.global_to_petsc_numbering" title="Permalink to this definition">¶</a></dt>
<dd><p>The mapping from global (per-process) dof numbering to
petsc (cross-process) dof numbering.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.Halo.comm">
<tt class="descname">comm</tt><a class="headerlink" href="#pyop2.base.Halo.comm" title="Permalink to this definition">¶</a></dt>
<dd><p>The MPI communicator this <a class="reference internal" href="#pyop2.base.Halo" title="pyop2.base.Halo"><tt class="xref py py-class docutils literal"><span class="pre">Halo</span></tt></a>&#8216;s communications
should take place over</p>
</dd></dl>

<dl class="method">
<dt id="pyop2.base.Halo.verify">
<tt class="descname">verify</tt><big>(</big><em>s</em><big>)</big><a class="headerlink" href="#pyop2.base.Halo.verify" title="Permalink to this definition">¶</a></dt>
<dd><p>Verify that this <a class="reference internal" href="#pyop2.base.Halo" title="pyop2.base.Halo"><tt class="xref py py-class docutils literal"><span class="pre">Halo</span></tt></a> is valid for a given
<a class="reference internal" href="#pyop2.base.Set" title="pyop2.base.Set"><tt class="xref py py-class docutils literal"><span class="pre">Set</span></tt></a>.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyop2.base.IterationSpace">
<em class="property">class </em><tt class="descclassname">pyop2.base.</tt><tt class="descname">IterationSpace</tt><big>(</big><em>iterset</em>, <em>block_shape=None</em>, <em>offsets=None</em><big>)</big><a class="headerlink" href="#pyop2.base.IterationSpace" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>OP2 iteration space type.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">User code should not directly instantiate <a class="reference internal" href="#pyop2.base.IterationSpace" title="pyop2.base.IterationSpace"><tt class="xref py py-class docutils literal"><span class="pre">IterationSpace</span></tt></a>.
This class is only for internal use inside a
<a class="reference internal" href="#pyop2.op2.par_loop" title="pyop2.op2.par_loop"><tt class="xref py py-func docutils literal"><span class="pre">pyop2.op2.par_loop()</span></tt></a>.</p>
</div>
<dl class="attribute">
<dt id="pyop2.base.IterationSpace.iterset">
<tt class="descname">iterset</tt><a class="headerlink" href="#pyop2.base.IterationSpace.iterset" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="#pyop2.base.Set" title="pyop2.base.Set"><tt class="xref py py-class docutils literal"><span class="pre">Set</span></tt></a> over which this IterationSpace is defined.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.IterationSpace.extents">
<tt class="descname">extents</tt><a class="headerlink" href="#pyop2.base.IterationSpace.extents" title="Permalink to this definition">¶</a></dt>
<dd><p>Extents of the IterationSpace within each item of <tt class="docutils literal"><span class="pre">iterset</span></tt></p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.IterationSpace.name">
<tt class="descname">name</tt><a class="headerlink" href="#pyop2.base.IterationSpace.name" title="Permalink to this definition">¶</a></dt>
<dd><p>The name of the <a class="reference internal" href="#pyop2.base.Set" title="pyop2.base.Set"><tt class="xref py py-class docutils literal"><span class="pre">Set</span></tt></a> over which this IterationSpace is
defined.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.IterationSpace.core_size">
<tt class="descname">core_size</tt><a class="headerlink" href="#pyop2.base.IterationSpace.core_size" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of <a class="reference internal" href="#pyop2.base.Set" title="pyop2.base.Set"><tt class="xref py py-class docutils literal"><span class="pre">Set</span></tt></a> elements which don&#8217;t touch halo elements in the set
over which this IterationSpace is defined</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.IterationSpace.size">
<tt class="descname">size</tt><a class="headerlink" href="#pyop2.base.IterationSpace.size" title="Permalink to this definition">¶</a></dt>
<dd><p>The size of the <a class="reference internal" href="#pyop2.base.Set" title="pyop2.base.Set"><tt class="xref py py-class docutils literal"><span class="pre">Set</span></tt></a> over which this IterationSpace is defined.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.IterationSpace.exec_size">
<tt class="descname">exec_size</tt><a class="headerlink" href="#pyop2.base.IterationSpace.exec_size" title="Permalink to this definition">¶</a></dt>
<dd><p>The size of the <a class="reference internal" href="#pyop2.base.Set" title="pyop2.base.Set"><tt class="xref py py-class docutils literal"><span class="pre">Set</span></tt></a> over which this IterationSpace
is defined, including halo elements to be executed over</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.IterationSpace.layers">
<tt class="descname">layers</tt><a class="headerlink" href="#pyop2.base.IterationSpace.layers" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of layers in the extruded set (or None if this is not an
extruded iteration space)</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.IterationSpace.partition_size">
<tt class="descname">partition_size</tt><a class="headerlink" href="#pyop2.base.IterationSpace.partition_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Default partition size</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.IterationSpace.total_size">
<tt class="descname">total_size</tt><a class="headerlink" href="#pyop2.base.IterationSpace.total_size" title="Permalink to this definition">¶</a></dt>
<dd><p>The total size of <a class="reference internal" href="#pyop2.base.Set" title="pyop2.base.Set"><tt class="xref py py-class docutils literal"><span class="pre">Set</span></tt></a> over which this IterationSpace is defined.</p>
<p>This includes all halo set elements.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.IterationSpace.cache_key">
<tt class="descname">cache_key</tt><a class="headerlink" href="#pyop2.base.IterationSpace.cache_key" title="Permalink to this definition">¶</a></dt>
<dd><p>Cache key used to uniquely identify the object in the cache.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyop2.base.DataCarrier">
<em class="property">class </em><tt class="descclassname">pyop2.base.</tt><tt class="descname">DataCarrier</tt><a class="headerlink" href="#pyop2.base.DataCarrier" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyop2.versioning.Versioned" title="pyop2.versioning.Versioned"><tt class="xref py py-class docutils literal"><span class="pre">pyop2.versioning.Versioned</span></tt></a></p>
<p>Abstract base class for OP2 data.</p>
<p>Actual objects will be <a class="reference internal" href="#pyop2.base.DataCarrier" title="pyop2.base.DataCarrier"><tt class="xref py py-class docutils literal"><span class="pre">DataCarrier</span></tt></a> objects of rank 0
(<a class="reference internal" href="#pyop2.base.Const" title="pyop2.base.Const"><tt class="xref py py-class docutils literal"><span class="pre">Const</span></tt></a> and <a class="reference internal" href="#pyop2.base.Global" title="pyop2.base.Global"><tt class="xref py py-class docutils literal"><span class="pre">Global</span></tt></a>), rank 1 (<a class="reference internal" href="#pyop2.base.Dat" title="pyop2.base.Dat"><tt class="xref py py-class docutils literal"><span class="pre">Dat</span></tt></a>), or rank 2
(<a class="reference internal" href="#pyop2.base.Mat" title="pyop2.base.Mat"><tt class="xref py py-class docutils literal"><span class="pre">Mat</span></tt></a>)</p>
<dl class="class">
<dt id="pyop2.base.DataCarrier.Snapshot">
<em class="property">class </em><tt class="descname">Snapshot</tt><big>(</big><em>obj</em><big>)</big><a class="headerlink" href="#pyop2.base.DataCarrier.Snapshot" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>A snapshot of the current state of the DataCarrier object. If
is_valid() returns True, then the object hasn&#8217;t changed since this
snapshot was taken (and still exists).</p>
<dl class="method">
<dt id="pyop2.base.DataCarrier.Snapshot.is_valid">
<tt class="descname">is_valid</tt><big>(</big><big>)</big><a class="headerlink" href="#pyop2.base.DataCarrier.Snapshot.is_valid" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="method">
<dt id="pyop2.base.DataCarrier.create_snapshot">
<tt class="descclassname">DataCarrier.</tt><tt class="descname">create_snapshot</tt><big>(</big><big>)</big><a class="headerlink" href="#pyop2.base.DataCarrier.create_snapshot" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a snapshot of the current object. If not overriden, this
method will return a full duplicate object.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.DataCarrier.dtype">
<tt class="descclassname">DataCarrier.</tt><tt class="descname">dtype</tt><a class="headerlink" href="#pyop2.base.DataCarrier.dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>The Python type of the data.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.DataCarrier.ctype">
<tt class="descclassname">DataCarrier.</tt><tt class="descname">ctype</tt><a class="headerlink" href="#pyop2.base.DataCarrier.ctype" title="Permalink to this definition">¶</a></dt>
<dd><p>The c type of the data.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.DataCarrier.name">
<tt class="descclassname">DataCarrier.</tt><tt class="descname">name</tt><a class="headerlink" href="#pyop2.base.DataCarrier.name" title="Permalink to this definition">¶</a></dt>
<dd><p>User-defined label.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.DataCarrier.dim">
<tt class="descclassname">DataCarrier.</tt><tt class="descname">dim</tt><a class="headerlink" href="#pyop2.base.DataCarrier.dim" title="Permalink to this definition">¶</a></dt>
<dd><p>The shape tuple of the values for each element of the object.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.DataCarrier.cdim">
<tt class="descclassname">DataCarrier.</tt><tt class="descname">cdim</tt><a class="headerlink" href="#pyop2.base.DataCarrier.cdim" title="Permalink to this definition">¶</a></dt>
<dd><p>The scalar number of values for each member of the object. This is
the product of the dim tuple.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyop2.base.SetAssociated">
<em class="property">class </em><tt class="descclassname">pyop2.base.</tt><tt class="descname">SetAssociated</tt><a class="headerlink" href="#pyop2.base.SetAssociated" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyop2.base.DataCarrier" title="pyop2.base.DataCarrier"><tt class="xref py py-class docutils literal"><span class="pre">pyop2.base.DataCarrier</span></tt></a></p>
<p>Intermediate class between DataCarrier and subtypes associated with a
Set (vectors and matrices).</p>
<dl class="class">
<dt id="pyop2.base.SetAssociated.Snapshot">
<em class="property">class </em><tt class="descname">Snapshot</tt><big>(</big><em>obj</em><big>)</big><a class="headerlink" href="#pyop2.base.SetAssociated.Snapshot" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>A snapshot for SetAssociated objects is valid if the snapshot
version is the same as the current version of the object</p>
<dl class="method">
<dt id="pyop2.base.SetAssociated.Snapshot.is_valid">
<tt class="descname">is_valid</tt><big>(</big><big>)</big><a class="headerlink" href="#pyop2.base.SetAssociated.Snapshot.is_valid" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyop2.base.Dat">
<em class="property">class </em><tt class="descclassname">pyop2.base.</tt><tt class="descname">Dat</tt><big>(</big><em>dataset</em>, <em>data=None</em>, <em>dtype=None</em>, <em>name=None</em>, <em>soa=None</em>, <em>uid=None</em><big>)</big><a class="headerlink" href="#pyop2.base.Dat" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyop2.base.SetAssociated" title="pyop2.base.SetAssociated"><tt class="xref py py-class docutils literal"><span class="pre">pyop2.base.SetAssociated</span></tt></a>, <tt class="xref py py-class docutils literal"><span class="pre">pyop2.base._EmptyDataMixin</span></tt>, <a class="reference internal" href="#pyop2.versioning.CopyOnWrite" title="pyop2.versioning.CopyOnWrite"><tt class="xref py py-class docutils literal"><span class="pre">pyop2.versioning.CopyOnWrite</span></tt></a></p>
<p>OP2 vector data. A <a class="reference internal" href="#pyop2.base.Dat" title="pyop2.base.Dat"><tt class="xref py py-class docutils literal"><span class="pre">Dat</span></tt></a> holds values on every element of a
<a class="reference internal" href="#pyop2.base.DataSet" title="pyop2.base.DataSet"><tt class="xref py py-class docutils literal"><span class="pre">DataSet</span></tt></a>.</p>
<p>If a <a class="reference internal" href="#pyop2.base.Set" title="pyop2.base.Set"><tt class="xref py py-class docutils literal"><span class="pre">Set</span></tt></a> is passed as the <tt class="docutils literal"><span class="pre">dataset</span></tt> argument, rather
than a <a class="reference internal" href="#pyop2.base.DataSet" title="pyop2.base.DataSet"><tt class="xref py py-class docutils literal"><span class="pre">DataSet</span></tt></a>, the <a class="reference internal" href="#pyop2.base.Dat" title="pyop2.base.Dat"><tt class="xref py py-class docutils literal"><span class="pre">Dat</span></tt></a> is created with a default
<a class="reference internal" href="#pyop2.base.DataSet" title="pyop2.base.DataSet"><tt class="xref py py-class docutils literal"><span class="pre">DataSet</span></tt></a> dimension of 1.</p>
<p>If a <a class="reference internal" href="#pyop2.base.Dat" title="pyop2.base.Dat"><tt class="xref py py-class docutils literal"><span class="pre">Dat</span></tt></a> is passed as the <tt class="docutils literal"><span class="pre">dataset</span></tt> argument, a copy is
returned.</p>
<p>It is permissible to pass <cite>None</cite> as the <cite>data</cite> argument.  In this
case, allocation of the data buffer is postponed until it is
accessed.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If the data buffer is not passed in, it is implicitly
initialised to be zero.</p>
</div>
<p>When a <a class="reference internal" href="#pyop2.base.Dat" title="pyop2.base.Dat"><tt class="xref py py-class docutils literal"><span class="pre">Dat</span></tt></a> is passed to <a class="reference internal" href="#pyop2.op2.par_loop" title="pyop2.op2.par_loop"><tt class="xref py py-func docutils literal"><span class="pre">pyop2.op2.par_loop()</span></tt></a>, the map via
which indirection occurs and the access descriptor are passed by
calling the <a class="reference internal" href="#pyop2.base.Dat" title="pyop2.base.Dat"><tt class="xref py py-class docutils literal"><span class="pre">Dat</span></tt></a>. For instance, if a <a class="reference internal" href="#pyop2.base.Dat" title="pyop2.base.Dat"><tt class="xref py py-class docutils literal"><span class="pre">Dat</span></tt></a> named <tt class="docutils literal"><span class="pre">D</span></tt> is
to be accessed for reading via a <a class="reference internal" href="#pyop2.base.Map" title="pyop2.base.Map"><tt class="xref py py-class docutils literal"><span class="pre">Map</span></tt></a> named <tt class="docutils literal"><span class="pre">M</span></tt>, this is
accomplished by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">D</span><span class="p">(</span><span class="n">pyop2</span><span class="o">.</span><span class="n">READ</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="#pyop2.base.Map" title="pyop2.base.Map"><tt class="xref py py-class docutils literal"><span class="pre">Map</span></tt></a> through which indirection occurs can be indexed
using the index notation described in the documentation for the
<a class="reference internal" href="#pyop2.base.Map" title="pyop2.base.Map"><tt class="xref py py-class docutils literal"><span class="pre">Map</span></tt></a>. Direct access to a Dat is accomplished by
omitting the path argument.</p>
<p><a class="reference internal" href="#pyop2.base.Dat" title="pyop2.base.Dat"><tt class="xref py py-class docutils literal"><span class="pre">Dat</span></tt></a> objects support the pointwise linear algebra operations
<tt class="docutils literal"><span class="pre">+=</span></tt>, <tt class="docutils literal"><span class="pre">*=</span></tt>, <tt class="docutils literal"><span class="pre">-=</span></tt>, <tt class="docutils literal"><span class="pre">/=</span></tt>, where <tt class="docutils literal"><span class="pre">*=</span></tt> and <tt class="docutils literal"><span class="pre">/=</span></tt> also support
multiplication / division by a scalar.</p>
<dl class="attribute">
<dt id="pyop2.base.Dat.split">
<tt class="descname">split</tt><a class="headerlink" href="#pyop2.base.Dat.split" title="Permalink to this definition">¶</a></dt>
<dd><p>Tuple containing only this <a class="reference internal" href="#pyop2.base.Dat" title="pyop2.base.Dat"><tt class="xref py py-class docutils literal"><span class="pre">Dat</span></tt></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.Dat.dataset">
<tt class="descname">dataset</tt><a class="headerlink" href="#pyop2.base.Dat.dataset" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#pyop2.base.DataSet" title="pyop2.base.DataSet"><tt class="xref py py-class docutils literal"><span class="pre">DataSet</span></tt></a> on which the Dat is defined.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.Dat.dim">
<tt class="descname">dim</tt><a class="headerlink" href="#pyop2.base.Dat.dim" title="Permalink to this definition">¶</a></dt>
<dd><p>The shape of the values for each element of the object.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.Dat.cdim">
<tt class="descname">cdim</tt><a class="headerlink" href="#pyop2.base.Dat.cdim" title="Permalink to this definition">¶</a></dt>
<dd><p>The scalar number of values for each member of the object. This is
the product of the dim tuple.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.Dat.soa">
<tt class="descname">soa</tt><a class="headerlink" href="#pyop2.base.Dat.soa" title="Permalink to this definition">¶</a></dt>
<dd><p>Are the data in SoA format?</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.Dat.data">
<tt class="descname">data</tt><a class="headerlink" href="#pyop2.base.Dat.data" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyop2.base.Dat.data_with_halos">
<tt class="descname">data_with_halos</tt><a class="headerlink" href="#pyop2.base.Dat.data_with_halos" title="Permalink to this definition">¶</a></dt>
<dd><p>A view of this <a class="reference internal" href="#pyop2.base.Dat" title="pyop2.base.Dat"><tt class="xref py py-class docutils literal"><span class="pre">Dat</span></tt></a>s data.</p>
<p>This accessor marks the <a class="reference internal" href="#pyop2.base.Dat" title="pyop2.base.Dat"><tt class="xref py py-class docutils literal"><span class="pre">Dat</span></tt></a> as dirty, see
<a class="reference internal" href="#pyop2.base.Dat.data" title="pyop2.base.Dat.data"><tt class="xref py py-meth docutils literal"><span class="pre">data()</span></tt></a> for more details on the semantics.</p>
<p>With this accessor, you get to see up to date halo values, but
you should not try and modify them, because they will be
overwritten by the next halo exchange.</p>
<p>This function is logically collective over MPI ranks, it is an
error to call it on fewer than all the ranks in MPI communicator.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.Dat.data_ro">
<tt class="descname">data_ro</tt><a class="headerlink" href="#pyop2.base.Dat.data_ro" title="Permalink to this definition">¶</a></dt>
<dd><p>Numpy array containing the data values.  Read-only.</p>
<p>With this accessor you are not allowed to modify the values
you get back.  If you need to do so, use <a class="reference internal" href="#pyop2.base.Dat.data" title="pyop2.base.Dat.data"><tt class="xref py py-meth docutils literal"><span class="pre">data()</span></tt></a> instead.</p>
<p>This only shows local values, to see the halo values too use
<a class="reference internal" href="#pyop2.base.Dat.data_ro_with_halos" title="pyop2.base.Dat.data_ro_with_halos"><tt class="xref py py-meth docutils literal"><span class="pre">data_ro_with_halos()</span></tt></a>.</p>
<p>This function is logically collective over MPI ranks, it is an
error to call it on fewer than all the ranks in MPI communicator.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.Dat.data_ro_with_halos">
<tt class="descname">data_ro_with_halos</tt><a class="headerlink" href="#pyop2.base.Dat.data_ro_with_halos" title="Permalink to this definition">¶</a></dt>
<dd><p>A view of this <a class="reference internal" href="#pyop2.base.Dat" title="pyop2.base.Dat"><tt class="xref py py-class docutils literal"><span class="pre">Dat</span></tt></a>s data.</p>
<p>This accessor does not mark the <a class="reference internal" href="#pyop2.base.Dat" title="pyop2.base.Dat"><tt class="xref py py-class docutils literal"><span class="pre">Dat</span></tt></a> as dirty, and is
a read only view, see <a class="reference internal" href="#pyop2.base.Dat.data_ro" title="pyop2.base.Dat.data_ro"><tt class="xref py py-meth docutils literal"><span class="pre">data_ro()</span></tt></a> for more details on the
semantics.</p>
<p>With this accessor, you get to see up to date halo values, but
you should not try and modify them, because they will be
overwritten by the next halo exchange.</p>
<p>This function is logically collective over MPI ranks, it is an
error to call it on fewer than all the ranks in MPI communicator.</p>
</dd></dl>

<dl class="method">
<dt id="pyop2.base.Dat.save">
<tt class="descname">save</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#pyop2.base.Dat.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Write the data array to file <tt class="docutils literal"><span class="pre">filename</span></tt> in NumPy format.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.Dat.shape">
<tt class="descname">shape</tt><a class="headerlink" href="#pyop2.base.Dat.shape" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyop2.base.Dat.dtype">
<tt class="descname">dtype</tt><a class="headerlink" href="#pyop2.base.Dat.dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyop2.base.Dat.nbytes">
<tt class="descname">nbytes</tt><a class="headerlink" href="#pyop2.base.Dat.nbytes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an estimate of the size of the data associated with this
<a class="reference internal" href="#pyop2.base.Dat" title="pyop2.base.Dat"><tt class="xref py py-class docutils literal"><span class="pre">Dat</span></tt></a> in bytes. This will be the correct size of the data
payload, but does not take into account the (presumably small)
overhead of the object and its metadata.</p>
<p>Note that this is the process local memory usage, not the sum
over all MPI processes.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.Dat.needs_halo_update">
<tt class="descname">needs_halo_update</tt><a class="headerlink" href="#pyop2.base.Dat.needs_halo_update" title="Permalink to this definition">¶</a></dt>
<dd><p>Has this <a class="reference internal" href="#pyop2.base.Dat" title="pyop2.base.Dat"><tt class="xref py py-class docutils literal"><span class="pre">Dat</span></tt></a> been written to since the last halo exchange?</p>
</dd></dl>

<dl class="method">
<dt id="pyop2.base.Dat.zero">
<tt class="descname">zero</tt><big>(</big><big>)</big><a class="headerlink" href="#pyop2.base.Dat.zero" title="Permalink to this definition">¶</a></dt>
<dd><p>Zero the data associated with this <a class="reference internal" href="#pyop2.base.Dat" title="pyop2.base.Dat"><tt class="xref py py-class docutils literal"><span class="pre">Dat</span></tt></a></p>
<p>This function is logically collective over MPI ranks, it is an
error to call it on fewer than all the ranks in MPI communicator.</p>
</dd></dl>

<dl class="method">
<dt id="pyop2.base.Dat.copy">
<tt class="descname">copy</tt><big>(</big><em>other</em><big>)</big><a class="headerlink" href="#pyop2.base.Dat.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy the data in this <a class="reference internal" href="#pyop2.base.Dat" title="pyop2.base.Dat"><tt class="xref py py-class docutils literal"><span class="pre">Dat</span></tt></a> into another.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>other</strong> &#8211; The destination <a class="reference internal" href="#pyop2.base.Dat" title="pyop2.base.Dat"><tt class="xref py py-class docutils literal"><span class="pre">Dat</span></tt></a></td>
</tr>
</tbody>
</table>
<p>This function is logically collective over MPI ranks, it is an
error to call it on fewer than all the ranks in MPI communicator.</p>
</dd></dl>

<dl class="method">
<dt id="pyop2.base.Dat.halo_exchange_begin">
<tt class="descname">halo_exchange_begin</tt><big>(</big><big>)</big><a class="headerlink" href="#pyop2.base.Dat.halo_exchange_begin" title="Permalink to this definition">¶</a></dt>
<dd><p>Begin halo exchange.</p>
<p>This function is logically collective over MPI ranks, it is an
error to call it on fewer than all the ranks in MPI communicator.</p>
</dd></dl>

<dl class="method">
<dt id="pyop2.base.Dat.halo_exchange_end">
<tt class="descname">halo_exchange_end</tt><big>(</big><big>)</big><a class="headerlink" href="#pyop2.base.Dat.halo_exchange_end" title="Permalink to this definition">¶</a></dt>
<dd><p>End halo exchange. Waits on MPI recv.</p>
<p>This function is logically collective over MPI ranks, it is an
error to call it on fewer than all the ranks in MPI communicator.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.Dat.norm">
<tt class="descname">norm</tt><a class="headerlink" href="#pyop2.base.Dat.norm" title="Permalink to this definition">¶</a></dt>
<dd><p>The L2-norm on the flattened vector.</p>
</dd></dl>

<dl class="classmethod">
<dt id="pyop2.base.Dat.fromhdf5">
<em class="property">classmethod </em><tt class="descname">fromhdf5</tt><big>(</big><em>dataset</em>, <em>f</em>, <em>name</em><big>)</big><a class="headerlink" href="#pyop2.base.Dat.fromhdf5" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a <a class="reference internal" href="#pyop2.base.Dat" title="pyop2.base.Dat"><tt class="xref py py-class docutils literal"><span class="pre">Dat</span></tt></a> from a Dat named <tt class="docutils literal"><span class="pre">name</span></tt> in HDF5 data <tt class="docutils literal"><span class="pre">f</span></tt></p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyop2.base.MixedDat">
<em class="property">class </em><tt class="descclassname">pyop2.base.</tt><tt class="descname">MixedDat</tt><big>(</big><em>mdset_or_dats</em><big>)</big><a class="headerlink" href="#pyop2.base.MixedDat" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyop2.base.Dat" title="pyop2.base.Dat"><tt class="xref py py-class docutils literal"><span class="pre">pyop2.base.Dat</span></tt></a></p>
<p>A container for a bag of <a class="reference internal" href="#pyop2.base.Dat" title="pyop2.base.Dat"><tt class="xref py py-class docutils literal"><span class="pre">Dat</span></tt></a>s.</p>
<p>Initialized either from a <a class="reference internal" href="#pyop2.base.MixedDataSet" title="pyop2.base.MixedDataSet"><tt class="xref py py-class docutils literal"><span class="pre">MixedDataSet</span></tt></a>, a <a class="reference internal" href="#pyop2.base.MixedSet" title="pyop2.base.MixedSet"><tt class="xref py py-class docutils literal"><span class="pre">MixedSet</span></tt></a>, or
an iterable of <a class="reference internal" href="#pyop2.base.DataSet" title="pyop2.base.DataSet"><tt class="xref py py-class docutils literal"><span class="pre">DataSet</span></tt></a>s and/or <a class="reference internal" href="#pyop2.base.Set" title="pyop2.base.Set"><tt class="xref py py-class docutils literal"><span class="pre">Set</span></tt></a>s, where all the
<a class="reference internal" href="#pyop2.base.Set" title="pyop2.base.Set"><tt class="xref py py-class docutils literal"><span class="pre">Set</span></tt></a>s are implcitly upcast to <a class="reference internal" href="#pyop2.base.DataSet" title="pyop2.base.DataSet"><tt class="xref py py-class docutils literal"><span class="pre">DataSet</span></tt></a>s</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">mdat</span> <span class="o">=</span> <span class="n">op2</span><span class="o">.</span><span class="n">MixedDat</span><span class="p">(</span><span class="n">mdset</span><span class="p">)</span>
<span class="n">mdat</span> <span class="o">=</span> <span class="n">op2</span><span class="o">.</span><span class="n">MixedDat</span><span class="p">([</span><span class="n">dset1</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">dsetN</span><span class="p">])</span>
</pre></div>
</div>
<p>or from an iterable of <a class="reference internal" href="#pyop2.base.Dat" title="pyop2.base.Dat"><tt class="xref py py-class docutils literal"><span class="pre">Dat</span></tt></a>s</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">mdat</span> <span class="o">=</span> <span class="n">op2</span><span class="o">.</span><span class="n">MixedDat</span><span class="p">([</span><span class="n">dat1</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">datN</span><span class="p">])</span>
</pre></div>
</div>
<dl class="attribute">
<dt id="pyop2.base.MixedDat.dtype">
<tt class="descname">dtype</tt><a class="headerlink" href="#pyop2.base.MixedDat.dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>The NumPy dtype of the data.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.MixedDat.split">
<tt class="descname">split</tt><a class="headerlink" href="#pyop2.base.MixedDat.split" title="Permalink to this definition">¶</a></dt>
<dd><p>The underlying tuple of <a class="reference internal" href="#pyop2.base.Dat" title="pyop2.base.Dat"><tt class="xref py py-class docutils literal"><span class="pre">Dat</span></tt></a>s.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.MixedDat.dataset">
<tt class="descname">dataset</tt><a class="headerlink" href="#pyop2.base.MixedDat.dataset" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#pyop2.base.MixedDataSet" title="pyop2.base.MixedDataSet"><tt class="xref py py-class docutils literal"><span class="pre">MixedDataSet</span></tt></a>s this <a class="reference internal" href="#pyop2.base.MixedDat" title="pyop2.base.MixedDat"><tt class="xref py py-class docutils literal"><span class="pre">MixedDat</span></tt></a> is defined on.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.MixedDat.soa">
<tt class="descname">soa</tt><a class="headerlink" href="#pyop2.base.MixedDat.soa" title="Permalink to this definition">¶</a></dt>
<dd><p>Are the data in SoA format?</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.MixedDat.data">
<tt class="descname">data</tt><a class="headerlink" href="#pyop2.base.MixedDat.data" title="Permalink to this definition">¶</a></dt>
<dd><p>Numpy arrays containing the data excluding halos.</p>
<p>This function is logically collective over MPI ranks, it is an
error to call it on fewer than all the ranks in MPI communicator.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.MixedDat.data_with_halos">
<tt class="descname">data_with_halos</tt><a class="headerlink" href="#pyop2.base.MixedDat.data_with_halos" title="Permalink to this definition">¶</a></dt>
<dd><p>Numpy arrays containing the data including halos.</p>
<p>This function is logically collective over MPI ranks, it is an
error to call it on fewer than all the ranks in MPI communicator.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.MixedDat.data_ro">
<tt class="descname">data_ro</tt><a class="headerlink" href="#pyop2.base.MixedDat.data_ro" title="Permalink to this definition">¶</a></dt>
<dd><p>Numpy arrays with read-only data excluding halos.</p>
<p>This function is logically collective over MPI ranks, it is an
error to call it on fewer than all the ranks in MPI communicator.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.MixedDat.data_ro_with_halos">
<tt class="descname">data_ro_with_halos</tt><a class="headerlink" href="#pyop2.base.MixedDat.data_ro_with_halos" title="Permalink to this definition">¶</a></dt>
<dd><p>Numpy arrays with read-only data including halos.</p>
<p>This function is logically collective over MPI ranks, it is an
error to call it on fewer than all the ranks in MPI communicator.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.MixedDat.needs_halo_update">
<tt class="descname">needs_halo_update</tt><a class="headerlink" href="#pyop2.base.MixedDat.needs_halo_update" title="Permalink to this definition">¶</a></dt>
<dd><p>Has this Dat been written to since the last halo exchange?</p>
</dd></dl>

<dl class="method">
<dt id="pyop2.base.MixedDat.halo_exchange_begin">
<tt class="descname">halo_exchange_begin</tt><big>(</big><big>)</big><a class="headerlink" href="#pyop2.base.MixedDat.halo_exchange_begin" title="Permalink to this definition">¶</a></dt>
<dd><p>This function is logically collective over MPI ranks, it is an
error to call it on fewer than all the ranks in MPI communicator.</p>
</dd></dl>

<dl class="method">
<dt id="pyop2.base.MixedDat.halo_exchange_end">
<tt class="descname">halo_exchange_end</tt><big>(</big><big>)</big><a class="headerlink" href="#pyop2.base.MixedDat.halo_exchange_end" title="Permalink to this definition">¶</a></dt>
<dd><p>This function is logically collective over MPI ranks, it is an
error to call it on fewer than all the ranks in MPI communicator.</p>
</dd></dl>

<dl class="method">
<dt id="pyop2.base.MixedDat.zero">
<tt class="descname">zero</tt><big>(</big><big>)</big><a class="headerlink" href="#pyop2.base.MixedDat.zero" title="Permalink to this definition">¶</a></dt>
<dd><p>Zero the data associated with this <a class="reference internal" href="#pyop2.base.MixedDat" title="pyop2.base.MixedDat"><tt class="xref py py-class docutils literal"><span class="pre">MixedDat</span></tt></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.MixedDat.nbytes">
<tt class="descname">nbytes</tt><a class="headerlink" href="#pyop2.base.MixedDat.nbytes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an estimate of the size of the data associated with this
<a class="reference internal" href="#pyop2.base.Dat" title="pyop2.base.Dat"><tt class="xref py py-class docutils literal"><span class="pre">Dat</span></tt></a> in bytes. This will be the correct size of the data
payload, but does not take into account the (presumably small)
overhead of the object and its metadata.</p>
<p>Note that this is the process local memory usage, not the sum
over all MPI processes.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyop2.base.Const">
<em class="property">class </em><tt class="descclassname">pyop2.base.</tt><tt class="descname">Const</tt><big>(</big><em>dim</em>, <em>data=None</em>, <em>name=None</em>, <em>dtype=None</em><big>)</big><a class="headerlink" href="#pyop2.base.Const" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyop2.base.DataCarrier" title="pyop2.base.DataCarrier"><tt class="xref py py-class docutils literal"><span class="pre">pyop2.base.DataCarrier</span></tt></a></p>
<p>Data that is constant for any element of any set.</p>
<dl class="class">
<dt id="pyop2.base.Const.Snapshot">
<em class="property">class </em><tt class="descname">Snapshot</tt><big>(</big><em>obj</em><big>)</big><a class="headerlink" href="#pyop2.base.Const.Snapshot" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Overridden from DataCarrier; a snapshot is always valid as long as
the Const object still exists</p>
<dl class="method">
<dt id="pyop2.base.Const.Snapshot.is_valid">
<tt class="descname">is_valid</tt><big>(</big><big>)</big><a class="headerlink" href="#pyop2.base.Const.Snapshot.is_valid" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="pyop2.base.Const.NonUniqueNameError">
<em class="property">exception </em><tt class="descclassname">Const.</tt><tt class="descname">NonUniqueNameError</tt><a class="headerlink" href="#pyop2.base.Const.NonUniqueNameError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">exceptions.ValueError</span></tt></p>
<p>The Names of const variables are required to be globally unique.
This exception is raised if the name is already in use.</p>
</dd></dl>

<dl class="method">
<dt id="pyop2.base.Const.duplicate">
<tt class="descclassname">Const.</tt><tt class="descname">duplicate</tt><big>(</big><big>)</big><a class="headerlink" href="#pyop2.base.Const.duplicate" title="Permalink to this definition">¶</a></dt>
<dd><p>A Const duplicate can always refer to the same data vector, since
it&#8217;s read-only</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.Const.data">
<tt class="descclassname">Const.</tt><tt class="descname">data</tt><a class="headerlink" href="#pyop2.base.Const.data" title="Permalink to this definition">¶</a></dt>
<dd><p>Data array.</p>
</dd></dl>

<dl class="method">
<dt id="pyop2.base.Const.remove_from_namespace">
<tt class="descclassname">Const.</tt><tt class="descname">remove_from_namespace</tt><big>(</big><big>)</big><a class="headerlink" href="#pyop2.base.Const.remove_from_namespace" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove this Const object from the namespace</p>
<p>This allows the same name to be redeclared with a different shape.</p>
</dd></dl>

<dl class="classmethod">
<dt id="pyop2.base.Const.fromhdf5">
<em class="property">classmethod </em><tt class="descclassname">Const.</tt><tt class="descname">fromhdf5</tt><big>(</big><em>f</em>, <em>name</em><big>)</big><a class="headerlink" href="#pyop2.base.Const.fromhdf5" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a <a class="reference internal" href="#pyop2.base.Const" title="pyop2.base.Const"><tt class="xref py py-class docutils literal"><span class="pre">Const</span></tt></a> from const named <tt class="docutils literal"><span class="pre">name</span></tt> in HDF5 data <tt class="docutils literal"><span class="pre">f</span></tt></p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyop2.base.Global">
<em class="property">class </em><tt class="descclassname">pyop2.base.</tt><tt class="descname">Global</tt><big>(</big><em>dim</em>, <em>data=None</em>, <em>dtype=None</em>, <em>name=None</em><big>)</big><a class="headerlink" href="#pyop2.base.Global" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyop2.base.DataCarrier" title="pyop2.base.DataCarrier"><tt class="xref py py-class docutils literal"><span class="pre">pyop2.base.DataCarrier</span></tt></a>, <tt class="xref py py-class docutils literal"><span class="pre">pyop2.base._EmptyDataMixin</span></tt></p>
<p>OP2 global value.</p>
<p>When a <tt class="docutils literal"><span class="pre">Global</span></tt> is passed to a <a class="reference internal" href="#pyop2.op2.par_loop" title="pyop2.op2.par_loop"><tt class="xref py py-func docutils literal"><span class="pre">pyop2.op2.par_loop()</span></tt></a>, the access
descriptor is passed by <cite>calling</cite> the <tt class="docutils literal"><span class="pre">Global</span></tt>.  For example, if
a <tt class="docutils literal"><span class="pre">Global</span></tt> named <tt class="docutils literal"><span class="pre">G</span></tt> is to be accessed for reading, this is
accomplished by:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">G</span><span class="p">(</span><span class="n">pyop2</span><span class="o">.</span><span class="n">READ</span><span class="p">)</span>
</pre></div>
</div>
<p>It is permissible to pass <cite>None</cite> as the <cite>data</cite> argument.  In this
case, allocation of the data buffer is postponed until it is
accessed.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If the data buffer is not passed in, it is implicitly
initialised to be zero.</p>
</div>
<dl class="attribute">
<dt id="pyop2.base.Global.shape">
<tt class="descname">shape</tt><a class="headerlink" href="#pyop2.base.Global.shape" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyop2.base.Global.dtype">
<tt class="descname">dtype</tt><a class="headerlink" href="#pyop2.base.Global.dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyop2.base.Global.data_ro">
<tt class="descname">data_ro</tt><a class="headerlink" href="#pyop2.base.Global.data_ro" title="Permalink to this definition">¶</a></dt>
<dd><p>Data array.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.Global.data">
<tt class="descname">data</tt><a class="headerlink" href="#pyop2.base.Global.data" title="Permalink to this definition">¶</a></dt>
<dd><p>Data array.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.Global.nbytes">
<tt class="descname">nbytes</tt><a class="headerlink" href="#pyop2.base.Global.nbytes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an estimate of the size of the data associated with this
<a class="reference internal" href="#pyop2.base.Global" title="pyop2.base.Global"><tt class="xref py py-class docutils literal"><span class="pre">Global</span></tt></a> in bytes. This will be the correct size of the
data payload, but does not take into account the overhead of
the object and its metadata. This renders this method of
little statistical significance, however it is included to
make the interface consistent.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.Global.soa">
<tt class="descname">soa</tt><a class="headerlink" href="#pyop2.base.Global.soa" title="Permalink to this definition">¶</a></dt>
<dd><p>Are the data in SoA format? This is always false for <a class="reference internal" href="#pyop2.base.Global" title="pyop2.base.Global"><tt class="xref py py-class docutils literal"><span class="pre">Global</span></tt></a>
objects.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyop2.base.IterationIndex">
<em class="property">class </em><tt class="descclassname">pyop2.base.</tt><tt class="descname">IterationIndex</tt><big>(</big><em>index=None</em><big>)</big><a class="headerlink" href="#pyop2.base.IterationIndex" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>OP2 iteration space index</p>
<p>Users should not directly instantiate <a class="reference internal" href="#pyop2.base.IterationIndex" title="pyop2.base.IterationIndex"><tt class="xref py py-class docutils literal"><span class="pre">IterationIndex</span></tt></a> objects. Use
<tt class="docutils literal"><span class="pre">op2.i</span></tt> instead.</p>
<dl class="attribute">
<dt id="pyop2.base.IterationIndex.index">
<tt class="descname">index</tt><a class="headerlink" href="#pyop2.base.IterationIndex.index" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the integer value of this index.</p>
</dd></dl>

</dd></dl>

<dl class="data">
<dt id="pyop2.base.i">
<tt class="descclassname">pyop2.base.</tt><tt class="descname">i</tt><em class="property"> = IterationIndex(None)</em><a class="headerlink" href="#pyop2.base.i" title="Permalink to this definition">¶</a></dt>
<dd><p>Shorthand for constructing <a class="reference internal" href="#pyop2.base.IterationIndex" title="pyop2.base.IterationIndex"><tt class="xref py py-class docutils literal"><span class="pre">IterationIndex</span></tt></a> objects.</p>
<p><tt class="docutils literal"><span class="pre">i[idx]</span></tt> builds an <a class="reference internal" href="#pyop2.base.IterationIndex" title="pyop2.base.IterationIndex"><tt class="xref py py-class docutils literal"><span class="pre">IterationIndex</span></tt></a> object for which the <cite>index</cite>
property is <cite>idx</cite>.</p>
</dd></dl>

<dl class="class">
<dt id="pyop2.base.Map">
<em class="property">class </em><tt class="descclassname">pyop2.base.</tt><tt class="descname">Map</tt><big>(</big><em>iterset</em>, <em>toset</em>, <em>arity</em>, <em>values=None</em>, <em>name=None</em>, <em>offset=None</em>, <em>parent=None</em>, <em>bt_masks=None</em><big>)</big><a class="headerlink" href="#pyop2.base.Map" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>OP2 map, a relation between two <a class="reference internal" href="#pyop2.base.Set" title="pyop2.base.Set"><tt class="xref py py-class docutils literal"><span class="pre">Set</span></tt></a> objects.</p>
<p>Each entry in the <tt class="docutils literal"><span class="pre">iterset</span></tt> maps to <tt class="docutils literal"><span class="pre">arity</span></tt> entries in the
<tt class="docutils literal"><span class="pre">toset</span></tt>. When a map is used in a <a class="reference internal" href="#pyop2.op2.par_loop" title="pyop2.op2.par_loop"><tt class="xref py py-func docutils literal"><span class="pre">pyop2.op2.par_loop()</span></tt></a>, it is
possible to use Python index notation to select an individual entry on the
right hand side of this map. There are three possibilities:</p>
<ul class="simple">
<li>No index. All <tt class="docutils literal"><span class="pre">arity</span></tt> <a class="reference internal" href="#pyop2.base.Dat" title="pyop2.base.Dat"><tt class="xref py py-class docutils literal"><span class="pre">Dat</span></tt></a> entries will be passed to the
kernel.</li>
<li>An integer: <tt class="docutils literal"><span class="pre">some_map[n]</span></tt>. The <tt class="docutils literal"><span class="pre">n</span></tt> th entry of the
map result will be passed to the kernel.</li>
<li>An <a class="reference internal" href="#pyop2.base.IterationIndex" title="pyop2.base.IterationIndex"><tt class="xref py py-class docutils literal"><span class="pre">IterationIndex</span></tt></a>, <tt class="docutils literal"><span class="pre">some_map[pyop2.i[n]]</span></tt>. <tt class="docutils literal"><span class="pre">n</span></tt>
will take each value from <tt class="docutils literal"><span class="pre">0</span></tt> to <tt class="docutils literal"><span class="pre">e-1</span></tt> where <tt class="docutils literal"><span class="pre">e</span></tt> is the
<tt class="docutils literal"><span class="pre">n</span></tt> th extent passed to the iteration space for this
<a class="reference internal" href="#pyop2.op2.par_loop" title="pyop2.op2.par_loop"><tt class="xref py py-func docutils literal"><span class="pre">pyop2.op2.par_loop()</span></tt></a>. See also <a class="reference internal" href="#pyop2.base.i" title="pyop2.base.i"><tt class="xref py py-data docutils literal"><span class="pre">i</span></tt></a>.</li>
</ul>
<p>For extruded problems (where <tt class="docutils literal"><span class="pre">iterset</span></tt> is an
<a class="reference internal" href="#pyop2.base.ExtrudedSet" title="pyop2.base.ExtrudedSet"><tt class="xref py py-class docutils literal"><span class="pre">ExtrudedSet</span></tt></a>) with boundary conditions applied at the top
and bottom of the domain, one needs to provide a list of which of
the <cite>arity</cite> values in each map entry correspond to values on the
bottom boundary and which correspond to the top.  This is done by
supplying two lists of indices in <cite>bt_masks</cite>, the first provides
indices for the bottom, the second for the top.</p>
<dl class="attribute">
<dt id="pyop2.base.Map.split">
<tt class="descname">split</tt><a class="headerlink" href="#pyop2.base.Map.split" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyop2.base.Map.iterset">
<tt class="descname">iterset</tt><a class="headerlink" href="#pyop2.base.Map.iterset" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#pyop2.base.Set" title="pyop2.base.Set"><tt class="xref py py-class docutils literal"><span class="pre">Set</span></tt></a> mapped from.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.Map.toset">
<tt class="descname">toset</tt><a class="headerlink" href="#pyop2.base.Map.toset" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#pyop2.base.Set" title="pyop2.base.Set"><tt class="xref py py-class docutils literal"><span class="pre">Set</span></tt></a> mapped to.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.Map.arity">
<tt class="descname">arity</tt><a class="headerlink" href="#pyop2.base.Map.arity" title="Permalink to this definition">¶</a></dt>
<dd><p>Arity of the mapping: number of toset elements mapped to per
iterset element.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.Map.arities">
<tt class="descname">arities</tt><a class="headerlink" href="#pyop2.base.Map.arities" title="Permalink to this definition">¶</a></dt>
<dd><p>Arity of the mapping: number of toset elements mapped to per
iterset element.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">tuple</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.Map.arange">
<tt class="descname">arange</tt><a class="headerlink" href="#pyop2.base.Map.arange" title="Permalink to this definition">¶</a></dt>
<dd><p>Tuple of arity offsets for each constituent <a class="reference internal" href="#pyop2.base.Map" title="pyop2.base.Map"><tt class="xref py py-class docutils literal"><span class="pre">Map</span></tt></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.Map.values">
<tt class="descname">values</tt><a class="headerlink" href="#pyop2.base.Map.values" title="Permalink to this definition">¶</a></dt>
<dd><p>Mapping array.</p>
<p>This only returns the map values for local points, to see the
halo points too, use <a class="reference internal" href="#pyop2.base.Map.values_with_halo" title="pyop2.base.Map.values_with_halo"><tt class="xref py py-meth docutils literal"><span class="pre">values_with_halo()</span></tt></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.Map.values_with_halo">
<tt class="descname">values_with_halo</tt><a class="headerlink" href="#pyop2.base.Map.values_with_halo" title="Permalink to this definition">¶</a></dt>
<dd><p>Mapping array.</p>
<p>This returns all map values (including halo points), see
<a class="reference internal" href="#pyop2.base.Map.values" title="pyop2.base.Map.values"><tt class="xref py py-meth docutils literal"><span class="pre">values()</span></tt></a> if you only need to look at the local
points.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.Map.name">
<tt class="descname">name</tt><a class="headerlink" href="#pyop2.base.Map.name" title="Permalink to this definition">¶</a></dt>
<dd><p>User-defined label</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.Map.offset">
<tt class="descname">offset</tt><a class="headerlink" href="#pyop2.base.Map.offset" title="Permalink to this definition">¶</a></dt>
<dd><p>The vertical offset.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.Map.top_mask">
<tt class="descname">top_mask</tt><a class="headerlink" href="#pyop2.base.Map.top_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>The top layer mask to be applied on a mesh cell.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.Map.bottom_mask">
<tt class="descname">bottom_mask</tt><a class="headerlink" href="#pyop2.base.Map.bottom_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>The bottom layer mask to be applied on a mesh cell.</p>
</dd></dl>

<dl class="classmethod">
<dt id="pyop2.base.Map.fromhdf5">
<em class="property">classmethod </em><tt class="descname">fromhdf5</tt><big>(</big><em>iterset</em>, <em>toset</em>, <em>f</em>, <em>name</em><big>)</big><a class="headerlink" href="#pyop2.base.Map.fromhdf5" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a <a class="reference internal" href="#pyop2.base.Map" title="pyop2.base.Map"><tt class="xref py py-class docutils literal"><span class="pre">Map</span></tt></a> from set named <tt class="docutils literal"><span class="pre">name</span></tt> in HDF5 data <tt class="docutils literal"><span class="pre">f</span></tt></p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyop2.base.MixedMap">
<em class="property">class </em><tt class="descclassname">pyop2.base.</tt><tt class="descname">MixedMap</tt><big>(</big><em>maps</em><big>)</big><a class="headerlink" href="#pyop2.base.MixedMap" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyop2.base.Map" title="pyop2.base.Map"><tt class="xref py py-class docutils literal"><span class="pre">pyop2.base.Map</span></tt></a></p>
<p>A container for a bag of <a class="reference internal" href="#pyop2.base.Map" title="pyop2.base.Map"><tt class="xref py py-class docutils literal"><span class="pre">Map</span></tt></a>s.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>maps</strong> (<em>iterable</em>) &#8211; Iterable of <a class="reference internal" href="#pyop2.base.Map" title="pyop2.base.Map"><tt class="xref py py-class docutils literal"><span class="pre">Map</span></tt></a>s</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="pyop2.base.MixedMap.split">
<tt class="descname">split</tt><a class="headerlink" href="#pyop2.base.MixedMap.split" title="Permalink to this definition">¶</a></dt>
<dd><p>The underlying tuple of <a class="reference internal" href="#pyop2.base.Map" title="pyop2.base.Map"><tt class="xref py py-class docutils literal"><span class="pre">Map</span></tt></a>s.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.MixedMap.iterset">
<tt class="descname">iterset</tt><a class="headerlink" href="#pyop2.base.MixedMap.iterset" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#pyop2.base.MixedSet" title="pyop2.base.MixedSet"><tt class="xref py py-class docutils literal"><span class="pre">MixedSet</span></tt></a> mapped from.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.MixedMap.toset">
<tt class="descname">toset</tt><a class="headerlink" href="#pyop2.base.MixedMap.toset" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#pyop2.base.MixedSet" title="pyop2.base.MixedSet"><tt class="xref py py-class docutils literal"><span class="pre">MixedSet</span></tt></a> mapped to.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.MixedMap.arity">
<tt class="descname">arity</tt><a class="headerlink" href="#pyop2.base.MixedMap.arity" title="Permalink to this definition">¶</a></dt>
<dd><p>Arity of the mapping: total number of toset elements mapped to per
iterset element.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.MixedMap.arities">
<tt class="descname">arities</tt><a class="headerlink" href="#pyop2.base.MixedMap.arities" title="Permalink to this definition">¶</a></dt>
<dd><p>Arity of the mapping: number of toset elements mapped to per
iterset element.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">tuple</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.MixedMap.arange">
<tt class="descname">arange</tt><a class="headerlink" href="#pyop2.base.MixedMap.arange" title="Permalink to this definition">¶</a></dt>
<dd><p>Tuple of arity offsets for each constituent <a class="reference internal" href="#pyop2.base.Map" title="pyop2.base.Map"><tt class="xref py py-class docutils literal"><span class="pre">Map</span></tt></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.MixedMap.values">
<tt class="descname">values</tt><a class="headerlink" href="#pyop2.base.MixedMap.values" title="Permalink to this definition">¶</a></dt>
<dd><p>Mapping arrays excluding data for halos.</p>
<p>This only returns the map values for local points, to see the
halo points too, use <a class="reference internal" href="#pyop2.base.MixedMap.values_with_halo" title="pyop2.base.MixedMap.values_with_halo"><tt class="xref py py-meth docutils literal"><span class="pre">values_with_halo()</span></tt></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.MixedMap.values_with_halo">
<tt class="descname">values_with_halo</tt><a class="headerlink" href="#pyop2.base.MixedMap.values_with_halo" title="Permalink to this definition">¶</a></dt>
<dd><p>Mapping arrays including data for halos.</p>
<p>This returns all map values (including halo points), see
<a class="reference internal" href="#pyop2.base.MixedMap.values" title="pyop2.base.MixedMap.values"><tt class="xref py py-meth docutils literal"><span class="pre">values()</span></tt></a> if you only need to look at the local
points.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.MixedMap.name">
<tt class="descname">name</tt><a class="headerlink" href="#pyop2.base.MixedMap.name" title="Permalink to this definition">¶</a></dt>
<dd><p>User-defined labels</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.MixedMap.offset">
<tt class="descname">offset</tt><a class="headerlink" href="#pyop2.base.MixedMap.offset" title="Permalink to this definition">¶</a></dt>
<dd><p>Vertical offsets.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyop2.base.Sparsity">
<em class="property">class </em><tt class="descclassname">pyop2.base.</tt><tt class="descname">Sparsity</tt><big>(</big><em>dsets</em>, <em>maps</em>, <em>name=None</em><big>)</big><a class="headerlink" href="#pyop2.base.Sparsity" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyop2.caching.Cached" title="pyop2.caching.Cached"><tt class="xref py py-class docutils literal"><span class="pre">pyop2.caching.Cached</span></tt></a></p>
<p>OP2 Sparsity, the non-zero structure a matrix derived from the union of
the outer product of pairs of <a class="reference internal" href="#pyop2.base.Map" title="pyop2.base.Map"><tt class="xref py py-class docutils literal"><span class="pre">Map</span></tt></a> objects.</p>
<p>Examples of constructing a Sparsity:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Sparsity</span><span class="p">(</span><span class="n">single_dset</span><span class="p">,</span> <span class="n">single_map</span><span class="p">,</span> <span class="s">&#39;mass&#39;</span><span class="p">)</span>
<span class="n">Sparsity</span><span class="p">((</span><span class="n">row_dset</span><span class="p">,</span> <span class="n">col_dset</span><span class="p">),</span> <span class="p">(</span><span class="n">single_rowmap</span><span class="p">,</span> <span class="n">single_colmap</span><span class="p">))</span>
<span class="n">Sparsity</span><span class="p">((</span><span class="n">row_dset</span><span class="p">,</span> <span class="n">col_dset</span><span class="p">),</span>
         <span class="p">[(</span><span class="n">first_rowmap</span><span class="p">,</span> <span class="n">first_colmap</span><span class="p">),</span> <span class="p">(</span><span class="n">second_rowmap</span><span class="p">,</span> <span class="n">second_colmap</span><span class="p">)])</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>dsets</strong> &#8211; <a class="reference internal" href="#pyop2.base.DataSet" title="pyop2.base.DataSet"><tt class="xref py py-class docutils literal"><span class="pre">DataSet</span></tt></a>s for the left and right function
spaces this <a class="reference internal" href="#pyop2.base.Sparsity" title="pyop2.base.Sparsity"><tt class="xref py py-class docutils literal"><span class="pre">Sparsity</span></tt></a> maps between</li>
<li><strong>maps</strong> (a pair of <a class="reference internal" href="#pyop2.base.Map" title="pyop2.base.Map"><tt class="xref py py-class docutils literal"><span class="pre">Map</span></tt></a>s specifying a row map and a column
map, or an iterable of pairs of <a class="reference internal" href="#pyop2.base.Map" title="pyop2.base.Map"><tt class="xref py py-class docutils literal"><span class="pre">Map</span></tt></a>s specifying multiple
row and column maps - if a single <a class="reference internal" href="#pyop2.base.Map" title="pyop2.base.Map"><tt class="xref py py-class docutils literal"><span class="pre">Map</span></tt></a> is passed, it is
used as both a row map and a column map) &#8211; <a class="reference internal" href="#pyop2.base.Map" title="pyop2.base.Map"><tt class="xref py py-class docutils literal"><span class="pre">Map</span></tt></a>s to build the <a class="reference internal" href="#pyop2.base.Sparsity" title="pyop2.base.Sparsity"><tt class="xref py py-class docutils literal"><span class="pre">Sparsity</span></tt></a> from</li>
<li><strong>name</strong> (<em>string</em>) &#8211; user-defined label (optional)</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="pyop2.base.Sparsity.dsets">
<tt class="descname">dsets</tt><a class="headerlink" href="#pyop2.base.Sparsity.dsets" title="Permalink to this definition">¶</a></dt>
<dd><p>A pair of <a class="reference internal" href="#pyop2.base.DataSet" title="pyop2.base.DataSet"><tt class="xref py py-class docutils literal"><span class="pre">DataSet</span></tt></a>s for the left and right function
spaces this <a class="reference internal" href="#pyop2.base.Sparsity" title="pyop2.base.Sparsity"><tt class="xref py py-class docutils literal"><span class="pre">Sparsity</span></tt></a> maps between.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.Sparsity.maps">
<tt class="descname">maps</tt><a class="headerlink" href="#pyop2.base.Sparsity.maps" title="Permalink to this definition">¶</a></dt>
<dd><p>A list of pairs (rmap, cmap) where each pair of
<a class="reference internal" href="#pyop2.base.Map" title="pyop2.base.Map"><tt class="xref py py-class docutils literal"><span class="pre">Map</span></tt></a> objects will later be used to assemble into this
matrix. The iterset of each of the maps in a pair must be the
same, while the toset of all the maps which appear first
must be common, this will form the row <a class="reference internal" href="#pyop2.base.Set" title="pyop2.base.Set"><tt class="xref py py-class docutils literal"><span class="pre">Set</span></tt></a> of the
sparsity. Similarly, the toset of all the maps which appear
second must be common and will form the column <a class="reference internal" href="#pyop2.base.Set" title="pyop2.base.Set"><tt class="xref py py-class docutils literal"><span class="pre">Set</span></tt></a> of
the <tt class="docutils literal"><span class="pre">Sparsity</span></tt>.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.Sparsity.cmaps">
<tt class="descname">cmaps</tt><a class="headerlink" href="#pyop2.base.Sparsity.cmaps" title="Permalink to this definition">¶</a></dt>
<dd><p>The list of column maps this sparsity is assembled from.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.Sparsity.rmaps">
<tt class="descname">rmaps</tt><a class="headerlink" href="#pyop2.base.Sparsity.rmaps" title="Permalink to this definition">¶</a></dt>
<dd><p>The list of row maps this sparsity is assembled from.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.Sparsity.dims">
<tt class="descname">dims</tt><a class="headerlink" href="#pyop2.base.Sparsity.dims" title="Permalink to this definition">¶</a></dt>
<dd><p>A pair giving the number of rows per entry of the row
<a class="reference internal" href="#pyop2.base.Set" title="pyop2.base.Set"><tt class="xref py py-class docutils literal"><span class="pre">Set</span></tt></a> and the number of columns per entry of the column
<a class="reference internal" href="#pyop2.base.Set" title="pyop2.base.Set"><tt class="xref py py-class docutils literal"><span class="pre">Set</span></tt></a> of the <tt class="docutils literal"><span class="pre">Sparsity</span></tt>.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.Sparsity.shape">
<tt class="descname">shape</tt><a class="headerlink" href="#pyop2.base.Sparsity.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of block rows and columns.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.Sparsity.nrows">
<tt class="descname">nrows</tt><a class="headerlink" href="#pyop2.base.Sparsity.nrows" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of rows in the <tt class="docutils literal"><span class="pre">Sparsity</span></tt>.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.Sparsity.ncols">
<tt class="descname">ncols</tt><a class="headerlink" href="#pyop2.base.Sparsity.ncols" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of columns in the <tt class="docutils literal"><span class="pre">Sparsity</span></tt>.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.Sparsity.name">
<tt class="descname">name</tt><a class="headerlink" href="#pyop2.base.Sparsity.name" title="Permalink to this definition">¶</a></dt>
<dd><p>A user-defined label.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.Sparsity.rowptr">
<tt class="descname">rowptr</tt><a class="headerlink" href="#pyop2.base.Sparsity.rowptr" title="Permalink to this definition">¶</a></dt>
<dd><p>Row pointer array of CSR data structure.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.Sparsity.colidx">
<tt class="descname">colidx</tt><a class="headerlink" href="#pyop2.base.Sparsity.colidx" title="Permalink to this definition">¶</a></dt>
<dd><p>Column indices array of CSR data structure.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.Sparsity.nnz">
<tt class="descname">nnz</tt><a class="headerlink" href="#pyop2.base.Sparsity.nnz" title="Permalink to this definition">¶</a></dt>
<dd><p>Array containing the number of non-zeroes in the various rows of the
diagonal portion of the local submatrix.</p>
<p>This is the same as the parameter <cite>d_nnz</cite> used for preallocation in
PETSc&#8217;s <a class="reference external" href="http://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/Mat/MatMPIAIJSetPreallocation.html">MatMPIAIJSetPreallocation</a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.Sparsity.onnz">
<tt class="descname">onnz</tt><a class="headerlink" href="#pyop2.base.Sparsity.onnz" title="Permalink to this definition">¶</a></dt>
<dd><p>Array containing the number of non-zeroes in the various rows of the
off-diagonal portion of the local submatrix.</p>
<p>This is the same as the parameter <cite>o_nnz</cite> used for preallocation in
PETSc&#8217;s <a class="reference external" href="http://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/Mat/MatMPIAIJSetPreallocation.html">MatMPIAIJSetPreallocation</a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.Sparsity.nz">
<tt class="descname">nz</tt><a class="headerlink" href="#pyop2.base.Sparsity.nz" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of non-zeroes in the diagonal portion of the local
submatrix.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.Sparsity.onz">
<tt class="descname">onz</tt><a class="headerlink" href="#pyop2.base.Sparsity.onz" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of non-zeroes in the off-diagonal portion of the local
submatrix.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyop2.base.Mat">
<em class="property">class </em><tt class="descclassname">pyop2.base.</tt><tt class="descname">Mat</tt><big>(</big><em>sparsity</em>, <em>dtype=None</em>, <em>name=None</em><big>)</big><a class="headerlink" href="#pyop2.base.Mat" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyop2.base.SetAssociated" title="pyop2.base.SetAssociated"><tt class="xref py py-class docutils literal"><span class="pre">pyop2.base.SetAssociated</span></tt></a></p>
<p>OP2 matrix data. A <tt class="docutils literal"><span class="pre">Mat</span></tt> is defined on a sparsity pattern and holds a value
for each element in the <a class="reference internal" href="#pyop2.base.Sparsity" title="pyop2.base.Sparsity"><tt class="xref py py-class docutils literal"><span class="pre">Sparsity</span></tt></a>.</p>
<p>When a <tt class="docutils literal"><span class="pre">Mat</span></tt> is passed to <a class="reference internal" href="#pyop2.op2.par_loop" title="pyop2.op2.par_loop"><tt class="xref py py-func docutils literal"><span class="pre">pyop2.op2.par_loop()</span></tt></a>, the maps via which
indirection occurs for the row and column space, and the access
descriptor are passed by <cite>calling</cite> the <tt class="docutils literal"><span class="pre">Mat</span></tt>. For instance, if a
<tt class="docutils literal"><span class="pre">Mat</span></tt> named <tt class="docutils literal"><span class="pre">A</span></tt> is to be accessed for reading via a row <a class="reference internal" href="#pyop2.base.Map" title="pyop2.base.Map"><tt class="xref py py-class docutils literal"><span class="pre">Map</span></tt></a>
named <tt class="docutils literal"><span class="pre">R</span></tt> and a column <a class="reference internal" href="#pyop2.base.Map" title="pyop2.base.Map"><tt class="xref py py-class docutils literal"><span class="pre">Map</span></tt></a> named <tt class="docutils literal"><span class="pre">C</span></tt>, this is accomplished by:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">A</span><span class="p">(</span><span class="n">pyop2</span><span class="o">.</span><span class="n">READ</span><span class="p">,</span> <span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="n">pyop2</span><span class="o">.</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">C</span><span class="p">[</span><span class="n">pyop2</span><span class="o">.</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]]))</span>
</pre></div>
</div>
<p>Notice that it is <cite>always</cite> necessary to index the indirection maps
for a <tt class="docutils literal"><span class="pre">Mat</span></tt>. See the <a class="reference internal" href="#pyop2.base.Mat" title="pyop2.base.Mat"><tt class="xref py py-class docutils literal"><span class="pre">Mat</span></tt></a> documentation for more
details.</p>
<dl class="attribute">
<dt id="pyop2.base.Mat.dims">
<tt class="descname">dims</tt><a class="headerlink" href="#pyop2.base.Mat.dims" title="Permalink to this definition">¶</a></dt>
<dd><p>A pair of integers giving the number of matrix rows and columns for
each member of the row <a class="reference internal" href="#pyop2.base.Set" title="pyop2.base.Set"><tt class="xref py py-class docutils literal"><span class="pre">Set</span></tt></a> and column <a class="reference internal" href="#pyop2.base.Set" title="pyop2.base.Set"><tt class="xref py py-class docutils literal"><span class="pre">Set</span></tt></a>
respectively. This corresponds to the <tt class="docutils literal"><span class="pre">cdim</span></tt> member of a
<a class="reference internal" href="#pyop2.base.DataSet" title="pyop2.base.DataSet"><tt class="xref py py-class docutils literal"><span class="pre">DataSet</span></tt></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.Mat.sparsity">
<tt class="descname">sparsity</tt><a class="headerlink" href="#pyop2.base.Mat.sparsity" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#pyop2.base.Sparsity" title="pyop2.base.Sparsity"><tt class="xref py py-class docutils literal"><span class="pre">Sparsity</span></tt></a> on which the <tt class="docutils literal"><span class="pre">Mat</span></tt> is defined.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.Mat.values">
<tt class="descname">values</tt><a class="headerlink" href="#pyop2.base.Mat.values" title="Permalink to this definition">¶</a></dt>
<dd><p>A numpy array of matrix values.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This is a dense array, so will need a lot of memory.  It&#8217;s
probably not a good idea to access this property if your
matrix has more than around 10000 degrees of freedom.</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.Mat.dtype">
<tt class="descname">dtype</tt><a class="headerlink" href="#pyop2.base.Mat.dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>The Python type of the data.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.Mat.nbytes">
<tt class="descname">nbytes</tt><a class="headerlink" href="#pyop2.base.Mat.nbytes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an estimate of the size of the data associated with this
<a class="reference internal" href="#pyop2.base.Mat" title="pyop2.base.Mat"><tt class="xref py py-class docutils literal"><span class="pre">Mat</span></tt></a> in bytes. This will be the correct size of the
data payload, but does not take into account the (presumably
small) overhead of the object and its metadata. The memory
associated with the sparsity pattern is also not recorded.</p>
<p>Note that this is the process local memory usage, not the sum
over all MPI processes.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyop2.base.Kernel">
<em class="property">class </em><tt class="descclassname">pyop2.base.</tt><tt class="descname">Kernel</tt><big>(</big><em>code</em>, <em>name</em>, <em>opts={}</em>, <em>include_dirs=</em><span class="optional">[</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#pyop2.base.Kernel" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyop2.caching.Cached" title="pyop2.caching.Cached"><tt class="xref py py-class docutils literal"><span class="pre">pyop2.caching.Cached</span></tt></a></p>
<p>OP2 kernel type.</p>
<dl class="attribute">
<dt id="pyop2.base.Kernel.name">
<tt class="descname">name</tt><a class="headerlink" href="#pyop2.base.Kernel.name" title="Permalink to this definition">¶</a></dt>
<dd><p>Kernel name, must match the kernel function name in the code.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.Kernel.code">
<tt class="descname">code</tt><a class="headerlink" href="#pyop2.base.Kernel.code" title="Permalink to this definition">¶</a></dt>
<dd><p>String containing the c code for this kernel routine. This
code must conform to the OP2 user kernel API.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyop2.base.JITModule">
<em class="property">class </em><tt class="descclassname">pyop2.base.</tt><tt class="descname">JITModule</tt><a class="headerlink" href="#pyop2.base.JITModule" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyop2.caching.Cached" title="pyop2.caching.Cached"><tt class="xref py py-class docutils literal"><span class="pre">pyop2.caching.Cached</span></tt></a></p>
<p>Cached module encapsulating the generated <a class="reference internal" href="#pyop2.base.ParLoop" title="pyop2.base.ParLoop"><tt class="xref py py-class docutils literal"><span class="pre">ParLoop</span></tt></a> stub.</p>
</dd></dl>

<dl class="class">
<dt id="pyop2.base.ParLoop">
<em class="property">class </em><tt class="descclassname">pyop2.base.</tt><tt class="descname">ParLoop</tt><big>(</big><em>kernel</em>, <em>iterset</em>, <em>*args</em><big>)</big><a class="headerlink" href="#pyop2.base.ParLoop" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyop2.base.LazyComputation" title="pyop2.base.LazyComputation"><tt class="xref py py-class docutils literal"><span class="pre">pyop2.base.LazyComputation</span></tt></a></p>
<p>Represents the kernel, iteration space and arguments of a parallel loop
invocation.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Users should not directly construct <a class="reference internal" href="#pyop2.base.ParLoop" title="pyop2.base.ParLoop"><tt class="xref py py-class docutils literal"><span class="pre">ParLoop</span></tt></a> objects, but
use <a class="reference internal" href="#pyop2.op2.par_loop" title="pyop2.op2.par_loop"><tt class="xref py py-func docutils literal"><span class="pre">pyop2.op2.par_loop()</span></tt></a> instead.</p>
</div>
<dl class="method">
<dt id="pyop2.base.ParLoop.compute">
<tt class="descname">compute</tt><big>(</big><big>)</big><a class="headerlink" href="#pyop2.base.ParLoop.compute" title="Permalink to this definition">¶</a></dt>
<dd><p>Executes the kernel over all members of the iteration space.</p>
<p>This function is logically collective over MPI ranks, it is an
error to call it on fewer than all the ranks in MPI communicator.</p>
</dd></dl>

<dl class="method">
<dt id="pyop2.base.ParLoop.maybe_set_dat_dirty">
<tt class="descname">maybe_set_dat_dirty</tt><big>(</big><big>)</big><a class="headerlink" href="#pyop2.base.ParLoop.maybe_set_dat_dirty" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyop2.base.ParLoop.halo_exchange_begin">
<tt class="descname">halo_exchange_begin</tt><big>(</big><big>)</big><a class="headerlink" href="#pyop2.base.ParLoop.halo_exchange_begin" title="Permalink to this definition">¶</a></dt>
<dd><p>Start halo exchanges.</p>
<p>This function is logically collective over MPI ranks, it is an
error to call it on fewer than all the ranks in MPI communicator.</p>
</dd></dl>

<dl class="method">
<dt id="pyop2.base.ParLoop.halo_exchange_end">
<tt class="descname">halo_exchange_end</tt><big>(</big><big>)</big><a class="headerlink" href="#pyop2.base.ParLoop.halo_exchange_end" title="Permalink to this definition">¶</a></dt>
<dd><p>Finish halo exchanges (wait on irecvs)</p>
<p>This function is logically collective over MPI ranks, it is an
error to call it on fewer than all the ranks in MPI communicator.</p>
</dd></dl>

<dl class="method">
<dt id="pyop2.base.ParLoop.reduction_begin">
<tt class="descname">reduction_begin</tt><big>(</big><big>)</big><a class="headerlink" href="#pyop2.base.ParLoop.reduction_begin" title="Permalink to this definition">¶</a></dt>
<dd><p>Start reductions</p>
<p>This function is logically collective over MPI ranks, it is an
error to call it on fewer than all the ranks in MPI communicator.</p>
</dd></dl>

<dl class="method">
<dt id="pyop2.base.ParLoop.reduction_end">
<tt class="descname">reduction_end</tt><big>(</big><big>)</big><a class="headerlink" href="#pyop2.base.ParLoop.reduction_end" title="Permalink to this definition">¶</a></dt>
<dd><p>End reductions</p>
<p>This function is logically collective over MPI ranks, it is an
error to call it on fewer than all the ranks in MPI communicator.</p>
</dd></dl>

<dl class="method">
<dt id="pyop2.base.ParLoop.maybe_set_halo_update_needed">
<tt class="descname">maybe_set_halo_update_needed</tt><big>(</big><big>)</big><a class="headerlink" href="#pyop2.base.ParLoop.maybe_set_halo_update_needed" title="Permalink to this definition">¶</a></dt>
<dd><p>Set halo update needed for <a class="reference internal" href="#pyop2.base.Dat" title="pyop2.base.Dat"><tt class="xref py py-class docutils literal"><span class="pre">Dat</span></tt></a> arguments that are written to
in this parallel loop.</p>
<p>This function is logically collective over MPI ranks, it is an
error to call it on fewer than all the ranks in MPI communicator.</p>
</dd></dl>

<dl class="method">
<dt id="pyop2.base.ParLoop.assemble">
<tt class="descname">assemble</tt><big>(</big><big>)</big><a class="headerlink" href="#pyop2.base.ParLoop.assemble" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyop2.base.ParLoop.build_itspace">
<tt class="descname">build_itspace</tt><big>(</big><em>iterset</em><big>)</big><a class="headerlink" href="#pyop2.base.ParLoop.build_itspace" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks that the iteration set of the <a class="reference internal" href="#pyop2.base.ParLoop" title="pyop2.base.ParLoop"><tt class="xref py py-class docutils literal"><span class="pre">ParLoop</span></tt></a> matches the
iteration set of all its arguments. A <tt class="xref py py-class docutils literal"><span class="pre">MapValueError</span></tt> is raised
if this condition is not met.</p>
<p>Also determines the size of the local iteration space and checks all
arguments using an <a class="reference internal" href="#pyop2.base.IterationIndex" title="pyop2.base.IterationIndex"><tt class="xref py py-class docutils literal"><span class="pre">IterationIndex</span></tt></a> for consistency.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">class:<cite>IterationSpace</cite> for this <a class="reference internal" href="#pyop2.base.ParLoop" title="pyop2.base.ParLoop"><tt class="xref py py-class docutils literal"><span class="pre">ParLoop</span></tt></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.ParLoop.offset_args">
<tt class="descname">offset_args</tt><a class="headerlink" href="#pyop2.base.ParLoop.offset_args" title="Permalink to this definition">¶</a></dt>
<dd><p>The offset args that need to be added to the argument list.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.ParLoop.layer_arg">
<tt class="descname">layer_arg</tt><a class="headerlink" href="#pyop2.base.ParLoop.layer_arg" title="Permalink to this definition">¶</a></dt>
<dd><p>The layer arg that needs to be added to the argument list.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.ParLoop.it_space">
<tt class="descname">it_space</tt><a class="headerlink" href="#pyop2.base.ParLoop.it_space" title="Permalink to this definition">¶</a></dt>
<dd><p>Iteration space of the parallel loop.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.ParLoop.is_direct">
<tt class="descname">is_direct</tt><a class="headerlink" href="#pyop2.base.ParLoop.is_direct" title="Permalink to this definition">¶</a></dt>
<dd><p>Is this parallel loop direct? I.e. are all the arguments either
:class:Dats accessed through the identity map, or :class:Global?</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.ParLoop.is_indirect">
<tt class="descname">is_indirect</tt><a class="headerlink" href="#pyop2.base.ParLoop.is_indirect" title="Permalink to this definition">¶</a></dt>
<dd><p>Is the parallel loop indirect?</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.ParLoop.needs_exec_halo">
<tt class="descname">needs_exec_halo</tt><a class="headerlink" href="#pyop2.base.ParLoop.needs_exec_halo" title="Permalink to this definition">¶</a></dt>
<dd><p>Does the parallel loop need an exec halo?</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.ParLoop.kernel">
<tt class="descname">kernel</tt><a class="headerlink" href="#pyop2.base.ParLoop.kernel" title="Permalink to this definition">¶</a></dt>
<dd><p>Kernel executed by this parallel loop.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.ParLoop.args">
<tt class="descname">args</tt><a class="headerlink" href="#pyop2.base.ParLoop.args" title="Permalink to this definition">¶</a></dt>
<dd><p>Arguments to this parallel loop.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.base.ParLoop.is_layered">
<tt class="descname">is_layered</tt><a class="headerlink" href="#pyop2.base.ParLoop.is_layered" title="Permalink to this definition">¶</a></dt>
<dd><p>Flag which triggers extrusion</p>
</dd></dl>

</dd></dl>

<dl class="data">
<dt id="pyop2.base.DEFAULT_SOLVER_PARAMETERS">
<tt class="descclassname">pyop2.base.</tt><tt class="descname">DEFAULT_SOLVER_PARAMETERS</tt><em class="property"> = {'pc_type': 'jacobi', 'ksp_atol': 1e-50, 'ksp_max_it': 10000, 'ksp_type': 'cg', 'ksp_gmres_restart': 30, 'ksp_divtol': 10000.0, 'ksp_rtol': 1e-07, 'plot_prefix': '', 'error_on_nonconvergence': True, 'plot_convergence': False, 'ksp_monitor': False}</em><a class="headerlink" href="#pyop2.base.DEFAULT_SOLVER_PARAMETERS" title="Permalink to this definition">¶</a></dt>
<dd><p>All parameters accepted by PETSc KSP and PC objects are permissible
as options to the <tt class="xref py py-class docutils literal"><span class="pre">op2.Solver</span></tt>.</p>
</dd></dl>

<dl class="class">
<dt id="pyop2.base.Solver">
<em class="property">class </em><tt class="descclassname">pyop2.base.</tt><tt class="descname">Solver</tt><big>(</big><em>parameters=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#pyop2.base.Solver" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>OP2 Solver object. The <a class="reference internal" href="#pyop2.base.Solver" title="pyop2.base.Solver"><tt class="xref py py-class docutils literal"><span class="pre">Solver</span></tt></a> holds a set of parameters that are
passed to the underlying linear algebra library when the <tt class="docutils literal"><span class="pre">solve</span></tt> method
is called. These can either be passed as a dictionary <tt class="docutils literal"><span class="pre">parameters</span></tt> <em>or</em>
as individual keyword arguments (combining both will cause an exception).</p>
<p>Recognized parameters either as dictionary keys or keyword arguments are:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>ksp_type</strong> &#8211; the solver type (&#8216;cg&#8217;)</li>
<li><strong>pc_type</strong> &#8211; the preconditioner type (&#8216;jacobi&#8217;)</li>
<li><strong>ksp_rtol</strong> &#8211; relative solver tolerance (1e-7)</li>
<li><strong>ksp_atol</strong> &#8211; absolute solver tolerance (1e-50)</li>
<li><strong>ksp_divtol</strong> &#8211; factor by which the residual norm may exceed the
right-hand-side norm before the solve is considered to have diverged:
<tt class="docutils literal"><span class="pre">norm(r)</span> <span class="pre">&gt;=</span> <span class="pre">dtol*norm(b)</span></tt> (1e4)</li>
<li><strong>ksp_max_it</strong> &#8211; maximum number of solver iterations (10000)</li>
<li><strong>error_on_nonconvergence</strong> &#8211; abort if the solve does not converge in the
maximum number of iterations (True, if False only a warning is printed)</li>
<li><strong>ksp_monitor</strong> &#8211; print the residual norm after each iteration
(False)</li>
<li><strong>plot_convergence</strong> &#8211; plot a graph of the convergence history after the
solve has finished and save it to file (False, implies <em>ksp_monitor</em>)</li>
<li><strong>plot_prefix</strong> &#8211; filename prefix for plot files (&#8216;&#8217;)</li>
<li><strong>ksp_gmres_restart</strong> &#8211; restart period when using GMRES</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="pyop2.base.Solver.update_parameters">
<tt class="descname">update_parameters</tt><big>(</big><em>parameters</em><big>)</big><a class="headerlink" href="#pyop2.base.Solver.update_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Update solver parameters</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>parameters</strong> &#8211; Dictionary containing the parameters to update.</td>
</tr>
</tbody>
</table>
<p>This function is logically collective over MPI ranks, it is an
error to call it on fewer than all the ranks in MPI communicator.</p>
</dd></dl>

<dl class="method">
<dt id="pyop2.base.Solver.solve">
<tt class="descname">solve</tt><big>(</big><em>A</em>, <em>x</em>, <em>b</em><big>)</big><a class="headerlink" href="#pyop2.base.Solver.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve a matrix equation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>A</strong> &#8211; The <a class="reference internal" href="#pyop2.base.Mat" title="pyop2.base.Mat"><tt class="xref py py-class docutils literal"><span class="pre">Mat</span></tt></a> containing the matrix.</li>
<li><strong>x</strong> &#8211; The <a class="reference internal" href="#pyop2.base.Dat" title="pyop2.base.Dat"><tt class="xref py py-class docutils literal"><span class="pre">Dat</span></tt></a> to receive the solution.</li>
<li><strong>b</strong> &#8211; The <a class="reference internal" href="#pyop2.base.Dat" title="pyop2.base.Dat"><tt class="xref py py-class docutils literal"><span class="pre">Dat</span></tt></a> containing the RHS.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>This function is logically collective over MPI ranks, it is an
error to call it on fewer than all the ranks in MPI communicator.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="pyop2.base.par_loop">
<tt class="descclassname">pyop2.base.</tt><tt class="descname">par_loop</tt><big>(</big><em>kernel</em>, <em>it_space</em>, <em>*args</em><big>)</big><a class="headerlink" href="#pyop2.base.par_loop" title="Permalink to this definition">¶</a></dt>
<dd><p>This function is logically collective over MPI ranks, it is an
error to call it on fewer than all the ranks in MPI communicator.</p>
</dd></dl>

</div>
<div class="section" id="module-pyop2.caching">
<span id="caching-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">caching</span></tt> Module<a class="headerlink" href="#module-pyop2.caching" title="Permalink to this headline">¶</a></h2>
<p>Provides common base classes for cached objects.</p>
<dl class="class">
<dt id="pyop2.caching.Cached">
<em class="property">class </em><tt class="descclassname">pyop2.caching.</tt><tt class="descname">Cached</tt><a class="headerlink" href="#pyop2.caching.Cached" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Base class providing global caching of objects. Derived classes need to
implement classmethods <tt class="xref py py-meth docutils literal"><span class="pre">_process_args()</span></tt> and <tt class="xref py py-meth docutils literal"><span class="pre">_cache_key()</span></tt>
and define a class attribute <tt class="xref py py-attr docutils literal"><span class="pre">_cache</span></tt> of type <tt class="xref py py-class docutils literal"><span class="pre">dict</span></tt>.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The derived class&#8217; <tt class="xref py py-meth docutils literal"><span class="pre">__init__()</span></tt> is still called if the object is
retrieved from cache. If that is not desired, derived classes can set
a flag indicating whether the constructor has already been called and
immediately return from <tt class="xref py py-meth docutils literal"><span class="pre">__init__()</span></tt> if the flag is set. Otherwise
the object will be re-initialized even if it was returned from cache!</p>
</div>
<dl class="attribute">
<dt id="pyop2.caching.Cached.cache_key">
<tt class="descname">cache_key</tt><a class="headerlink" href="#pyop2.caching.Cached.cache_key" title="Permalink to this definition">¶</a></dt>
<dd><p>Cache key.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyop2.caching.DiskCached">
<em class="property">class </em><tt class="descclassname">pyop2.caching.</tt><tt class="descname">DiskCached</tt><a class="headerlink" href="#pyop2.caching.DiskCached" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyop2.caching.Cached" title="pyop2.caching.Cached"><tt class="xref py py-class docutils literal"><span class="pre">pyop2.caching.Cached</span></tt></a></p>
<p>Base class providing global caching of objects on disk. The same notes
as in <a class="reference internal" href="#pyop2.caching.Cached" title="pyop2.caching.Cached"><tt class="xref py py-class docutils literal"><span class="pre">Cached</span></tt></a> apply. In addition, derived classes need to
define a class attribute <tt class="xref py py-attr docutils literal"><span class="pre">_cachedir</span></tt> specifying the path where to
cache objects on disk.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The key returned by <tt class="xref py py-meth docutils literal"><span class="pre">_cache_key()</span></tt> <em>must</em> be a
<tt class="xref py py-class docutils literal"><span class="pre">str</span></tt> safe to use as a filename, such as an md5 hex digest.</p>
</div>
</dd></dl>

</div>
<div class="section" id="module-pyop2.computeind">
<span id="computeind-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">computeind</span></tt> Module<a class="headerlink" href="#module-pyop2.computeind" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="pyop2.computeind.compute_ind_extr">
<tt class="descclassname">pyop2.computeind.</tt><tt class="descname">compute_ind_extr</tt><big>(</big><big>)</big><a class="headerlink" href="#pyop2.computeind.compute_ind_extr" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-pyop2.configuration">
<span id="configuration-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">configuration</span></tt> Module<a class="headerlink" href="#module-pyop2.configuration" title="Permalink to this headline">¶</a></h2>
<p>PyOP2 global configuration.</p>
<dl class="class">
<dt id="pyop2.configuration.Configuration">
<em class="property">class </em><tt class="descclassname">pyop2.configuration.</tt><tt class="descname">Configuration</tt><a class="headerlink" href="#pyop2.configuration.Configuration" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>PyOP2 configuration parameters</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>backend</strong> &#8211; Select the PyOP2 backend (one of <cite>cuda</cite>,
<cite>opencl</cite>, <cite>openmp</cite> or <cite>sequential</cite>).</li>
<li><strong>debug</strong> &#8211; Turn on debugging for generated code (turns off
compiler optimisations).</li>
<li><strong>log_level</strong> &#8211; How chatty should PyOP2 be?  Valid values
are &#8220;DEBUG&#8221;, &#8220;INFO&#8221;, &#8220;WARNING&#8221;, &#8220;ERROR&#8221;, &#8220;CRITICAL&#8221;.</li>
<li><strong>lazy_evaluation</strong> &#8211; Should lazy evaluation be on or off?</li>
<li><strong>lazy_max_trace_length</strong> &#8211; How many <tt class="xref py py-func docutils literal"><span class="pre">par_loop()</span></tt>s
should be queued lazily before forcing evaluation?  Pass
<cite>0</cite> for an unbounded length.</li>
<li><strong>dump_gencode</strong> &#8211; Should PyOP2 write the generated code
somewhere for inspection?</li>
<li><strong>dump_gencode_path</strong> &#8211; Where should the generated code be
written to?</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="pyop2.configuration.Configuration.DEFAULTS">
<tt class="descname">DEFAULTS</tt><em class="property"> = {'lazy_evaluation': ('PYOP2_LAZY', &lt;type 'bool'&gt;, True), 'log_level': ('PYOP2_LOG_LEVEL', (&lt;type 'str'&gt;, &lt;type 'int'&gt;), 'WARNING'), 'dump_gencode_path': ('PYOP2_DUMP_GENCODE_PATH', &lt;type 'str'&gt;, '/tmp/pyop2-gencode'), 'simd_isa': ('PYOP2_SIMD_ISA', &lt;type 'str'&gt;, ''), 'lazy_max_trace_length': ('PYOP2_MAX_TRACE_LENGTH', &lt;type 'int'&gt;, 0), 'debug': ('PYOP2_DEBUG', &lt;type 'int'&gt;, 0), 'compiler': ('PYOP2_BACKEND_COMPILER', &lt;type 'str'&gt;, ''), 'dump_gencode': ('PYOP2_DUMP_GENCODE', &lt;type 'bool'&gt;, False), 'backend': ('PYOP2_BACKEND', &lt;type 'str'&gt;, 'sequential')}</em><a class="headerlink" href="#pyop2.configuration.Configuration.DEFAULTS" title="Permalink to this definition">¶</a></dt>
<dd><p>Default values for PyOP2 configuration parameters</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.configuration.Configuration.READONLY">
<tt class="descname">READONLY</tt><em class="property"> = ['backend']</em><a class="headerlink" href="#pyop2.configuration.Configuration.READONLY" title="Permalink to this definition">¶</a></dt>
<dd><p>List of read-only configuration keys.</p>
</dd></dl>

<dl class="method">
<dt id="pyop2.configuration.Configuration.reset">
<tt class="descname">reset</tt><big>(</big><big>)</big><a class="headerlink" href="#pyop2.configuration.Configuration.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset the configuration parameters to the default values.</p>
</dd></dl>

<dl class="method">
<dt id="pyop2.configuration.Configuration.reconfigure">
<tt class="descname">reconfigure</tt><big>(</big><em>**kwargs</em><big>)</big><a class="headerlink" href="#pyop2.configuration.Configuration.reconfigure" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the configuration parameters with new values.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pyop2.cuda">
<span id="cuda-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">cuda</span></tt> Module<a class="headerlink" href="#module-pyop2.cuda" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="pyop2.cuda.Kernel">
<em class="property">class </em><tt class="descclassname">pyop2.cuda.</tt><tt class="descname">Kernel</tt><big>(</big><em>code</em>, <em>name</em>, <em>opts={}</em>, <em>include_dirs=</em><span class="optional">[</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#pyop2.cuda.Kernel" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyop2.device.Kernel" title="pyop2.device.Kernel"><tt class="xref py py-class docutils literal"><span class="pre">pyop2.device.Kernel</span></tt></a></p>
<dl class="method">
<dt id="pyop2.cuda.Kernel.instrument">
<tt class="descname">instrument</tt><big>(</big><big>)</big><a class="headerlink" href="#pyop2.cuda.Kernel.instrument" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyop2.cuda.Arg">
<em class="property">class </em><tt class="descclassname">pyop2.cuda.</tt><tt class="descname">Arg</tt><big>(</big><em>data=None</em>, <em>map=None</em>, <em>idx=None</em>, <em>access=None</em>, <em>flatten=False</em><big>)</big><a class="headerlink" href="#pyop2.cuda.Arg" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyop2.device.Arg" title="pyop2.device.Arg"><tt class="xref py py-class docutils literal"><span class="pre">pyop2.device.Arg</span></tt></a></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>data</strong> &#8211; A data-carrying object, either <a class="reference internal" href="#pyop2.cuda.Dat" title="pyop2.cuda.Dat"><tt class="xref py py-class docutils literal"><span class="pre">Dat</span></tt></a> or class:<cite>Mat</cite></li>
<li><strong>map</strong> &#8211; A <a class="reference internal" href="#pyop2.cuda.Map" title="pyop2.cuda.Map"><tt class="xref py py-class docutils literal"><span class="pre">Map</span></tt></a> to access this <a class="reference internal" href="#pyop2.cuda.Arg" title="pyop2.cuda.Arg"><tt class="xref py py-class docutils literal"><span class="pre">Arg</span></tt></a> or the default
if the identity map is to be used.</li>
<li><strong>idx</strong> &#8211; An index into the <a class="reference internal" href="#pyop2.cuda.Map" title="pyop2.cuda.Map"><tt class="xref py py-class docutils literal"><span class="pre">Map</span></tt></a>: an <tt class="xref py py-class docutils literal"><span class="pre">IterationIndex</span></tt>
when using an iteration space, an <tt class="xref py py-class docutils literal"><span class="pre">int</span></tt> to use a
given component of the mapping or the default to use all
components of the mapping.</li>
<li><strong>access</strong> &#8211; An access descriptor of type <tt class="xref py py-class docutils literal"><span class="pre">Access</span></tt></li>
<li><strong>flatten</strong> &#8211; Treat the data dimensions of this <a class="reference internal" href="#pyop2.cuda.Arg" title="pyop2.cuda.Arg"><tt class="xref py py-class docutils literal"><span class="pre">Arg</span></tt></a> as flat
s.t. the kernel is passed a flat vector of length
<tt class="docutils literal"><span class="pre">map.arity</span> <span class="pre">*</span> <span class="pre">data.dataset.cdim</span></tt>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Checks that:</p>
<ol class="arabic simple">
<li>the maps used are initialized i.e. have mapping data associated, and</li>
<li>the to Set of the map used to access it matches the Set it is
defined on.</li>
</ol>
<p>A <tt class="xref py py-class docutils literal"><span class="pre">MapValueError</span></tt> is raised if these conditions are not met.</p>
</dd></dl>

<dl class="class">
<dt id="pyop2.cuda.Subset">
<em class="property">class </em><tt class="descclassname">pyop2.cuda.</tt><tt class="descname">Subset</tt><big>(</big><em>superset</em>, <em>indices</em><big>)</big><a class="headerlink" href="#pyop2.cuda.Subset" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyop2.base.Subset" title="pyop2.base.Subset"><tt class="xref py py-class docutils literal"><span class="pre">pyop2.base.Subset</span></tt></a></p>
</dd></dl>

<dl class="class">
<dt id="pyop2.cuda.DeviceDataMixin">
<em class="property">class </em><tt class="descclassname">pyop2.cuda.</tt><tt class="descname">DeviceDataMixin</tt><a class="headerlink" href="#pyop2.cuda.DeviceDataMixin" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyop2.device.DeviceDataMixin" title="pyop2.device.DeviceDataMixin"><tt class="xref py py-class docutils literal"><span class="pre">pyop2.device.DeviceDataMixin</span></tt></a></p>
</dd></dl>

<dl class="class">
<dt id="pyop2.cuda.Dat">
<em class="property">class </em><tt class="descclassname">pyop2.cuda.</tt><tt class="descname">Dat</tt><big>(</big><em>dataset</em>, <em>data=None</em>, <em>dtype=None</em>, <em>name=None</em>, <em>soa=None</em>, <em>uid=None</em><big>)</big><a class="headerlink" href="#pyop2.cuda.Dat" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyop2.cuda.DeviceDataMixin" title="pyop2.cuda.DeviceDataMixin"><tt class="xref py py-class docutils literal"><span class="pre">pyop2.cuda.DeviceDataMixin</span></tt></a>, <a class="reference internal" href="#pyop2.device.Dat" title="pyop2.device.Dat"><tt class="xref py py-class docutils literal"><span class="pre">pyop2.device.Dat</span></tt></a></p>
<dl class="attribute">
<dt id="pyop2.cuda.Dat.norm">
<tt class="descname">norm</tt><a class="headerlink" href="#pyop2.cuda.Dat.norm" title="Permalink to this definition">¶</a></dt>
<dd><p>The L2-norm on the flattened vector.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyop2.cuda.Sparsity">
<em class="property">class </em><tt class="descclassname">pyop2.cuda.</tt><tt class="descname">Sparsity</tt><big>(</big><em>dsets</em>, <em>maps</em>, <em>name=None</em><big>)</big><a class="headerlink" href="#pyop2.cuda.Sparsity" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyop2.base.Sparsity" title="pyop2.base.Sparsity"><tt class="xref py py-class docutils literal"><span class="pre">pyop2.base.Sparsity</span></tt></a></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>dsets</strong> &#8211; <tt class="xref py py-class docutils literal"><span class="pre">DataSet</span></tt>s for the left and right function
spaces this <a class="reference internal" href="#pyop2.cuda.Sparsity" title="pyop2.cuda.Sparsity"><tt class="xref py py-class docutils literal"><span class="pre">Sparsity</span></tt></a> maps between</li>
<li><strong>maps</strong> (a pair of <a class="reference internal" href="#pyop2.cuda.Map" title="pyop2.cuda.Map"><tt class="xref py py-class docutils literal"><span class="pre">Map</span></tt></a>s specifying a row map and a column
map, or an iterable of pairs of <a class="reference internal" href="#pyop2.cuda.Map" title="pyop2.cuda.Map"><tt class="xref py py-class docutils literal"><span class="pre">Map</span></tt></a>s specifying multiple
row and column maps - if a single <a class="reference internal" href="#pyop2.cuda.Map" title="pyop2.cuda.Map"><tt class="xref py py-class docutils literal"><span class="pre">Map</span></tt></a> is passed, it is
used as both a row map and a column map) &#8211; <a class="reference internal" href="#pyop2.cuda.Map" title="pyop2.cuda.Map"><tt class="xref py py-class docutils literal"><span class="pre">Map</span></tt></a>s to build the <a class="reference internal" href="#pyop2.cuda.Sparsity" title="pyop2.cuda.Sparsity"><tt class="xref py py-class docutils literal"><span class="pre">Sparsity</span></tt></a> from</li>
<li><strong>name</strong> (<em>string</em>) &#8211; user-defined label (optional)</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="pyop2.cuda.Sparsity.rowptr">
<tt class="descname">rowptr</tt><a class="headerlink" href="#pyop2.cuda.Sparsity.rowptr" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyop2.cuda.Sparsity.colidx">
<tt class="descname">colidx</tt><a class="headerlink" href="#pyop2.cuda.Sparsity.colidx" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyop2.cuda.Mat">
<em class="property">class </em><tt class="descclassname">pyop2.cuda.</tt><tt class="descname">Mat</tt><big>(</big><em>datasets</em>, <em>dtype=None</em>, <em>name=None</em><big>)</big><a class="headerlink" href="#pyop2.cuda.Mat" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyop2.cuda.DeviceDataMixin" title="pyop2.cuda.DeviceDataMixin"><tt class="xref py py-class docutils literal"><span class="pre">pyop2.cuda.DeviceDataMixin</span></tt></a>, <a class="reference internal" href="#pyop2.device.Mat" title="pyop2.device.Mat"><tt class="xref py py-class docutils literal"><span class="pre">pyop2.device.Mat</span></tt></a></p>
<dl class="attribute">
<dt id="pyop2.cuda.Mat.values">
<tt class="descname">values</tt><a class="headerlink" href="#pyop2.cuda.Mat.values" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyop2.cuda.Mat.array">
<tt class="descname">array</tt><a class="headerlink" href="#pyop2.cuda.Mat.array" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyop2.cuda.Mat.zero_rows">
<tt class="descname">zero_rows</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#pyop2.cuda.Mat.zero_rows" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyop2.cuda.Mat.zero">
<tt class="descname">zero</tt><big>(</big><big>)</big><a class="headerlink" href="#pyop2.cuda.Mat.zero" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyop2.cuda.Const">
<em class="property">class </em><tt class="descclassname">pyop2.cuda.</tt><tt class="descname">Const</tt><big>(</big><em>dim</em>, <em>data</em>, <em>name</em>, <em>dtype=None</em><big>)</big><a class="headerlink" href="#pyop2.cuda.Const" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyop2.cuda.DeviceDataMixin" title="pyop2.cuda.DeviceDataMixin"><tt class="xref py py-class docutils literal"><span class="pre">pyop2.cuda.DeviceDataMixin</span></tt></a>, <a class="reference internal" href="#pyop2.device.Const" title="pyop2.device.Const"><tt class="xref py py-class docutils literal"><span class="pre">pyop2.device.Const</span></tt></a></p>
</dd></dl>

<dl class="class">
<dt id="pyop2.cuda.Global">
<em class="property">class </em><tt class="descclassname">pyop2.cuda.</tt><tt class="descname">Global</tt><big>(</big><em>dim</em>, <em>data=None</em>, <em>dtype=None</em>, <em>name=None</em><big>)</big><a class="headerlink" href="#pyop2.cuda.Global" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyop2.cuda.DeviceDataMixin" title="pyop2.cuda.DeviceDataMixin"><tt class="xref py py-class docutils literal"><span class="pre">pyop2.cuda.DeviceDataMixin</span></tt></a>, <a class="reference internal" href="#pyop2.device.Global" title="pyop2.device.Global"><tt class="xref py py-class docutils literal"><span class="pre">pyop2.device.Global</span></tt></a></p>
<dl class="attribute">
<dt id="pyop2.cuda.Global.data">
<tt class="descname">data</tt><a class="headerlink" href="#pyop2.cuda.Global.data" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyop2.cuda.Map">
<em class="property">class </em><tt class="descclassname">pyop2.cuda.</tt><tt class="descname">Map</tt><big>(</big><em>iterset</em>, <em>dataset</em>, <em>arity</em>, <em>values=None</em>, <em>name=None</em>, <em>offset=None</em>, <em>parent=None</em>, <em>bt_masks=None</em><big>)</big><a class="headerlink" href="#pyop2.cuda.Map" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyop2.device.Map" title="pyop2.device.Map"><tt class="xref py py-class docutils literal"><span class="pre">pyop2.device.Map</span></tt></a></p>
</dd></dl>

<dl class="class">
<dt id="pyop2.cuda.Plan">
<em class="property">class </em><tt class="descclassname">pyop2.cuda.</tt><tt class="descname">Plan</tt><a class="headerlink" href="#pyop2.cuda.Plan" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyop2.plan.Plan" title="pyop2.plan.Plan"><tt class="xref py py-class docutils literal"><span class="pre">pyop2.plan.Plan</span></tt></a></p>
<dl class="attribute">
<dt id="pyop2.cuda.Plan.nthrcol">
<tt class="descname">nthrcol</tt><a class="headerlink" href="#pyop2.cuda.Plan.nthrcol" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyop2.cuda.Plan.thrcol">
<tt class="descname">thrcol</tt><a class="headerlink" href="#pyop2.cuda.Plan.thrcol" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyop2.cuda.Plan.offset">
<tt class="descname">offset</tt><a class="headerlink" href="#pyop2.cuda.Plan.offset" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyop2.cuda.Plan.ind_map">
<tt class="descname">ind_map</tt><a class="headerlink" href="#pyop2.cuda.Plan.ind_map" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyop2.cuda.Plan.ind_offs">
<tt class="descname">ind_offs</tt><a class="headerlink" href="#pyop2.cuda.Plan.ind_offs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyop2.cuda.Plan.ind_sizes">
<tt class="descname">ind_sizes</tt><a class="headerlink" href="#pyop2.cuda.Plan.ind_sizes" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyop2.cuda.Plan.loc_map">
<tt class="descname">loc_map</tt><a class="headerlink" href="#pyop2.cuda.Plan.loc_map" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyop2.cuda.Plan.nelems">
<tt class="descname">nelems</tt><a class="headerlink" href="#pyop2.cuda.Plan.nelems" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyop2.cuda.Plan.blkmap">
<tt class="descname">blkmap</tt><a class="headerlink" href="#pyop2.cuda.Plan.blkmap" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyop2.cuda.Solver">
<em class="property">class </em><tt class="descclassname">pyop2.cuda.</tt><tt class="descname">Solver</tt><big>(</big><em>parameters=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#pyop2.cuda.Solver" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyop2.base.Solver" title="pyop2.base.Solver"><tt class="xref py py-class docutils literal"><span class="pre">pyop2.base.Solver</span></tt></a></p>
</dd></dl>

<dl class="class">
<dt id="pyop2.cuda.JITModule">
<em class="property">class </em><tt class="descclassname">pyop2.cuda.</tt><tt class="descname">JITModule</tt><big>(</big><em>kernel</em>, <em>itspace_extents</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#pyop2.cuda.JITModule" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyop2.base.JITModule" title="pyop2.base.JITModule"><tt class="xref py py-class docutils literal"><span class="pre">pyop2.base.JITModule</span></tt></a></p>
<dl class="method">
<dt id="pyop2.cuda.JITModule.compile">
<tt class="descname">compile</tt><big>(</big><big>)</big><a class="headerlink" href="#pyop2.cuda.JITModule.compile" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyop2.cuda.ParLoop">
<em class="property">class </em><tt class="descclassname">pyop2.cuda.</tt><tt class="descname">ParLoop</tt><big>(</big><em>kernel</em>, <em>itspace</em>, <em>*args</em><big>)</big><a class="headerlink" href="#pyop2.cuda.ParLoop" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyop2.device.ParLoop" title="pyop2.device.ParLoop"><tt class="xref py py-class docutils literal"><span class="pre">pyop2.device.ParLoop</span></tt></a></p>
<dl class="method">
<dt id="pyop2.cuda.ParLoop.launch_configuration">
<tt class="descname">launch_configuration</tt><big>(</big><em>part</em><big>)</big><a class="headerlink" href="#pyop2.cuda.ParLoop.launch_configuration" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyop2.cuda.ParLoop.assemble">
<tt class="descname">assemble</tt><big>(</big><big>)</big><a class="headerlink" href="#pyop2.cuda.ParLoop.assemble" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pyop2.device">
<span id="device-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">device</span></tt> Module<a class="headerlink" href="#module-pyop2.device" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="pyop2.device.Kernel">
<em class="property">class </em><tt class="descclassname">pyop2.device.</tt><tt class="descname">Kernel</tt><big>(</big><em>code</em>, <em>name</em>, <em>opts={}</em>, <em>include_dirs=</em><span class="optional">[</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#pyop2.device.Kernel" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyop2.base.Kernel" title="pyop2.base.Kernel"><tt class="xref py py-class docutils literal"><span class="pre">pyop2.base.Kernel</span></tt></a></p>
</dd></dl>

<dl class="class">
<dt id="pyop2.device.Arg">
<em class="property">class </em><tt class="descclassname">pyop2.device.</tt><tt class="descname">Arg</tt><big>(</big><em>data=None</em>, <em>map=None</em>, <em>idx=None</em>, <em>access=None</em>, <em>flatten=False</em><big>)</big><a class="headerlink" href="#pyop2.device.Arg" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyop2.base.Arg" title="pyop2.base.Arg"><tt class="xref py py-class docutils literal"><span class="pre">pyop2.base.Arg</span></tt></a></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>data</strong> &#8211; A data-carrying object, either <a class="reference internal" href="#pyop2.device.Dat" title="pyop2.device.Dat"><tt class="xref py py-class docutils literal"><span class="pre">Dat</span></tt></a> or class:<cite>Mat</cite></li>
<li><strong>map</strong> &#8211; A <a class="reference internal" href="#pyop2.device.Map" title="pyop2.device.Map"><tt class="xref py py-class docutils literal"><span class="pre">Map</span></tt></a> to access this <a class="reference internal" href="#pyop2.device.Arg" title="pyop2.device.Arg"><tt class="xref py py-class docutils literal"><span class="pre">Arg</span></tt></a> or the default
if the identity map is to be used.</li>
<li><strong>idx</strong> &#8211; An index into the <a class="reference internal" href="#pyop2.device.Map" title="pyop2.device.Map"><tt class="xref py py-class docutils literal"><span class="pre">Map</span></tt></a>: an <tt class="xref py py-class docutils literal"><span class="pre">IterationIndex</span></tt>
when using an iteration space, an <tt class="xref py py-class docutils literal"><span class="pre">int</span></tt> to use a
given component of the mapping or the default to use all
components of the mapping.</li>
<li><strong>access</strong> &#8211; An access descriptor of type <tt class="xref py py-class docutils literal"><span class="pre">Access</span></tt></li>
<li><strong>flatten</strong> &#8211; Treat the data dimensions of this <a class="reference internal" href="#pyop2.device.Arg" title="pyop2.device.Arg"><tt class="xref py py-class docutils literal"><span class="pre">Arg</span></tt></a> as flat
s.t. the kernel is passed a flat vector of length
<tt class="docutils literal"><span class="pre">map.arity</span> <span class="pre">*</span> <span class="pre">data.dataset.cdim</span></tt>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Checks that:</p>
<ol class="arabic simple">
<li>the maps used are initialized i.e. have mapping data associated, and</li>
<li>the to Set of the map used to access it matches the Set it is
defined on.</li>
</ol>
<p>A <tt class="xref py py-class docutils literal"><span class="pre">MapValueError</span></tt> is raised if these conditions are not met.</p>
<dl class="attribute">
<dt id="pyop2.device.Arg.name">
<tt class="descname">name</tt><a class="headerlink" href="#pyop2.device.Arg.name" title="Permalink to this definition">¶</a></dt>
<dd><p>The generated argument name.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyop2.device.DeviceDataMixin">
<em class="property">class </em><tt class="descclassname">pyop2.device.</tt><tt class="descname">DeviceDataMixin</tt><a class="headerlink" href="#pyop2.device.DeviceDataMixin" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<dl class="attribute">
<dt id="pyop2.device.DeviceDataMixin.DEVICE_UNALLOCATED">
<tt class="descname">DEVICE_UNALLOCATED</tt><em class="property"> = 'DEVICE_UNALLOCATED'</em><a class="headerlink" href="#pyop2.device.DeviceDataMixin.DEVICE_UNALLOCATED" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyop2.device.DeviceDataMixin.HOST_UNALLOCATED">
<tt class="descname">HOST_UNALLOCATED</tt><em class="property"> = 'HOST_UNALLOCATED'</em><a class="headerlink" href="#pyop2.device.DeviceDataMixin.HOST_UNALLOCATED" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyop2.device.DeviceDataMixin.DEVICE">
<tt class="descname">DEVICE</tt><em class="property"> = 'DEVICE'</em><a class="headerlink" href="#pyop2.device.DeviceDataMixin.DEVICE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyop2.device.DeviceDataMixin.HOST">
<tt class="descname">HOST</tt><em class="property"> = 'HOST'</em><a class="headerlink" href="#pyop2.device.DeviceDataMixin.HOST" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyop2.device.DeviceDataMixin.BOTH">
<tt class="descname">BOTH</tt><em class="property"> = 'BOTH'</em><a class="headerlink" href="#pyop2.device.DeviceDataMixin.BOTH" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyop2.device.DeviceDataMixin.state">
<tt class="descname">state</tt><a class="headerlink" href="#pyop2.device.DeviceDataMixin.state" title="Permalink to this definition">¶</a></dt>
<dd><p>Current allocation state of the data.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.device.DeviceDataMixin.data">
<tt class="descname">data</tt><a class="headerlink" href="#pyop2.device.DeviceDataMixin.data" title="Permalink to this definition">¶</a></dt>
<dd><p>Numpy array containing the data values.</p>
<p>This function is logically collective over MPI ranks, it is an
error to call it on fewer than all the ranks in MPI communicator.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.device.DeviceDataMixin.data_ro">
<tt class="descname">data_ro</tt><a class="headerlink" href="#pyop2.device.DeviceDataMixin.data_ro" title="Permalink to this definition">¶</a></dt>
<dd><p>Numpy array containing the data values.  Read-only</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyop2.device.Dat">
<em class="property">class </em><tt class="descclassname">pyop2.device.</tt><tt class="descname">Dat</tt><big>(</big><em>dataset</em>, <em>data=None</em>, <em>dtype=None</em>, <em>name=None</em>, <em>soa=None</em>, <em>uid=None</em><big>)</big><a class="headerlink" href="#pyop2.device.Dat" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyop2.device.DeviceDataMixin" title="pyop2.device.DeviceDataMixin"><tt class="xref py py-class docutils literal"><span class="pre">pyop2.device.DeviceDataMixin</span></tt></a>, <a class="reference internal" href="#pyop2.base.Dat" title="pyop2.base.Dat"><tt class="xref py py-class docutils literal"><span class="pre">pyop2.base.Dat</span></tt></a></p>
<dl class="attribute">
<dt id="pyop2.device.Dat.array">
<tt class="descname">array</tt><a class="headerlink" href="#pyop2.device.Dat.array" title="Permalink to this definition">¶</a></dt>
<dd><p>The data array on the device.</p>
</dd></dl>

<dl class="method">
<dt id="pyop2.device.Dat.halo_exchange_begin">
<tt class="descname">halo_exchange_begin</tt><big>(</big><big>)</big><a class="headerlink" href="#pyop2.device.Dat.halo_exchange_begin" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyop2.device.Dat.halo_exchange_end">
<tt class="descname">halo_exchange_end</tt><big>(</big><big>)</big><a class="headerlink" href="#pyop2.device.Dat.halo_exchange_end" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyop2.device.Const">
<em class="property">class </em><tt class="descclassname">pyop2.device.</tt><tt class="descname">Const</tt><big>(</big><em>dim</em>, <em>data</em>, <em>name</em>, <em>dtype=None</em><big>)</big><a class="headerlink" href="#pyop2.device.Const" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyop2.device.DeviceDataMixin" title="pyop2.device.DeviceDataMixin"><tt class="xref py py-class docutils literal"><span class="pre">pyop2.device.DeviceDataMixin</span></tt></a>, <a class="reference internal" href="#pyop2.base.Const" title="pyop2.base.Const"><tt class="xref py py-class docutils literal"><span class="pre">pyop2.base.Const</span></tt></a></p>
<dl class="attribute">
<dt id="pyop2.device.Const.data">
<tt class="descname">data</tt><a class="headerlink" href="#pyop2.device.Const.data" title="Permalink to this definition">¶</a></dt>
<dd><p>Numpy array containing the data values.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyop2.device.Global">
<em class="property">class </em><tt class="descclassname">pyop2.device.</tt><tt class="descname">Global</tt><big>(</big><em>dim</em>, <em>data=None</em>, <em>dtype=None</em>, <em>name=None</em><big>)</big><a class="headerlink" href="#pyop2.device.Global" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyop2.device.DeviceDataMixin" title="pyop2.device.DeviceDataMixin"><tt class="xref py py-class docutils literal"><span class="pre">pyop2.device.DeviceDataMixin</span></tt></a>, <a class="reference internal" href="#pyop2.base.Global" title="pyop2.base.Global"><tt class="xref py py-class docutils literal"><span class="pre">pyop2.base.Global</span></tt></a></p>
</dd></dl>

<dl class="class">
<dt id="pyop2.device.Map">
<em class="property">class </em><tt class="descclassname">pyop2.device.</tt><tt class="descname">Map</tt><big>(</big><em>iterset</em>, <em>dataset</em>, <em>arity</em>, <em>values=None</em>, <em>name=None</em>, <em>offset=None</em>, <em>parent=None</em>, <em>bt_masks=None</em><big>)</big><a class="headerlink" href="#pyop2.device.Map" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyop2.base.Map" title="pyop2.base.Map"><tt class="xref py py-class docutils literal"><span class="pre">pyop2.base.Map</span></tt></a></p>
</dd></dl>

<dl class="class">
<dt id="pyop2.device.Mat">
<em class="property">class </em><tt class="descclassname">pyop2.device.</tt><tt class="descname">Mat</tt><big>(</big><em>datasets</em>, <em>dtype=None</em>, <em>name=None</em><big>)</big><a class="headerlink" href="#pyop2.device.Mat" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyop2.base.Mat" title="pyop2.base.Mat"><tt class="xref py py-class docutils literal"><span class="pre">pyop2.base.Mat</span></tt></a></p>
</dd></dl>

<dl class="class">
<dt id="pyop2.device.ParLoop">
<em class="property">class </em><tt class="descclassname">pyop2.device.</tt><tt class="descname">ParLoop</tt><big>(</big><em>kernel</em>, <em>itspace</em>, <em>*args</em><big>)</big><a class="headerlink" href="#pyop2.device.ParLoop" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyop2.base.ParLoop" title="pyop2.base.ParLoop"><tt class="xref py py-class docutils literal"><span class="pre">pyop2.base.ParLoop</span></tt></a></p>
</dd></dl>

</div>
<div class="section" id="module-pyop2.exceptions">
<span id="exceptions-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">exceptions</span></tt> Module<a class="headerlink" href="#module-pyop2.exceptions" title="Permalink to this headline">¶</a></h2>
<p>OP2 exception types</p>
<dl class="exception">
<dt id="pyop2.exceptions.DataTypeError">
<em class="property">exception </em><tt class="descclassname">pyop2.exceptions.</tt><tt class="descname">DataTypeError</tt><a class="headerlink" href="#pyop2.exceptions.DataTypeError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">exceptions.TypeError</span></tt></p>
<p>Invalid type for data.</p>
</dd></dl>

<dl class="exception">
<dt id="pyop2.exceptions.DimTypeError">
<em class="property">exception </em><tt class="descclassname">pyop2.exceptions.</tt><tt class="descname">DimTypeError</tt><a class="headerlink" href="#pyop2.exceptions.DimTypeError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">exceptions.TypeError</span></tt></p>
<p>Invalid type for dimension.</p>
</dd></dl>

<dl class="exception">
<dt id="pyop2.exceptions.ArityTypeError">
<em class="property">exception </em><tt class="descclassname">pyop2.exceptions.</tt><tt class="descname">ArityTypeError</tt><a class="headerlink" href="#pyop2.exceptions.ArityTypeError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">exceptions.TypeError</span></tt></p>
<p>Invalid type for arity.</p>
</dd></dl>

<dl class="exception">
<dt id="pyop2.exceptions.IndexTypeError">
<em class="property">exception </em><tt class="descclassname">pyop2.exceptions.</tt><tt class="descname">IndexTypeError</tt><a class="headerlink" href="#pyop2.exceptions.IndexTypeError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">exceptions.TypeError</span></tt></p>
<p>Invalid type for index.</p>
</dd></dl>

<dl class="exception">
<dt id="pyop2.exceptions.NameTypeError">
<em class="property">exception </em><tt class="descclassname">pyop2.exceptions.</tt><tt class="descname">NameTypeError</tt><a class="headerlink" href="#pyop2.exceptions.NameTypeError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">exceptions.TypeError</span></tt></p>
<p>Invalid type for name.</p>
</dd></dl>

<dl class="exception">
<dt id="pyop2.exceptions.SetTypeError">
<em class="property">exception </em><tt class="descclassname">pyop2.exceptions.</tt><tt class="descname">SetTypeError</tt><a class="headerlink" href="#pyop2.exceptions.SetTypeError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">exceptions.TypeError</span></tt></p>
<p>Invalid type for <a class="reference internal" href="#pyop2.op2.Set" title="pyop2.op2.Set"><tt class="xref py py-class docutils literal"><span class="pre">pyop2.op2.Set</span></tt></a>.</p>
</dd></dl>

<dl class="exception">
<dt id="pyop2.exceptions.SizeTypeError">
<em class="property">exception </em><tt class="descclassname">pyop2.exceptions.</tt><tt class="descname">SizeTypeError</tt><a class="headerlink" href="#pyop2.exceptions.SizeTypeError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">exceptions.TypeError</span></tt></p>
<p>Invalid type for size.</p>
</dd></dl>

<dl class="exception">
<dt id="pyop2.exceptions.SubsetIndexOutOfBounds">
<em class="property">exception </em><tt class="descclassname">pyop2.exceptions.</tt><tt class="descname">SubsetIndexOutOfBounds</tt><a class="headerlink" href="#pyop2.exceptions.SubsetIndexOutOfBounds" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">exceptions.TypeError</span></tt></p>
<p>Out of bound index.</p>
</dd></dl>

<dl class="exception">
<dt id="pyop2.exceptions.SparsityTypeError">
<em class="property">exception </em><tt class="descclassname">pyop2.exceptions.</tt><tt class="descname">SparsityTypeError</tt><a class="headerlink" href="#pyop2.exceptions.SparsityTypeError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">exceptions.TypeError</span></tt></p>
<p>Invalid type for <a class="reference internal" href="#pyop2.op2.Sparsity" title="pyop2.op2.Sparsity"><tt class="xref py py-class docutils literal"><span class="pre">pyop2.op2.Sparsity</span></tt></a>.</p>
</dd></dl>

<dl class="exception">
<dt id="pyop2.exceptions.MapTypeError">
<em class="property">exception </em><tt class="descclassname">pyop2.exceptions.</tt><tt class="descname">MapTypeError</tt><a class="headerlink" href="#pyop2.exceptions.MapTypeError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">exceptions.TypeError</span></tt></p>
<p>Invalid type for <a class="reference internal" href="#pyop2.op2.Map" title="pyop2.op2.Map"><tt class="xref py py-class docutils literal"><span class="pre">pyop2.op2.Map</span></tt></a>.</p>
</dd></dl>

<dl class="exception">
<dt id="pyop2.exceptions.DataSetTypeError">
<em class="property">exception </em><tt class="descclassname">pyop2.exceptions.</tt><tt class="descname">DataSetTypeError</tt><a class="headerlink" href="#pyop2.exceptions.DataSetTypeError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">exceptions.TypeError</span></tt></p>
<p>Invalid type for <a class="reference internal" href="#pyop2.op2.DataSet" title="pyop2.op2.DataSet"><tt class="xref py py-class docutils literal"><span class="pre">pyop2.op2.DataSet</span></tt></a>.</p>
</dd></dl>

<dl class="exception">
<dt id="pyop2.exceptions.MatTypeError">
<em class="property">exception </em><tt class="descclassname">pyop2.exceptions.</tt><tt class="descname">MatTypeError</tt><a class="headerlink" href="#pyop2.exceptions.MatTypeError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">exceptions.TypeError</span></tt></p>
<p>Invalid type for <a class="reference internal" href="#pyop2.op2.Mat" title="pyop2.op2.Mat"><tt class="xref py py-class docutils literal"><span class="pre">pyop2.op2.Mat</span></tt></a>.</p>
</dd></dl>

<dl class="exception">
<dt id="pyop2.exceptions.DatTypeError">
<em class="property">exception </em><tt class="descclassname">pyop2.exceptions.</tt><tt class="descname">DatTypeError</tt><a class="headerlink" href="#pyop2.exceptions.DatTypeError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">exceptions.TypeError</span></tt></p>
<p>Invalid type for <a class="reference internal" href="#pyop2.op2.Dat" title="pyop2.op2.Dat"><tt class="xref py py-class docutils literal"><span class="pre">pyop2.op2.Dat</span></tt></a>.</p>
</dd></dl>

<dl class="exception">
<dt id="pyop2.exceptions.KernelTypeError">
<em class="property">exception </em><tt class="descclassname">pyop2.exceptions.</tt><tt class="descname">KernelTypeError</tt><a class="headerlink" href="#pyop2.exceptions.KernelTypeError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">exceptions.TypeError</span></tt></p>
<p>Invalid type for <a class="reference internal" href="#pyop2.op2.Kernel" title="pyop2.op2.Kernel"><tt class="xref py py-class docutils literal"><span class="pre">pyop2.op2.Kernel</span></tt></a>.</p>
</dd></dl>

<dl class="exception">
<dt id="pyop2.exceptions.DataValueError">
<em class="property">exception </em><tt class="descclassname">pyop2.exceptions.</tt><tt class="descname">DataValueError</tt><a class="headerlink" href="#pyop2.exceptions.DataValueError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">exceptions.ValueError</span></tt></p>
<p>Illegal value for data.</p>
</dd></dl>

<dl class="exception">
<dt id="pyop2.exceptions.IndexValueError">
<em class="property">exception </em><tt class="descclassname">pyop2.exceptions.</tt><tt class="descname">IndexValueError</tt><a class="headerlink" href="#pyop2.exceptions.IndexValueError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">exceptions.ValueError</span></tt></p>
<p>Illegal value for index.</p>
</dd></dl>

<dl class="exception">
<dt id="pyop2.exceptions.ModeValueError">
<em class="property">exception </em><tt class="descclassname">pyop2.exceptions.</tt><tt class="descname">ModeValueError</tt><a class="headerlink" href="#pyop2.exceptions.ModeValueError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">exceptions.ValueError</span></tt></p>
<p>Illegal value for mode.</p>
</dd></dl>

<dl class="exception">
<dt id="pyop2.exceptions.SetValueError">
<em class="property">exception </em><tt class="descclassname">pyop2.exceptions.</tt><tt class="descname">SetValueError</tt><a class="headerlink" href="#pyop2.exceptions.SetValueError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">exceptions.ValueError</span></tt></p>
<p>Illegal value for <a class="reference internal" href="#pyop2.op2.Set" title="pyop2.op2.Set"><tt class="xref py py-class docutils literal"><span class="pre">pyop2.op2.Set</span></tt></a>.</p>
</dd></dl>

<dl class="exception">
<dt id="pyop2.exceptions.MapValueError">
<em class="property">exception </em><tt class="descclassname">pyop2.exceptions.</tt><tt class="descname">MapValueError</tt><a class="headerlink" href="#pyop2.exceptions.MapValueError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">exceptions.ValueError</span></tt></p>
<p>Illegal value for <a class="reference internal" href="#pyop2.op2.Map" title="pyop2.op2.Map"><tt class="xref py py-class docutils literal"><span class="pre">pyop2.op2.Map</span></tt></a>.</p>
</dd></dl>

<dl class="exception">
<dt id="pyop2.exceptions.ConfigurationError">
<em class="property">exception </em><tt class="descclassname">pyop2.exceptions.</tt><tt class="descname">ConfigurationError</tt><a class="headerlink" href="#pyop2.exceptions.ConfigurationError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">exceptions.RuntimeError</span></tt></p>
<p>Illegal configuration value or type.</p>
</dd></dl>

</div>
<div class="section" id="module-pyop2.ffc_interface">
<span id="ffc-interface-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">ffc_interface</span></tt> Module<a class="headerlink" href="#module-pyop2.ffc_interface" title="Permalink to this headline">¶</a></h2>
<p>Provides the interface to FFC for compiling a form, and transforms the FFC-
generated code in order to make it suitable for passing to the backends.</p>
<dl class="class">
<dt id="pyop2.ffc_interface.FFCKernel">
<em class="property">class </em><tt class="descclassname">pyop2.ffc_interface.</tt><tt class="descname">FFCKernel</tt><big>(</big><em>form</em>, <em>name</em><big>)</big><a class="headerlink" href="#pyop2.ffc_interface.FFCKernel" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyop2.caching.DiskCached" title="pyop2.caching.DiskCached"><tt class="xref py py-class docutils literal"><span class="pre">pyop2.caching.DiskCached</span></tt></a></p>
</dd></dl>

<dl class="function">
<dt id="pyop2.ffc_interface.compile_form">
<tt class="descclassname">pyop2.ffc_interface.</tt><tt class="descname">compile_form</tt><big>(</big><em>form</em>, <em>name</em><big>)</big><a class="headerlink" href="#pyop2.ffc_interface.compile_form" title="Permalink to this definition">¶</a></dt>
<dd><p>Compile a form using FFC and return a <a class="reference internal" href="#pyop2.op2.Kernel" title="pyop2.op2.Kernel"><tt class="xref py py-class docutils literal"><span class="pre">pyop2.op2.Kernel</span></tt></a>.</p>
</dd></dl>

<dl class="function">
<dt id="pyop2.ffc_interface.clear_cache">
<tt class="descclassname">pyop2.ffc_interface.</tt><tt class="descname">clear_cache</tt><big>(</big><big>)</big><a class="headerlink" href="#pyop2.ffc_interface.clear_cache" title="Permalink to this definition">¶</a></dt>
<dd><p>Clear the PyOP2 FFC kernel cache.</p>
</dd></dl>

</div>
<div class="section" id="module-pyop2.finalised">
<span id="finalised-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">finalised</span></tt> Module<a class="headerlink" href="#module-pyop2.finalised" title="Permalink to this headline">¶</a></h2>
<p>This module contains stub implementations of core classes which are used to
provide useful error messages if the user invokes them after calling
<a class="reference internal" href="#pyop2.op2.exit" title="pyop2.op2.exit"><tt class="xref py py-func docutils literal"><span class="pre">pyop2.op2.exit()</span></tt></a></p>
<dl class="class">
<dt id="pyop2.finalised.Access">
<em class="property">class </em><tt class="descclassname">pyop2.finalised.</tt><tt class="descname">Access</tt><big>(</big><em>*args</em><big>)</big><a class="headerlink" href="#pyop2.finalised.Access" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
</dd></dl>

<dl class="class">
<dt id="pyop2.finalised.Set">
<em class="property">class </em><tt class="descclassname">pyop2.finalised.</tt><tt class="descname">Set</tt><big>(</big><em>*args</em><big>)</big><a class="headerlink" href="#pyop2.finalised.Set" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
</dd></dl>

<dl class="class">
<dt id="pyop2.finalised.Kernel">
<em class="property">class </em><tt class="descclassname">pyop2.finalised.</tt><tt class="descname">Kernel</tt><big>(</big><em>*args</em><big>)</big><a class="headerlink" href="#pyop2.finalised.Kernel" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
</dd></dl>

<dl class="class">
<dt id="pyop2.finalised.Dat">
<em class="property">class </em><tt class="descclassname">pyop2.finalised.</tt><tt class="descname">Dat</tt><big>(</big><em>*args</em><big>)</big><a class="headerlink" href="#pyop2.finalised.Dat" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
</dd></dl>

<dl class="class">
<dt id="pyop2.finalised.Mat">
<em class="property">class </em><tt class="descclassname">pyop2.finalised.</tt><tt class="descname">Mat</tt><big>(</big><em>*args</em><big>)</big><a class="headerlink" href="#pyop2.finalised.Mat" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
</dd></dl>

<dl class="class">
<dt id="pyop2.finalised.Const">
<em class="property">class </em><tt class="descclassname">pyop2.finalised.</tt><tt class="descname">Const</tt><big>(</big><em>*args</em><big>)</big><a class="headerlink" href="#pyop2.finalised.Const" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
</dd></dl>

<dl class="class">
<dt id="pyop2.finalised.Global">
<em class="property">class </em><tt class="descclassname">pyop2.finalised.</tt><tt class="descname">Global</tt><big>(</big><em>*args</em><big>)</big><a class="headerlink" href="#pyop2.finalised.Global" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
</dd></dl>

<dl class="class">
<dt id="pyop2.finalised.Map">
<em class="property">class </em><tt class="descclassname">pyop2.finalised.</tt><tt class="descname">Map</tt><big>(</big><em>*args</em><big>)</big><a class="headerlink" href="#pyop2.finalised.Map" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
</dd></dl>

<dl class="function">
<dt id="pyop2.finalised.par_loop">
<tt class="descclassname">pyop2.finalised.</tt><tt class="descname">par_loop</tt><big>(</big><em>*args</em><big>)</big><a class="headerlink" href="#pyop2.finalised.par_loop" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-pyop2.find_op2">
<span id="find-op2-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">find_op2</span></tt> Module<a class="headerlink" href="#module-pyop2.find_op2" title="Permalink to this headline">¶</a></h2>
<p>Try finding the install location of the OP2-Common library.</p>
</div>
<div class="section" id="module-pyop2.host">
<span id="host-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">host</span></tt> Module<a class="headerlink" href="#module-pyop2.host" title="Permalink to this headline">¶</a></h2>
<p>Base classes extending those from the <tt class="xref py py-mod docutils literal"><span class="pre">base</span></tt> module with functionality
common to backends executing on the host.</p>
<dl class="class">
<dt id="pyop2.host.Kernel">
<em class="property">class </em><tt class="descclassname">pyop2.host.</tt><tt class="descname">Kernel</tt><big>(</big><em>code</em>, <em>name</em>, <em>opts={}</em>, <em>include_dirs=</em><span class="optional">[</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#pyop2.host.Kernel" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyop2.base.Kernel" title="pyop2.base.Kernel"><tt class="xref py py-class docutils literal"><span class="pre">pyop2.base.Kernel</span></tt></a></p>
</dd></dl>

<dl class="class">
<dt id="pyop2.host.Arg">
<em class="property">class </em><tt class="descclassname">pyop2.host.</tt><tt class="descname">Arg</tt><big>(</big><em>data=None</em>, <em>map=None</em>, <em>idx=None</em>, <em>access=None</em>, <em>flatten=False</em><big>)</big><a class="headerlink" href="#pyop2.host.Arg" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyop2.base.Arg" title="pyop2.base.Arg"><tt class="xref py py-class docutils literal"><span class="pre">pyop2.base.Arg</span></tt></a></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>data</strong> &#8211; A data-carrying object, either <tt class="xref py py-class docutils literal"><span class="pre">Dat</span></tt> or class:<cite>Mat</cite></li>
<li><strong>map</strong> &#8211; A <tt class="xref py py-class docutils literal"><span class="pre">Map</span></tt> to access this <a class="reference internal" href="#pyop2.host.Arg" title="pyop2.host.Arg"><tt class="xref py py-class docutils literal"><span class="pre">Arg</span></tt></a> or the default
if the identity map is to be used.</li>
<li><strong>idx</strong> &#8211; An index into the <tt class="xref py py-class docutils literal"><span class="pre">Map</span></tt>: an <tt class="xref py py-class docutils literal"><span class="pre">IterationIndex</span></tt>
when using an iteration space, an <tt class="xref py py-class docutils literal"><span class="pre">int</span></tt> to use a
given component of the mapping or the default to use all
components of the mapping.</li>
<li><strong>access</strong> &#8211; An access descriptor of type <tt class="xref py py-class docutils literal"><span class="pre">Access</span></tt></li>
<li><strong>flatten</strong> &#8211; Treat the data dimensions of this <a class="reference internal" href="#pyop2.host.Arg" title="pyop2.host.Arg"><tt class="xref py py-class docutils literal"><span class="pre">Arg</span></tt></a> as flat
s.t. the kernel is passed a flat vector of length
<tt class="docutils literal"><span class="pre">map.arity</span> <span class="pre">*</span> <span class="pre">data.dataset.cdim</span></tt>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Checks that:</p>
<ol class="arabic simple">
<li>the maps used are initialized i.e. have mapping data associated, and</li>
<li>the to Set of the map used to access it matches the Set it is
defined on.</li>
</ol>
<p>A <tt class="xref py py-class docutils literal"><span class="pre">MapValueError</span></tt> is raised if these conditions are not met.</p>
<dl class="method">
<dt id="pyop2.host.Arg.c_arg_name">
<tt class="descname">c_arg_name</tt><big>(</big><em>i=0</em>, <em>j=None</em><big>)</big><a class="headerlink" href="#pyop2.host.Arg.c_arg_name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyop2.host.Arg.c_vec_name">
<tt class="descname">c_vec_name</tt><big>(</big><big>)</big><a class="headerlink" href="#pyop2.host.Arg.c_vec_name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyop2.host.Arg.c_map_name">
<tt class="descname">c_map_name</tt><big>(</big><em>i</em>, <em>j</em><big>)</big><a class="headerlink" href="#pyop2.host.Arg.c_map_name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyop2.host.Arg.c_offset_name">
<tt class="descname">c_offset_name</tt><big>(</big><em>i</em>, <em>j</em><big>)</big><a class="headerlink" href="#pyop2.host.Arg.c_offset_name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyop2.host.Arg.c_wrapper_arg">
<tt class="descname">c_wrapper_arg</tt><big>(</big><big>)</big><a class="headerlink" href="#pyop2.host.Arg.c_wrapper_arg" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyop2.host.Arg.c_vec_dec">
<tt class="descname">c_vec_dec</tt><big>(</big><big>)</big><a class="headerlink" href="#pyop2.host.Arg.c_vec_dec" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyop2.host.Arg.c_wrapper_dec">
<tt class="descname">c_wrapper_dec</tt><big>(</big><big>)</big><a class="headerlink" href="#pyop2.host.Arg.c_wrapper_dec" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyop2.host.Arg.c_ind_data">
<tt class="descname">c_ind_data</tt><big>(</big><em>idx</em>, <em>i</em>, <em>j=0</em><big>)</big><a class="headerlink" href="#pyop2.host.Arg.c_ind_data" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyop2.host.Arg.c_ind_data_xtr">
<tt class="descname">c_ind_data_xtr</tt><big>(</big><em>idx</em>, <em>i</em>, <em>j=0</em><big>)</big><a class="headerlink" href="#pyop2.host.Arg.c_ind_data_xtr" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyop2.host.Arg.c_kernel_arg_name">
<tt class="descname">c_kernel_arg_name</tt><big>(</big><em>i</em>, <em>j</em><big>)</big><a class="headerlink" href="#pyop2.host.Arg.c_kernel_arg_name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyop2.host.Arg.c_global_reduction_name">
<tt class="descname">c_global_reduction_name</tt><big>(</big><em>count=None</em><big>)</big><a class="headerlink" href="#pyop2.host.Arg.c_global_reduction_name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyop2.host.Arg.c_local_tensor_name">
<tt class="descname">c_local_tensor_name</tt><big>(</big><em>i</em>, <em>j</em><big>)</big><a class="headerlink" href="#pyop2.host.Arg.c_local_tensor_name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyop2.host.Arg.c_kernel_arg">
<tt class="descname">c_kernel_arg</tt><big>(</big><em>count</em>, <em>i=0</em>, <em>j=0</em>, <em>shape=(0</em>, <em>)</em><big>)</big><a class="headerlink" href="#pyop2.host.Arg.c_kernel_arg" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyop2.host.Arg.c_vec_init">
<tt class="descname">c_vec_init</tt><big>(</big><big>)</big><a class="headerlink" href="#pyop2.host.Arg.c_vec_init" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyop2.host.Arg.c_addto_scalar_field">
<tt class="descname">c_addto_scalar_field</tt><big>(</big><em>i</em>, <em>j</em>, <em>buf_name</em>, <em>extruded=None</em><big>)</big><a class="headerlink" href="#pyop2.host.Arg.c_addto_scalar_field" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyop2.host.Arg.c_addto_vector_field">
<tt class="descname">c_addto_vector_field</tt><big>(</big><em>i</em>, <em>j</em>, <em>xtr=''</em><big>)</big><a class="headerlink" href="#pyop2.host.Arg.c_addto_vector_field" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyop2.host.Arg.c_local_tensor_dec">
<tt class="descname">c_local_tensor_dec</tt><big>(</big><em>extents</em>, <em>i</em>, <em>j</em><big>)</big><a class="headerlink" href="#pyop2.host.Arg.c_local_tensor_dec" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyop2.host.Arg.c_zero_tmp">
<tt class="descname">c_zero_tmp</tt><big>(</big><em>i</em>, <em>j</em><big>)</big><a class="headerlink" href="#pyop2.host.Arg.c_zero_tmp" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyop2.host.Arg.c_add_offset_flatten">
<tt class="descname">c_add_offset_flatten</tt><big>(</big><big>)</big><a class="headerlink" href="#pyop2.host.Arg.c_add_offset_flatten" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyop2.host.Arg.c_add_offset">
<tt class="descname">c_add_offset</tt><big>(</big><big>)</big><a class="headerlink" href="#pyop2.host.Arg.c_add_offset" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyop2.host.Arg.c_intermediate_globals_decl">
<tt class="descname">c_intermediate_globals_decl</tt><big>(</big><em>count</em><big>)</big><a class="headerlink" href="#pyop2.host.Arg.c_intermediate_globals_decl" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyop2.host.Arg.c_intermediate_globals_init">
<tt class="descname">c_intermediate_globals_init</tt><big>(</big><em>count</em><big>)</big><a class="headerlink" href="#pyop2.host.Arg.c_intermediate_globals_init" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyop2.host.Arg.c_intermediate_globals_writeback">
<tt class="descname">c_intermediate_globals_writeback</tt><big>(</big><em>count</em><big>)</big><a class="headerlink" href="#pyop2.host.Arg.c_intermediate_globals_writeback" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyop2.host.Arg.c_map_decl">
<tt class="descname">c_map_decl</tt><big>(</big><big>)</big><a class="headerlink" href="#pyop2.host.Arg.c_map_decl" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyop2.host.Arg.c_map_decl_itspace">
<tt class="descname">c_map_decl_itspace</tt><big>(</big><big>)</big><a class="headerlink" href="#pyop2.host.Arg.c_map_decl_itspace" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyop2.host.Arg.c_map_init_flattened">
<tt class="descname">c_map_init_flattened</tt><big>(</big><big>)</big><a class="headerlink" href="#pyop2.host.Arg.c_map_init_flattened" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyop2.host.Arg.c_map_init">
<tt class="descname">c_map_init</tt><big>(</big><big>)</big><a class="headerlink" href="#pyop2.host.Arg.c_map_init" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyop2.host.Arg.c_map_bcs">
<tt class="descname">c_map_bcs</tt><big>(</big><em>top_bottom</em>, <em>layers</em>, <em>sign</em><big>)</big><a class="headerlink" href="#pyop2.host.Arg.c_map_bcs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyop2.host.Arg.c_add_offset_map_flatten">
<tt class="descname">c_add_offset_map_flatten</tt><big>(</big><big>)</big><a class="headerlink" href="#pyop2.host.Arg.c_add_offset_map_flatten" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyop2.host.Arg.c_add_offset_map">
<tt class="descname">c_add_offset_map</tt><big>(</big><big>)</big><a class="headerlink" href="#pyop2.host.Arg.c_add_offset_map" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyop2.host.Arg.c_offset_init">
<tt class="descname">c_offset_init</tt><big>(</big><big>)</big><a class="headerlink" href="#pyop2.host.Arg.c_offset_init" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyop2.host.Arg.c_offset_decl">
<tt class="descname">c_offset_decl</tt><big>(</big><big>)</big><a class="headerlink" href="#pyop2.host.Arg.c_offset_decl" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyop2.host.Arg.c_buffer_decl">
<tt class="descname">c_buffer_decl</tt><big>(</big><em>size</em>, <em>idx</em>, <em>buf_name</em><big>)</big><a class="headerlink" href="#pyop2.host.Arg.c_buffer_decl" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyop2.host.Arg.c_buffer_gather">
<tt class="descname">c_buffer_gather</tt><big>(</big><em>size</em>, <em>idx</em>, <em>buf_name</em><big>)</big><a class="headerlink" href="#pyop2.host.Arg.c_buffer_gather" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyop2.host.Arg.c_buffer_scatter_mm">
<tt class="descname">c_buffer_scatter_mm</tt><big>(</big><em>i</em>, <em>j</em>, <em>mxofs</em>, <em>buf_name</em>, <em>buf_scat_name</em><big>)</big><a class="headerlink" href="#pyop2.host.Arg.c_buffer_scatter_mm" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyop2.host.Arg.c_buffer_scatter_vec">
<tt class="descname">c_buffer_scatter_vec</tt><big>(</big><em>count</em>, <em>i</em>, <em>j</em>, <em>mxofs</em>, <em>buf_name</em><big>)</big><a class="headerlink" href="#pyop2.host.Arg.c_buffer_scatter_vec" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyop2.host.JITModule">
<em class="property">class </em><tt class="descclassname">pyop2.host.</tt><tt class="descname">JITModule</tt><big>(</big><em>kernel</em>, <em>itspace</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#pyop2.host.JITModule" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyop2.base.JITModule" title="pyop2.base.JITModule"><tt class="xref py py-class docutils literal"><span class="pre">pyop2.base.JITModule</span></tt></a></p>
<dl class="method">
<dt id="pyop2.host.JITModule.compile">
<tt class="descname">compile</tt><big>(</big><big>)</big><a class="headerlink" href="#pyop2.host.JITModule.compile" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyop2.host.JITModule.generate_code">
<tt class="descname">generate_code</tt><big>(</big><big>)</big><a class="headerlink" href="#pyop2.host.JITModule.generate_code" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pyop2.logger">
<span id="logger-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">logger</span></tt> Module<a class="headerlink" href="#module-pyop2.logger" title="Permalink to this headline">¶</a></h2>
<p>The PyOP2 logger, based on the Python standard library logging module.</p>
<dl class="function">
<dt id="pyop2.logger.set_log_level">
<tt class="descclassname">pyop2.logger.</tt><tt class="descname">set_log_level</tt><big>(</big><em>level</em><big>)</big><a class="headerlink" href="#pyop2.logger.set_log_level" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the log level of the PyOP2 logger.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>level</strong> &#8211; the log level. Valid values: DEBUG, INFO, WARNING, ERROR, CRITICAL</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyop2.logger.info_red">
<tt class="descclassname">pyop2.logger.</tt><tt class="descname">info_red</tt><big>(</big><em>message</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#pyop2.logger.info_red" title="Permalink to this definition">¶</a></dt>
<dd><p>Write info message in red.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>message</strong> &#8211; the message to be printed.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyop2.logger.info_green">
<tt class="descclassname">pyop2.logger.</tt><tt class="descname">info_green</tt><big>(</big><em>message</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#pyop2.logger.info_green" title="Permalink to this definition">¶</a></dt>
<dd><p>Write info message in green.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>message</strong> &#8211; the message to be printed.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyop2.logger.info_blue">
<tt class="descclassname">pyop2.logger.</tt><tt class="descname">info_blue</tt><big>(</big><em>message</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#pyop2.logger.info_blue" title="Permalink to this definition">¶</a></dt>
<dd><p>Write info message in blue.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>message</strong> &#8211; the message to be printed.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyop2.logger.log">
<tt class="descclassname">pyop2.logger.</tt><tt class="descname">log</tt><big>(</big><em>level</em>, <em>msg</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#pyop2.logger.log" title="Permalink to this definition">¶</a></dt>
<dd><p>Print &#8216;msg % args&#8217; with the severity &#8216;level&#8217;.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>level</strong> &#8211; the log level. Valid values: DEBUG, INFO, WARNING, ERROR, CRITICAL</li>
<li><strong>msg</strong> &#8211; the message</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyop2.logger.progress">
<tt class="descclassname">pyop2.logger.</tt><tt class="descname">progress</tt><big>(</big><em>*args</em>, <em>**kwds</em><big>)</big><a class="headerlink" href="#pyop2.logger.progress" title="Permalink to this definition">¶</a></dt>
<dd><p>A context manager to print a progress message.</p>
<p>The block is wrapped in <tt class="docutils literal"><span class="pre">msg...</span></tt>, <tt class="docutils literal"><span class="pre">msg...done</span></tt> log messages
with an appropriate indent (to distinguish nested message).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>level</strong> &#8211; the log level.  See <a class="reference internal" href="#pyop2.logger.log" title="pyop2.logger.log"><tt class="xref py py-func docutils literal"><span class="pre">log()</span></tt></a> for valid values</li>
<li><strong>msg</strong> &#8211; the message.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>See <a class="reference internal" href="#pyop2.logger.log" title="pyop2.logger.log"><tt class="xref py py-func docutils literal"><span class="pre">log()</span></tt></a> for more details.</p>
</dd></dl>

</div>
<div class="section" id="module-pyop2.mpi">
<span id="mpi-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">mpi</span></tt> Module<a class="headerlink" href="#module-pyop2.mpi" title="Permalink to this headline">¶</a></h2>
<p>PyOP2 MPI communicator.</p>
<dl class="function">
<dt id="pyop2.mpi.collective">
<tt class="descclassname">pyop2.mpi.</tt><tt class="descname">collective</tt><big>(</big><em>fn</em><big>)</big><a class="headerlink" href="#pyop2.mpi.collective" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="pyop2.mpi.MPIConfig">
<em class="property">class </em><tt class="descclassname">pyop2.mpi.</tt><tt class="descname">MPIConfig</tt><a class="headerlink" href="#pyop2.mpi.MPIConfig" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<dl class="attribute">
<dt id="pyop2.mpi.MPIConfig.parallel">
<tt class="descname">parallel</tt><a class="headerlink" href="#pyop2.mpi.MPIConfig.parallel" title="Permalink to this definition">¶</a></dt>
<dd><p>Are we running in parallel?</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.mpi.MPIConfig.comm">
<tt class="descname">comm</tt><a class="headerlink" href="#pyop2.mpi.MPIConfig.comm" title="Permalink to this definition">¶</a></dt>
<dd><p>The MPI Communicator used by PyOP2.</p>
</dd></dl>

<dl class="method">
<dt id="pyop2.mpi.MPIConfig.rank_zero">
<tt class="descname">rank_zero</tt><big>(</big><em>f</em><big>)</big><a class="headerlink" href="#pyop2.mpi.MPIConfig.rank_zero" title="Permalink to this definition">¶</a></dt>
<dd><p>Decorator for executing a function only on MPI rank zero.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pyop2.op2">
<span id="op2-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">op2</span></tt> Module<a class="headerlink" href="#module-pyop2.op2" title="Permalink to this headline">¶</a></h2>
<p>The PyOP2 API specification.</p>
<dl class="function">
<dt id="pyop2.op2.initialised">
<tt class="descclassname">pyop2.op2.</tt><tt class="descname">initialised</tt><big>(</big><big>)</big><a class="headerlink" href="#pyop2.op2.initialised" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether PyOP2 has been yet initialised but not yet finalised.</p>
</dd></dl>

<dl class="function">
<dt id="pyop2.op2.init">
<tt class="descclassname">pyop2.op2.</tt><tt class="descname">init</tt><big>(</big><em>**kwargs</em><big>)</big><a class="headerlink" href="#pyop2.op2.init" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialise PyOP2: select the backend and potentially other configuration
options.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>backend</strong> &#8211; Set the hardware-specific backend. Current choices are
<tt class="docutils literal"><span class="pre">&quot;sequential&quot;</span></tt>, <tt class="docutils literal"><span class="pre">&quot;openmp&quot;</span></tt>, <tt class="docutils literal"><span class="pre">&quot;opencl&quot;</span></tt>, <tt class="docutils literal"><span class="pre">&quot;cuda&quot;</span></tt>.</li>
<li><strong>debug</strong> &#8211; The level of debugging output.</li>
<li><strong>comm</strong> &#8211; The MPI communicator to use for parallel communication,
defaults to <cite>MPI_COMM_WORLD</cite></li>
<li><strong>log_level</strong> &#8211; The log level. Options: DEBUG, INFO, WARNING, ERROR, CRITICAL</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>For debugging purposes, <cite>init</cite> accepts all keyword arguments
accepted by the PyOP2 <tt class="xref py py-class docutils literal"><span class="pre">Configuration</span></tt> object, see
<tt class="xref py py-meth docutils literal"><span class="pre">Configuration.__init__()</span></tt> for details of further accepted
options.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Calling <tt class="docutils literal"><span class="pre">init</span></tt> again with a different backend raises an exception.
Changing the backend is not possible. Calling <tt class="docutils literal"><span class="pre">init</span></tt> again with the
same backend or not specifying a backend will update the configuration.
Calling <tt class="docutils literal"><span class="pre">init</span></tt> after <tt class="docutils literal"><span class="pre">exit</span></tt> has been called is an error and will
raise an exception.</p>
</div>
<p>This function is logically collective over MPI ranks, it is an
error to call it on fewer than all the ranks in MPI communicator.</p>
</dd></dl>

<dl class="function">
<dt id="pyop2.op2.exit">
<tt class="descclassname">pyop2.op2.</tt><tt class="descname">exit</tt><big>(</big><big>)</big><a class="headerlink" href="#pyop2.op2.exit" title="Permalink to this definition">¶</a></dt>
<dd><p>Exit OP2 and clean up</p>
<p>This function is logically collective over MPI ranks, it is an
error to call it on fewer than all the ranks in MPI communicator.</p>
</dd></dl>

<dl class="class">
<dt id="pyop2.op2.Kernel">
<em class="property">class </em><tt class="descclassname">pyop2.op2.</tt><tt class="descname">Kernel</tt><big>(</big><em>code</em>, <em>name</em>, <em>opts={}</em>, <em>include_dirs=</em><span class="optional">[</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#pyop2.op2.Kernel" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyop2.base.Kernel" title="pyop2.base.Kernel"><tt class="xref py py-class docutils literal"><span class="pre">pyop2.base.Kernel</span></tt></a></p>
<p>OP2 kernel type.</p>
</dd></dl>

<dl class="class">
<dt id="pyop2.op2.Set">
<em class="property">class </em><tt class="descclassname">pyop2.op2.</tt><tt class="descname">Set</tt><big>(</big><em>size=None</em>, <em>name=None</em>, <em>halo=None</em><big>)</big><a class="headerlink" href="#pyop2.op2.Set" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyop2.base.Set" title="pyop2.base.Set"><tt class="xref py py-class docutils literal"><span class="pre">pyop2.base.Set</span></tt></a></p>
<p>OP2 set.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>size</strong> (<em>integer or list of four integers.</em>) &#8211; The size of the set.</li>
<li><strong>dim</strong> (<em>integer or tuple of integers</em>) &#8211; The shape of the data associated with each element of this <tt class="docutils literal"><span class="pre">Set</span></tt>.</li>
<li><strong>name</strong> (<em>string</em>) &#8211; The name of the set (optional).</li>
<li><strong>halo</strong> &#8211; An exisiting halo to use (optional).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>When the set is employed as an iteration space in a
<a class="reference internal" href="#pyop2.op2.par_loop" title="pyop2.op2.par_loop"><tt class="xref py py-func docutils literal"><span class="pre">pyop2.op2.par_loop()</span></tt></a>, the extent of any local iteration space within
each set entry is indicated in brackets. See the example in
<a class="reference internal" href="#pyop2.op2.par_loop" title="pyop2.op2.par_loop"><tt class="xref py py-func docutils literal"><span class="pre">pyop2.op2.par_loop()</span></tt></a> for more details.</p>
<p>The size of the set can either be an integer, or a list of four
integers.  The latter case is used for running in parallel where
we distinguish between:</p>
<blockquote>
<div><ul class="simple">
<li><cite>CORE</cite> (owned and not touching halo)</li>
<li><cite>OWNED</cite> (owned, touching halo)</li>
<li><cite>EXECUTE HALO</cite> (not owned, but executed over redundantly)</li>
<li><cite>NON EXECUTE HALO</cite> (not owned, read when executing in the execute halo)</li>
</ul>
</div></blockquote>
<p>If a single integer is passed, we assume that we&#8217;re running in
serial and there is no distinction.</p>
<p>The division of set elements is:</p>
<div class="highlight-python"><pre>[0, CORE)
[CORE, OWNED)
[OWNED, EXECUTE HALO)
[EXECUTE HALO, NON EXECUTE HALO).</pre>
</div>
<p>Halo send/receive data is stored on sets in a <a class="reference internal" href="#pyop2.op2.Halo" title="pyop2.op2.Halo"><tt class="xref py py-class docutils literal"><span class="pre">Halo</span></tt></a>.</p>
</dd></dl>

<dl class="class">
<dt id="pyop2.op2.ExtrudedSet">
<em class="property">class </em><tt class="descclassname">pyop2.op2.</tt><tt class="descname">ExtrudedSet</tt><big>(</big><em>size=None</em>, <em>name=None</em>, <em>halo=None</em><big>)</big><a class="headerlink" href="#pyop2.op2.ExtrudedSet" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyop2.base.Set" title="pyop2.base.Set"><tt class="xref py py-class docutils literal"><span class="pre">pyop2.base.Set</span></tt></a></p>
<p>OP2 set.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>size</strong> (<em>integer or list of four integers.</em>) &#8211; The size of the set.</li>
<li><strong>dim</strong> (<em>integer or tuple of integers</em>) &#8211; The shape of the data associated with each element of this <tt class="docutils literal"><span class="pre">Set</span></tt>.</li>
<li><strong>name</strong> (<em>string</em>) &#8211; The name of the set (optional).</li>
<li><strong>halo</strong> &#8211; An exisiting halo to use (optional).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>When the set is employed as an iteration space in a
<a class="reference internal" href="#pyop2.op2.par_loop" title="pyop2.op2.par_loop"><tt class="xref py py-func docutils literal"><span class="pre">pyop2.op2.par_loop()</span></tt></a>, the extent of any local iteration space within
each set entry is indicated in brackets. See the example in
<a class="reference internal" href="#pyop2.op2.par_loop" title="pyop2.op2.par_loop"><tt class="xref py py-func docutils literal"><span class="pre">pyop2.op2.par_loop()</span></tt></a> for more details.</p>
<p>The size of the set can either be an integer, or a list of four
integers.  The latter case is used for running in parallel where
we distinguish between:</p>
<blockquote>
<div><ul class="simple">
<li><cite>CORE</cite> (owned and not touching halo)</li>
<li><cite>OWNED</cite> (owned, touching halo)</li>
<li><cite>EXECUTE HALO</cite> (not owned, but executed over redundantly)</li>
<li><cite>NON EXECUTE HALO</cite> (not owned, read when executing in the execute halo)</li>
</ul>
</div></blockquote>
<p>If a single integer is passed, we assume that we&#8217;re running in
serial and there is no distinction.</p>
<p>The division of set elements is:</p>
<div class="highlight-python"><pre>[0, CORE)
[CORE, OWNED)
[OWNED, EXECUTE HALO)
[EXECUTE HALO, NON EXECUTE HALO).</pre>
</div>
<p>Halo send/receive data is stored on sets in a <a class="reference internal" href="#pyop2.op2.Halo" title="pyop2.op2.Halo"><tt class="xref py py-class docutils literal"><span class="pre">Halo</span></tt></a>.</p>
</dd></dl>

<dl class="class">
<dt id="pyop2.op2.MixedSet">
<em class="property">class </em><tt class="descclassname">pyop2.op2.</tt><tt class="descname">MixedSet</tt><big>(</big><em>sets</em><big>)</big><a class="headerlink" href="#pyop2.op2.MixedSet" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyop2.base.MixedSet" title="pyop2.base.MixedSet"><tt class="xref py py-class docutils literal"><span class="pre">pyop2.base.MixedSet</span></tt></a></p>
<p>A container for a bag of <a class="reference internal" href="#pyop2.op2.Set" title="pyop2.op2.Set"><tt class="xref py py-class docutils literal"><span class="pre">Set</span></tt></a>s.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>sets</strong> (<em>iterable</em>) &#8211; Iterable of <a class="reference internal" href="#pyop2.op2.Set" title="pyop2.op2.Set"><tt class="xref py py-class docutils literal"><span class="pre">Set</span></tt></a>s or <a class="reference internal" href="#pyop2.op2.ExtrudedSet" title="pyop2.op2.ExtrudedSet"><tt class="xref py py-class docutils literal"><span class="pre">ExtrudedSet</span></tt></a>s</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="pyop2.op2.Subset">
<em class="property">class </em><tt class="descclassname">pyop2.op2.</tt><tt class="descname">Subset</tt><big>(</big><em>superset</em>, <em>indices</em><big>)</big><a class="headerlink" href="#pyop2.op2.Subset" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyop2.base.Subset" title="pyop2.base.Subset"><tt class="xref py py-class docutils literal"><span class="pre">pyop2.base.Subset</span></tt></a></p>
<p>OP2 subset.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>superset</strong> (a <a class="reference internal" href="#pyop2.op2.Set" title="pyop2.op2.Set"><tt class="xref py py-class docutils literal"><span class="pre">Set</span></tt></a> or a <a class="reference internal" href="#pyop2.op2.Subset" title="pyop2.op2.Subset"><tt class="xref py py-class docutils literal"><span class="pre">Subset</span></tt></a>.) &#8211; The superset of the subset.</li>
<li><strong>indices</strong> (<em>a list of integers, or a numpy array.</em>) &#8211; Elements of the superset that form the
subset. Duplicate values are removed when constructing the subset.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="pyop2.op2.DataSet">
<em class="property">class </em><tt class="descclassname">pyop2.op2.</tt><tt class="descname">DataSet</tt><big>(</big><em>iter_set</em>, <em>dim=1</em>, <em>name=None</em><big>)</big><a class="headerlink" href="#pyop2.op2.DataSet" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyop2.base.DataSet" title="pyop2.base.DataSet"><tt class="xref py py-class docutils literal"><span class="pre">pyop2.base.DataSet</span></tt></a></p>
<p>PyOP2 Data Set</p>
<p>Set used in the op2.Dat structures to specify the dimension of the data.</p>
</dd></dl>

<dl class="class">
<dt id="pyop2.op2.MixedDataSet">
<em class="property">class </em><tt class="descclassname">pyop2.op2.</tt><tt class="descname">MixedDataSet</tt><big>(</big><em>arg</em>, <em>dims=None</em><big>)</big><a class="headerlink" href="#pyop2.op2.MixedDataSet" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyop2.base.MixedDataSet" title="pyop2.base.MixedDataSet"><tt class="xref py py-class docutils literal"><span class="pre">pyop2.base.MixedDataSet</span></tt></a></p>
<p>A container for a bag of <a class="reference internal" href="#pyop2.op2.DataSet" title="pyop2.op2.DataSet"><tt class="xref py py-class docutils literal"><span class="pre">DataSet</span></tt></a>s.</p>
<p>Initialized either from a <a class="reference internal" href="#pyop2.op2.MixedSet" title="pyop2.op2.MixedSet"><tt class="xref py py-class docutils literal"><span class="pre">MixedSet</span></tt></a> and an iterable or iterator of
<tt class="docutils literal"><span class="pre">dims</span></tt> of corresponding length</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">mdset</span> <span class="o">=</span> <span class="n">op2</span><span class="o">.</span><span class="n">MixedDataSet</span><span class="p">(</span><span class="n">mset</span><span class="p">,</span> <span class="p">[</span><span class="n">dim1</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">dimN</span><span class="p">])</span>
</pre></div>
</div>
<p>or from a tuple of <a class="reference internal" href="#pyop2.op2.Set" title="pyop2.op2.Set"><tt class="xref py py-class docutils literal"><span class="pre">Set</span></tt></a>s and an iterable of <tt class="docutils literal"><span class="pre">dims</span></tt> of
corresponding length</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">mdset</span> <span class="o">=</span> <span class="n">op2</span><span class="o">.</span><span class="n">MixedDataSet</span><span class="p">([</span><span class="n">set1</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">setN</span><span class="p">],</span> <span class="p">[</span><span class="n">dim1</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">dimN</span><span class="p">])</span>
</pre></div>
</div>
<p>If all <tt class="docutils literal"><span class="pre">dims</span></tt> are to be the same, they can also be given as an
<tt class="xref py py-class docutils literal"><span class="pre">int</span></tt> for either of above invocations</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">mdset</span> <span class="o">=</span> <span class="n">op2</span><span class="o">.</span><span class="n">MixedDataSet</span><span class="p">(</span><span class="n">mset</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span>
<span class="n">mdset</span> <span class="o">=</span> <span class="n">op2</span><span class="o">.</span><span class="n">MixedDataSet</span><span class="p">([</span><span class="n">set1</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">setN</span><span class="p">],</span> <span class="n">dim</span><span class="p">)</span>
</pre></div>
</div>
<p>Initialized from a <a class="reference internal" href="#pyop2.op2.MixedSet" title="pyop2.op2.MixedSet"><tt class="xref py py-class docutils literal"><span class="pre">MixedSet</span></tt></a> without explicitly specifying <tt class="docutils literal"><span class="pre">dims</span></tt>
they default to 1</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">mdset</span> <span class="o">=</span> <span class="n">op2</span><span class="o">.</span><span class="n">MixedDataSet</span><span class="p">(</span><span class="n">mset</span><span class="p">)</span>
</pre></div>
</div>
<p>Initialized from an iterable or iterator of <a class="reference internal" href="#pyop2.op2.DataSet" title="pyop2.op2.DataSet"><tt class="xref py py-class docutils literal"><span class="pre">DataSet</span></tt></a>s and/or
<a class="reference internal" href="#pyop2.op2.Set" title="pyop2.op2.Set"><tt class="xref py py-class docutils literal"><span class="pre">Set</span></tt></a>s, where <a class="reference internal" href="#pyop2.op2.Set" title="pyop2.op2.Set"><tt class="xref py py-class docutils literal"><span class="pre">Set</span></tt></a>s are implicitly upcast to
<a class="reference internal" href="#pyop2.op2.DataSet" title="pyop2.op2.DataSet"><tt class="xref py py-class docutils literal"><span class="pre">DataSet</span></tt></a>s of dim 1</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">mdset</span> <span class="o">=</span> <span class="n">op2</span><span class="o">.</span><span class="n">MixedDataSet</span><span class="p">([</span><span class="n">dset1</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">dsetN</span><span class="p">])</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>arg</strong> &#8211; a <a class="reference internal" href="#pyop2.op2.MixedSet" title="pyop2.op2.MixedSet"><tt class="xref py py-class docutils literal"><span class="pre">MixedSet</span></tt></a> or an iterable or a generator
expression of <a class="reference internal" href="#pyop2.op2.Set" title="pyop2.op2.Set"><tt class="xref py py-class docutils literal"><span class="pre">Set</span></tt></a>s or <a class="reference internal" href="#pyop2.op2.DataSet" title="pyop2.op2.DataSet"><tt class="xref py py-class docutils literal"><span class="pre">DataSet</span></tt></a>s or a
mixture of both</li>
<li><strong>dims</strong> &#8211; <cite>None</cite> (the default) or an <tt class="xref py py-class docutils literal"><span class="pre">int</span></tt> or an iterable or
generator expression of <tt class="xref py py-class docutils literal"><span class="pre">int</span></tt>s, which <strong>must</strong> be
of same length as <cite>arg</cite></li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">When using generator expressions for <tt class="docutils literal"><span class="pre">arg</span></tt> or <tt class="docutils literal"><span class="pre">dims</span></tt>, these
<strong>must</strong> terminate or else will cause an infinite loop.</p>
</div>
</dd></dl>

<dl class="class">
<dt id="pyop2.op2.Halo">
<em class="property">class </em><tt class="descclassname">pyop2.op2.</tt><tt class="descname">Halo</tt><big>(</big><em>sends</em>, <em>receives</em>, <em>comm=None</em>, <em>gnn2unn=None</em><big>)</big><a class="headerlink" href="#pyop2.op2.Halo" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyop2.base.Halo" title="pyop2.base.Halo"><tt class="xref py py-class docutils literal"><span class="pre">pyop2.base.Halo</span></tt></a></p>
<p>A description of a halo associated with a <a class="reference internal" href="#pyop2.op2.Set" title="pyop2.op2.Set"><tt class="xref py py-class docutils literal"><span class="pre">Set</span></tt></a>.</p>
<p>The halo object describes which <a class="reference internal" href="#pyop2.op2.Set" title="pyop2.op2.Set"><tt class="xref py py-class docutils literal"><span class="pre">Set</span></tt></a> elements are sent
where, and which <a class="reference internal" href="#pyop2.op2.Set" title="pyop2.op2.Set"><tt class="xref py py-class docutils literal"><span class="pre">Set</span></tt></a> elements are received from where.</p>
<p>The <cite>sends</cite> should be a dict whose key is the process we want to
send to, similarly the <cite>receives</cite> should be a dict whose key is the
process we want to receive from.  The value should in each case be
a numpy array of the set elements to send to/receive from each
<cite>process</cite>.</p>
<p>The gnn2unn array is a map from process-local set element
numbering to cross-process set element numbering.  It must
correctly number all the set elements in the halo region as well
as owned elements.  Providing this array is only necessary if you
will access <a class="reference internal" href="#pyop2.op2.Mat" title="pyop2.op2.Mat"><tt class="xref py py-class docutils literal"><span class="pre">Mat</span></tt></a> objects on the <a class="reference internal" href="#pyop2.op2.Set" title="pyop2.op2.Set"><tt class="xref py py-class docutils literal"><span class="pre">Set</span></tt></a> this <cite>Halo</cite>
lives on.  Insertion into <a class="reference internal" href="#pyop2.op2.Dat" title="pyop2.op2.Dat"><tt class="xref py py-class docutils literal"><span class="pre">Dat</span></tt></a>s always uses process-local
numbering, however insertion into <a class="reference internal" href="#pyop2.op2.Mat" title="pyop2.op2.Mat"><tt class="xref py py-class docutils literal"><span class="pre">Mat</span></tt></a>s uses cross-process
numbering under the hood.</p>
</dd></dl>

<dl class="class">
<dt id="pyop2.op2.Dat">
<em class="property">class </em><tt class="descclassname">pyop2.op2.</tt><tt class="descname">Dat</tt><big>(</big><em>dataset</em>, <em>data=None</em>, <em>dtype=None</em>, <em>name=None</em>, <em>soa=None</em>, <em>uid=None</em><big>)</big><a class="headerlink" href="#pyop2.op2.Dat" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyop2.base.Dat" title="pyop2.base.Dat"><tt class="xref py py-class docutils literal"><span class="pre">pyop2.base.Dat</span></tt></a></p>
<p>OP2 vector data. A <a class="reference internal" href="#pyop2.op2.Dat" title="pyop2.op2.Dat"><tt class="xref py py-class docutils literal"><span class="pre">Dat</span></tt></a> holds values on every element of a
<a class="reference internal" href="#pyop2.op2.DataSet" title="pyop2.op2.DataSet"><tt class="xref py py-class docutils literal"><span class="pre">DataSet</span></tt></a>.</p>
<p>If a <a class="reference internal" href="#pyop2.op2.Set" title="pyop2.op2.Set"><tt class="xref py py-class docutils literal"><span class="pre">Set</span></tt></a> is passed as the <tt class="docutils literal"><span class="pre">dataset</span></tt> argument, rather
than a <a class="reference internal" href="#pyop2.op2.DataSet" title="pyop2.op2.DataSet"><tt class="xref py py-class docutils literal"><span class="pre">DataSet</span></tt></a>, the <a class="reference internal" href="#pyop2.op2.Dat" title="pyop2.op2.Dat"><tt class="xref py py-class docutils literal"><span class="pre">Dat</span></tt></a> is created with a default
<a class="reference internal" href="#pyop2.op2.DataSet" title="pyop2.op2.DataSet"><tt class="xref py py-class docutils literal"><span class="pre">DataSet</span></tt></a> dimension of 1.</p>
<p>If a <a class="reference internal" href="#pyop2.op2.Dat" title="pyop2.op2.Dat"><tt class="xref py py-class docutils literal"><span class="pre">Dat</span></tt></a> is passed as the <tt class="docutils literal"><span class="pre">dataset</span></tt> argument, a copy is
returned.</p>
<p>It is permissible to pass <cite>None</cite> as the <cite>data</cite> argument.  In this
case, allocation of the data buffer is postponed until it is
accessed.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If the data buffer is not passed in, it is implicitly
initialised to be zero.</p>
</div>
<p>When a <a class="reference internal" href="#pyop2.op2.Dat" title="pyop2.op2.Dat"><tt class="xref py py-class docutils literal"><span class="pre">Dat</span></tt></a> is passed to <a class="reference internal" href="#pyop2.op2.par_loop" title="pyop2.op2.par_loop"><tt class="xref py py-func docutils literal"><span class="pre">pyop2.op2.par_loop()</span></tt></a>, the map via
which indirection occurs and the access descriptor are passed by
calling the <a class="reference internal" href="#pyop2.op2.Dat" title="pyop2.op2.Dat"><tt class="xref py py-class docutils literal"><span class="pre">Dat</span></tt></a>. For instance, if a <a class="reference internal" href="#pyop2.op2.Dat" title="pyop2.op2.Dat"><tt class="xref py py-class docutils literal"><span class="pre">Dat</span></tt></a> named <tt class="docutils literal"><span class="pre">D</span></tt> is
to be accessed for reading via a <a class="reference internal" href="#pyop2.op2.Map" title="pyop2.op2.Map"><tt class="xref py py-class docutils literal"><span class="pre">Map</span></tt></a> named <tt class="docutils literal"><span class="pre">M</span></tt>, this is
accomplished by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">D</span><span class="p">(</span><span class="n">pyop2</span><span class="o">.</span><span class="n">READ</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="#pyop2.op2.Map" title="pyop2.op2.Map"><tt class="xref py py-class docutils literal"><span class="pre">Map</span></tt></a> through which indirection occurs can be indexed
using the index notation described in the documentation for the
<a class="reference internal" href="#pyop2.op2.Map" title="pyop2.op2.Map"><tt class="xref py py-class docutils literal"><span class="pre">Map</span></tt></a>. Direct access to a Dat is accomplished by
omitting the path argument.</p>
<p><a class="reference internal" href="#pyop2.op2.Dat" title="pyop2.op2.Dat"><tt class="xref py py-class docutils literal"><span class="pre">Dat</span></tt></a> objects support the pointwise linear algebra operations
<tt class="docutils literal"><span class="pre">+=</span></tt>, <tt class="docutils literal"><span class="pre">*=</span></tt>, <tt class="docutils literal"><span class="pre">-=</span></tt>, <tt class="docutils literal"><span class="pre">/=</span></tt>, where <tt class="docutils literal"><span class="pre">*=</span></tt> and <tt class="docutils literal"><span class="pre">/=</span></tt> also support
multiplication / division by a scalar.</p>
</dd></dl>

<dl class="class">
<dt id="pyop2.op2.MixedDat">
<em class="property">class </em><tt class="descclassname">pyop2.op2.</tt><tt class="descname">MixedDat</tt><big>(</big><em>mdset_or_dats</em><big>)</big><a class="headerlink" href="#pyop2.op2.MixedDat" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyop2.base.MixedDat" title="pyop2.base.MixedDat"><tt class="xref py py-class docutils literal"><span class="pre">pyop2.base.MixedDat</span></tt></a></p>
<p>A container for a bag of <a class="reference internal" href="#pyop2.op2.Dat" title="pyop2.op2.Dat"><tt class="xref py py-class docutils literal"><span class="pre">Dat</span></tt></a>s.</p>
<p>Initialized either from a <a class="reference internal" href="#pyop2.op2.MixedDataSet" title="pyop2.op2.MixedDataSet"><tt class="xref py py-class docutils literal"><span class="pre">MixedDataSet</span></tt></a>, a <a class="reference internal" href="#pyop2.op2.MixedSet" title="pyop2.op2.MixedSet"><tt class="xref py py-class docutils literal"><span class="pre">MixedSet</span></tt></a>, or
an iterable of <a class="reference internal" href="#pyop2.op2.DataSet" title="pyop2.op2.DataSet"><tt class="xref py py-class docutils literal"><span class="pre">DataSet</span></tt></a>s and/or <a class="reference internal" href="#pyop2.op2.Set" title="pyop2.op2.Set"><tt class="xref py py-class docutils literal"><span class="pre">Set</span></tt></a>s, where all the
<a class="reference internal" href="#pyop2.op2.Set" title="pyop2.op2.Set"><tt class="xref py py-class docutils literal"><span class="pre">Set</span></tt></a>s are implcitly upcast to <a class="reference internal" href="#pyop2.op2.DataSet" title="pyop2.op2.DataSet"><tt class="xref py py-class docutils literal"><span class="pre">DataSet</span></tt></a>s</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">mdat</span> <span class="o">=</span> <span class="n">op2</span><span class="o">.</span><span class="n">MixedDat</span><span class="p">(</span><span class="n">mdset</span><span class="p">)</span>
<span class="n">mdat</span> <span class="o">=</span> <span class="n">op2</span><span class="o">.</span><span class="n">MixedDat</span><span class="p">([</span><span class="n">dset1</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">dsetN</span><span class="p">])</span>
</pre></div>
</div>
<p>or from an iterable of <a class="reference internal" href="#pyop2.op2.Dat" title="pyop2.op2.Dat"><tt class="xref py py-class docutils literal"><span class="pre">Dat</span></tt></a>s</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">mdat</span> <span class="o">=</span> <span class="n">op2</span><span class="o">.</span><span class="n">MixedDat</span><span class="p">([</span><span class="n">dat1</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">datN</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="pyop2.op2.Mat">
<em class="property">class </em><tt class="descclassname">pyop2.op2.</tt><tt class="descname">Mat</tt><big>(</big><em>sparsity</em>, <em>dtype=None</em>, <em>name=None</em><big>)</big><a class="headerlink" href="#pyop2.op2.Mat" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyop2.base.Mat" title="pyop2.base.Mat"><tt class="xref py py-class docutils literal"><span class="pre">pyop2.base.Mat</span></tt></a></p>
<p>OP2 matrix data. A <tt class="docutils literal"><span class="pre">Mat</span></tt> is defined on a sparsity pattern and holds a value
for each element in the <a class="reference internal" href="#pyop2.op2.Sparsity" title="pyop2.op2.Sparsity"><tt class="xref py py-class docutils literal"><span class="pre">Sparsity</span></tt></a>.</p>
<p>When a <tt class="docutils literal"><span class="pre">Mat</span></tt> is passed to <a class="reference internal" href="#pyop2.op2.par_loop" title="pyop2.op2.par_loop"><tt class="xref py py-func docutils literal"><span class="pre">pyop2.op2.par_loop()</span></tt></a>, the maps via which
indirection occurs for the row and column space, and the access
descriptor are passed by <cite>calling</cite> the <tt class="docutils literal"><span class="pre">Mat</span></tt>. For instance, if a
<tt class="docutils literal"><span class="pre">Mat</span></tt> named <tt class="docutils literal"><span class="pre">A</span></tt> is to be accessed for reading via a row <a class="reference internal" href="#pyop2.op2.Map" title="pyop2.op2.Map"><tt class="xref py py-class docutils literal"><span class="pre">Map</span></tt></a>
named <tt class="docutils literal"><span class="pre">R</span></tt> and a column <a class="reference internal" href="#pyop2.op2.Map" title="pyop2.op2.Map"><tt class="xref py py-class docutils literal"><span class="pre">Map</span></tt></a> named <tt class="docutils literal"><span class="pre">C</span></tt>, this is accomplished by:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">A</span><span class="p">(</span><span class="n">pyop2</span><span class="o">.</span><span class="n">READ</span><span class="p">,</span> <span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="n">pyop2</span><span class="o">.</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">C</span><span class="p">[</span><span class="n">pyop2</span><span class="o">.</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]]))</span>
</pre></div>
</div>
<p>Notice that it is <cite>always</cite> necessary to index the indirection maps
for a <tt class="docutils literal"><span class="pre">Mat</span></tt>. See the <a class="reference internal" href="#pyop2.op2.Mat" title="pyop2.op2.Mat"><tt class="xref py py-class docutils literal"><span class="pre">Mat</span></tt></a> documentation for more
details.</p>
</dd></dl>

<dl class="class">
<dt id="pyop2.op2.Const">
<em class="property">class </em><tt class="descclassname">pyop2.op2.</tt><tt class="descname">Const</tt><big>(</big><em>dim</em>, <em>data=None</em>, <em>name=None</em>, <em>dtype=None</em><big>)</big><a class="headerlink" href="#pyop2.op2.Const" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyop2.base.Const" title="pyop2.base.Const"><tt class="xref py py-class docutils literal"><span class="pre">pyop2.base.Const</span></tt></a></p>
<p>Data that is constant for any element of any set.</p>
</dd></dl>

<dl class="class">
<dt id="pyop2.op2.Global">
<em class="property">class </em><tt class="descclassname">pyop2.op2.</tt><tt class="descname">Global</tt><big>(</big><em>dim</em>, <em>data=None</em>, <em>dtype=None</em>, <em>name=None</em><big>)</big><a class="headerlink" href="#pyop2.op2.Global" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyop2.base.Global" title="pyop2.base.Global"><tt class="xref py py-class docutils literal"><span class="pre">pyop2.base.Global</span></tt></a></p>
<p>OP2 global value.</p>
<p>When a <tt class="docutils literal"><span class="pre">Global</span></tt> is passed to a <a class="reference internal" href="#pyop2.op2.par_loop" title="pyop2.op2.par_loop"><tt class="xref py py-func docutils literal"><span class="pre">pyop2.op2.par_loop()</span></tt></a>, the access
descriptor is passed by <cite>calling</cite> the <tt class="docutils literal"><span class="pre">Global</span></tt>.  For example, if
a <tt class="docutils literal"><span class="pre">Global</span></tt> named <tt class="docutils literal"><span class="pre">G</span></tt> is to be accessed for reading, this is
accomplished by:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">G</span><span class="p">(</span><span class="n">pyop2</span><span class="o">.</span><span class="n">READ</span><span class="p">)</span>
</pre></div>
</div>
<p>It is permissible to pass <cite>None</cite> as the <cite>data</cite> argument.  In this
case, allocation of the data buffer is postponed until it is
accessed.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If the data buffer is not passed in, it is implicitly
initialised to be zero.</p>
</div>
</dd></dl>

<dl class="class">
<dt id="pyop2.op2.Map">
<em class="property">class </em><tt class="descclassname">pyop2.op2.</tt><tt class="descname">Map</tt><big>(</big><em>iterset</em>, <em>toset</em>, <em>arity</em>, <em>values=None</em>, <em>name=None</em>, <em>offset=None</em>, <em>parent=None</em>, <em>bt_masks=None</em><big>)</big><a class="headerlink" href="#pyop2.op2.Map" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyop2.base.Map" title="pyop2.base.Map"><tt class="xref py py-class docutils literal"><span class="pre">pyop2.base.Map</span></tt></a></p>
<p>OP2 map, a relation between two <a class="reference internal" href="#pyop2.op2.Set" title="pyop2.op2.Set"><tt class="xref py py-class docutils literal"><span class="pre">Set</span></tt></a> objects.</p>
<p>Each entry in the <tt class="docutils literal"><span class="pre">iterset</span></tt> maps to <tt class="docutils literal"><span class="pre">arity</span></tt> entries in the
<tt class="docutils literal"><span class="pre">toset</span></tt>. When a map is used in a <a class="reference internal" href="#pyop2.op2.par_loop" title="pyop2.op2.par_loop"><tt class="xref py py-func docutils literal"><span class="pre">pyop2.op2.par_loop()</span></tt></a>, it is
possible to use Python index notation to select an individual entry on the
right hand side of this map. There are three possibilities:</p>
<ul class="simple">
<li>No index. All <tt class="docutils literal"><span class="pre">arity</span></tt> <a class="reference internal" href="#pyop2.op2.Dat" title="pyop2.op2.Dat"><tt class="xref py py-class docutils literal"><span class="pre">Dat</span></tt></a> entries will be passed to the
kernel.</li>
<li>An integer: <tt class="docutils literal"><span class="pre">some_map[n]</span></tt>. The <tt class="docutils literal"><span class="pre">n</span></tt> th entry of the
map result will be passed to the kernel.</li>
<li>An <tt class="xref py py-class docutils literal"><span class="pre">IterationIndex</span></tt>, <tt class="docutils literal"><span class="pre">some_map[pyop2.i[n]]</span></tt>. <tt class="docutils literal"><span class="pre">n</span></tt>
will take each value from <tt class="docutils literal"><span class="pre">0</span></tt> to <tt class="docutils literal"><span class="pre">e-1</span></tt> where <tt class="docutils literal"><span class="pre">e</span></tt> is the
<tt class="docutils literal"><span class="pre">n</span></tt> th extent passed to the iteration space for this
<a class="reference internal" href="#pyop2.op2.par_loop" title="pyop2.op2.par_loop"><tt class="xref py py-func docutils literal"><span class="pre">pyop2.op2.par_loop()</span></tt></a>. See also <tt class="xref py py-data docutils literal"><span class="pre">i</span></tt>.</li>
</ul>
<p>For extruded problems (where <tt class="docutils literal"><span class="pre">iterset</span></tt> is an
<a class="reference internal" href="#pyop2.op2.ExtrudedSet" title="pyop2.op2.ExtrudedSet"><tt class="xref py py-class docutils literal"><span class="pre">ExtrudedSet</span></tt></a>) with boundary conditions applied at the top
and bottom of the domain, one needs to provide a list of which of
the <cite>arity</cite> values in each map entry correspond to values on the
bottom boundary and which correspond to the top.  This is done by
supplying two lists of indices in <cite>bt_masks</cite>, the first provides
indices for the bottom, the second for the top.</p>
</dd></dl>

<dl class="class">
<dt id="pyop2.op2.MixedMap">
<em class="property">class </em><tt class="descclassname">pyop2.op2.</tt><tt class="descname">MixedMap</tt><big>(</big><em>maps</em><big>)</big><a class="headerlink" href="#pyop2.op2.MixedMap" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyop2.base.MixedMap" title="pyop2.base.MixedMap"><tt class="xref py py-class docutils literal"><span class="pre">pyop2.base.MixedMap</span></tt></a></p>
<p>A container for a bag of <a class="reference internal" href="#pyop2.op2.Map" title="pyop2.op2.Map"><tt class="xref py py-class docutils literal"><span class="pre">Map</span></tt></a>s.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>maps</strong> (<em>iterable</em>) &#8211; Iterable of <a class="reference internal" href="#pyop2.op2.Map" title="pyop2.op2.Map"><tt class="xref py py-class docutils literal"><span class="pre">Map</span></tt></a>s</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="pyop2.op2.Sparsity">
<em class="property">class </em><tt class="descclassname">pyop2.op2.</tt><tt class="descname">Sparsity</tt><big>(</big><em>dsets</em>, <em>maps</em>, <em>name=None</em><big>)</big><a class="headerlink" href="#pyop2.op2.Sparsity" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyop2.base.Sparsity" title="pyop2.base.Sparsity"><tt class="xref py py-class docutils literal"><span class="pre">pyop2.base.Sparsity</span></tt></a></p>
<p>OP2 Sparsity, the non-zero structure a matrix derived from the union of
the outer product of pairs of <a class="reference internal" href="#pyop2.op2.Map" title="pyop2.op2.Map"><tt class="xref py py-class docutils literal"><span class="pre">Map</span></tt></a> objects.</p>
<p>Examples of constructing a Sparsity:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Sparsity</span><span class="p">(</span><span class="n">single_dset</span><span class="p">,</span> <span class="n">single_map</span><span class="p">,</span> <span class="s">&#39;mass&#39;</span><span class="p">)</span>
<span class="n">Sparsity</span><span class="p">((</span><span class="n">row_dset</span><span class="p">,</span> <span class="n">col_dset</span><span class="p">),</span> <span class="p">(</span><span class="n">single_rowmap</span><span class="p">,</span> <span class="n">single_colmap</span><span class="p">))</span>
<span class="n">Sparsity</span><span class="p">((</span><span class="n">row_dset</span><span class="p">,</span> <span class="n">col_dset</span><span class="p">),</span>
         <span class="p">[(</span><span class="n">first_rowmap</span><span class="p">,</span> <span class="n">first_colmap</span><span class="p">),</span> <span class="p">(</span><span class="n">second_rowmap</span><span class="p">,</span> <span class="n">second_colmap</span><span class="p">)])</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>dsets</strong> &#8211; <a class="reference internal" href="#pyop2.op2.DataSet" title="pyop2.op2.DataSet"><tt class="xref py py-class docutils literal"><span class="pre">DataSet</span></tt></a>s for the left and right function
spaces this <a class="reference internal" href="#pyop2.op2.Sparsity" title="pyop2.op2.Sparsity"><tt class="xref py py-class docutils literal"><span class="pre">Sparsity</span></tt></a> maps between</li>
<li><strong>maps</strong> (a pair of <a class="reference internal" href="#pyop2.op2.Map" title="pyop2.op2.Map"><tt class="xref py py-class docutils literal"><span class="pre">Map</span></tt></a>s specifying a row map and a column
map, or an iterable of pairs of <a class="reference internal" href="#pyop2.op2.Map" title="pyop2.op2.Map"><tt class="xref py py-class docutils literal"><span class="pre">Map</span></tt></a>s specifying multiple
row and column maps - if a single <a class="reference internal" href="#pyop2.op2.Map" title="pyop2.op2.Map"><tt class="xref py py-class docutils literal"><span class="pre">Map</span></tt></a> is passed, it is
used as both a row map and a column map) &#8211; <a class="reference internal" href="#pyop2.op2.Map" title="pyop2.op2.Map"><tt class="xref py py-class docutils literal"><span class="pre">Map</span></tt></a>s to build the <a class="reference internal" href="#pyop2.op2.Sparsity" title="pyop2.op2.Sparsity"><tt class="xref py py-class docutils literal"><span class="pre">Sparsity</span></tt></a> from</li>
<li><strong>name</strong> (<em>string</em>) &#8211; user-defined label (optional)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="pyop2.op2.Solver">
<em class="property">class </em><tt class="descclassname">pyop2.op2.</tt><tt class="descname">Solver</tt><big>(</big><em>parameters=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#pyop2.op2.Solver" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyop2.base.Solver" title="pyop2.base.Solver"><tt class="xref py py-class docutils literal"><span class="pre">pyop2.base.Solver</span></tt></a></p>
<p>OP2 Solver object. The <a class="reference internal" href="#pyop2.op2.Solver" title="pyop2.op2.Solver"><tt class="xref py py-class docutils literal"><span class="pre">Solver</span></tt></a> holds a set of parameters that are
passed to the underlying linear algebra library when the <tt class="docutils literal"><span class="pre">solve</span></tt> method
is called. These can either be passed as a dictionary <tt class="docutils literal"><span class="pre">parameters</span></tt> <em>or</em>
as individual keyword arguments (combining both will cause an exception).</p>
<p>Recognized parameters either as dictionary keys or keyword arguments are:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>ksp_type</strong> &#8211; the solver type (&#8216;cg&#8217;)</li>
<li><strong>pc_type</strong> &#8211; the preconditioner type (&#8216;jacobi&#8217;)</li>
<li><strong>ksp_rtol</strong> &#8211; relative solver tolerance (1e-7)</li>
<li><strong>ksp_atol</strong> &#8211; absolute solver tolerance (1e-50)</li>
<li><strong>ksp_divtol</strong> &#8211; factor by which the residual norm may exceed the
right-hand-side norm before the solve is considered to have diverged:
<tt class="docutils literal"><span class="pre">norm(r)</span> <span class="pre">&gt;=</span> <span class="pre">dtol*norm(b)</span></tt> (1e4)</li>
<li><strong>ksp_max_it</strong> &#8211; maximum number of solver iterations (10000)</li>
<li><strong>error_on_nonconvergence</strong> &#8211; abort if the solve does not converge in the
maximum number of iterations (True, if False only a warning is printed)</li>
<li><strong>ksp_monitor</strong> &#8211; print the residual norm after each iteration
(False)</li>
<li><strong>plot_convergence</strong> &#8211; plot a graph of the convergence history after the
solve has finished and save it to file (False, implies <em>ksp_monitor</em>)</li>
<li><strong>plot_prefix</strong> &#8211; filename prefix for plot files (&#8216;&#8217;)</li>
<li><strong>ksp_gmres_restart</strong> &#8211; restart period when using GMRES</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyop2.op2.par_loop">
<tt class="descclassname">pyop2.op2.</tt><tt class="descname">par_loop</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#pyop2.op2.par_loop" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="pyop2.op2.solve">
<tt class="descclassname">pyop2.op2.</tt><tt class="descname">solve</tt><big>(</big><em>A</em>, <em>x</em>, <em>b</em><big>)</big><a class="headerlink" href="#pyop2.op2.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve a matrix equation using the default <a class="reference internal" href="#pyop2.op2.Solver" title="pyop2.op2.Solver"><tt class="xref py py-class docutils literal"><span class="pre">Solver</span></tt></a></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>A</strong> &#8211; The <a class="reference internal" href="#pyop2.op2.Mat" title="pyop2.op2.Mat"><tt class="xref py py-class docutils literal"><span class="pre">Mat</span></tt></a> containing the matrix.</li>
<li><strong>x</strong> &#8211; The <a class="reference internal" href="#pyop2.op2.Dat" title="pyop2.op2.Dat"><tt class="xref py py-class docutils literal"><span class="pre">Dat</span></tt></a> to receive the solution.</li>
<li><strong>b</strong> &#8211; The <a class="reference internal" href="#pyop2.op2.Dat" title="pyop2.op2.Dat"><tt class="xref py py-class docutils literal"><span class="pre">Dat</span></tt></a> containing the RHS.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>This function is logically collective over MPI ranks, it is an
error to call it on fewer than all the ranks in MPI communicator.</p>
</dd></dl>

<dl class="function">
<dt id="pyop2.op2.set_log_level">
<tt class="descclassname">pyop2.op2.</tt><tt class="descname">set_log_level</tt><big>(</big><em>level</em><big>)</big><a class="headerlink" href="#pyop2.op2.set_log_level" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the log level of the PyOP2 logger.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>level</strong> &#8211; the log level. Valid values: DEBUG, INFO, WARNING, ERROR, CRITICAL</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="opencl-module">
<h2><tt class="xref py py-mod docutils literal"><span class="pre">opencl</span></tt> Module<a class="headerlink" href="#opencl-module" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-pyop2.openmp">
<span id="openmp-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">openmp</span></tt> Module<a class="headerlink" href="#module-pyop2.openmp" title="Permalink to this headline">¶</a></h2>
<p>OP2 OpenMP backend.</p>
<dl class="class">
<dt id="pyop2.openmp.Arg">
<em class="property">class </em><tt class="descclassname">pyop2.openmp.</tt><tt class="descname">Arg</tt><big>(</big><em>data=None</em>, <em>map=None</em>, <em>idx=None</em>, <em>access=None</em>, <em>flatten=False</em><big>)</big><a class="headerlink" href="#pyop2.openmp.Arg" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyop2.host.Arg" title="pyop2.host.Arg"><tt class="xref py py-class docutils literal"><span class="pre">pyop2.host.Arg</span></tt></a></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>data</strong> &#8211; A data-carrying object, either <tt class="xref py py-class docutils literal"><span class="pre">Dat</span></tt> or class:<cite>Mat</cite></li>
<li><strong>map</strong> &#8211; A <tt class="xref py py-class docutils literal"><span class="pre">Map</span></tt> to access this <a class="reference internal" href="#pyop2.openmp.Arg" title="pyop2.openmp.Arg"><tt class="xref py py-class docutils literal"><span class="pre">Arg</span></tt></a> or the default
if the identity map is to be used.</li>
<li><strong>idx</strong> &#8211; An index into the <tt class="xref py py-class docutils literal"><span class="pre">Map</span></tt>: an <tt class="xref py py-class docutils literal"><span class="pre">IterationIndex</span></tt>
when using an iteration space, an <tt class="xref py py-class docutils literal"><span class="pre">int</span></tt> to use a
given component of the mapping or the default to use all
components of the mapping.</li>
<li><strong>access</strong> &#8211; An access descriptor of type <tt class="xref py py-class docutils literal"><span class="pre">Access</span></tt></li>
<li><strong>flatten</strong> &#8211; Treat the data dimensions of this <a class="reference internal" href="#pyop2.openmp.Arg" title="pyop2.openmp.Arg"><tt class="xref py py-class docutils literal"><span class="pre">Arg</span></tt></a> as flat
s.t. the kernel is passed a flat vector of length
<tt class="docutils literal"><span class="pre">map.arity</span> <span class="pre">*</span> <span class="pre">data.dataset.cdim</span></tt>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Checks that:</p>
<ol class="arabic simple">
<li>the maps used are initialized i.e. have mapping data associated, and</li>
<li>the to Set of the map used to access it matches the Set it is
defined on.</li>
</ol>
<p>A <tt class="xref py py-class docutils literal"><span class="pre">MapValueError</span></tt> is raised if these conditions are not met.</p>
<dl class="method">
<dt id="pyop2.openmp.Arg.c_vec_name">
<tt class="descname">c_vec_name</tt><big>(</big><em>idx=None</em><big>)</big><a class="headerlink" href="#pyop2.openmp.Arg.c_vec_name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyop2.openmp.Arg.c_kernel_arg_name">
<tt class="descname">c_kernel_arg_name</tt><big>(</big><em>i</em>, <em>j</em>, <em>idx=None</em><big>)</big><a class="headerlink" href="#pyop2.openmp.Arg.c_kernel_arg_name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyop2.openmp.Arg.c_local_tensor_name">
<tt class="descname">c_local_tensor_name</tt><big>(</big><em>i</em>, <em>j</em><big>)</big><a class="headerlink" href="#pyop2.openmp.Arg.c_local_tensor_name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyop2.openmp.Arg.c_vec_dec">
<tt class="descname">c_vec_dec</tt><big>(</big><big>)</big><a class="headerlink" href="#pyop2.openmp.Arg.c_vec_dec" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyop2.openmp.Arg.padding">
<tt class="descname">padding</tt><big>(</big><big>)</big><a class="headerlink" href="#pyop2.openmp.Arg.padding" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyop2.openmp.Arg.c_reduction_dec">
<tt class="descname">c_reduction_dec</tt><big>(</big><big>)</big><a class="headerlink" href="#pyop2.openmp.Arg.c_reduction_dec" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyop2.openmp.Arg.c_reduction_init">
<tt class="descname">c_reduction_init</tt><big>(</big><big>)</big><a class="headerlink" href="#pyop2.openmp.Arg.c_reduction_init" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyop2.openmp.Arg.c_reduction_finalisation">
<tt class="descname">c_reduction_finalisation</tt><big>(</big><big>)</big><a class="headerlink" href="#pyop2.openmp.Arg.c_reduction_finalisation" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyop2.openmp.Arg.c_global_reduction_name">
<tt class="descname">c_global_reduction_name</tt><big>(</big><em>count=None</em><big>)</big><a class="headerlink" href="#pyop2.openmp.Arg.c_global_reduction_name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyop2.openmp.JITModule">
<em class="property">class </em><tt class="descclassname">pyop2.openmp.</tt><tt class="descname">JITModule</tt><big>(</big><em>kernel</em>, <em>itspace</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#pyop2.openmp.JITModule" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyop2.host.JITModule" title="pyop2.host.JITModule"><tt class="xref py py-class docutils literal"><span class="pre">pyop2.host.JITModule</span></tt></a></p>
<dl class="method">
<dt id="pyop2.openmp.JITModule.generate_code">
<tt class="descname">generate_code</tt><big>(</big><big>)</big><a class="headerlink" href="#pyop2.openmp.JITModule.generate_code" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyop2.openmp.JITModule.ompflag">
<tt class="descname">ompflag</tt><em class="property"> = '-fopenmp'</em><a class="headerlink" href="#pyop2.openmp.JITModule.ompflag" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyop2.openmp.JITModule.omplib">
<tt class="descname">omplib</tt><em class="property"> = 'gomp'</em><a class="headerlink" href="#pyop2.openmp.JITModule.omplib" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyop2.openmp.ParLoop">
<em class="property">class </em><tt class="descclassname">pyop2.openmp.</tt><tt class="descname">ParLoop</tt><big>(</big><em>kernel</em>, <em>itspace</em>, <em>*args</em><big>)</big><a class="headerlink" href="#pyop2.openmp.ParLoop" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyop2.device.ParLoop" title="pyop2.device.ParLoop"><tt class="xref py py-class docutils literal"><span class="pre">pyop2.device.ParLoop</span></tt></a>, <a class="reference internal" href="#pyop2.base.ParLoop" title="pyop2.base.ParLoop"><tt class="xref py py-class docutils literal"><span class="pre">pyop2.base.ParLoop</span></tt></a></p>
</dd></dl>

</div>
<div class="section" id="module-pyop2.petsc_base">
<span id="petsc-base-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">petsc_base</span></tt> Module<a class="headerlink" href="#module-pyop2.petsc_base" title="Permalink to this headline">¶</a></h2>
<p>Base classes for OP2 objects. The versions here extend those from the
<tt class="xref py py-mod docutils literal"><span class="pre">base</span></tt> module to include runtime data information which is backend
independent. Individual runtime backends should subclass these as
required to implement backend-specific features.</p>
<dl class="class">
<dt id="pyop2.petsc_base.MPIConfig">
<em class="property">class </em><tt class="descclassname">pyop2.petsc_base.</tt><tt class="descname">MPIConfig</tt><a class="headerlink" href="#pyop2.petsc_base.MPIConfig" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyop2.mpi.MPIConfig" title="pyop2.mpi.MPIConfig"><tt class="xref py py-class docutils literal"><span class="pre">pyop2.mpi.MPIConfig</span></tt></a></p>
<dl class="attribute">
<dt id="pyop2.petsc_base.MPIConfig.comm">
<tt class="descname">comm</tt><a class="headerlink" href="#pyop2.petsc_base.MPIConfig.comm" title="Permalink to this definition">¶</a></dt>
<dd><p>The MPI Communicator used by PyOP2.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyop2.petsc_base.Dat">
<em class="property">class </em><tt class="descclassname">pyop2.petsc_base.</tt><tt class="descname">Dat</tt><big>(</big><em>dataset</em>, <em>data=None</em>, <em>dtype=None</em>, <em>name=None</em>, <em>soa=None</em>, <em>uid=None</em><big>)</big><a class="headerlink" href="#pyop2.petsc_base.Dat" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyop2.base.Dat" title="pyop2.base.Dat"><tt class="xref py py-class docutils literal"><span class="pre">pyop2.base.Dat</span></tt></a></p>
<dl class="method">
<dt id="pyop2.petsc_base.Dat.vec_context">
<tt class="descname">vec_context</tt><big>(</big><em>*args</em>, <em>**kwds</em><big>)</big><a class="headerlink" href="#pyop2.petsc_base.Dat.vec_context" title="Permalink to this definition">¶</a></dt>
<dd><p>A context manager for a <tt class="xref py py-class docutils literal"><span class="pre">PETSc.Vec</span></tt> from a <a class="reference internal" href="#pyop2.petsc_base.Dat" title="pyop2.petsc_base.Dat"><tt class="xref py py-class docutils literal"><span class="pre">Dat</span></tt></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>readonly</strong> &#8211; Access the data read-only (use <tt class="xref py py-meth docutils literal"><span class="pre">Dat.data_ro()</span></tt>)
or read-write (use <tt class="xref py py-meth docutils literal"><span class="pre">Dat.data()</span></tt>). Read-write
access requires a halo update.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.petsc_base.Dat.vec">
<tt class="descname">vec</tt><a class="headerlink" href="#pyop2.petsc_base.Dat.vec" title="Permalink to this definition">¶</a></dt>
<dd><p>Context manager for a PETSc Vec appropriate for this Dat.</p>
<p>You&#8217;re allowed to modify the data you get back from this view.</p>
<p>This function is logically collective over MPI ranks, it is an
error to call it on fewer than all the ranks in MPI communicator.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.petsc_base.Dat.vec_ro">
<tt class="descname">vec_ro</tt><a class="headerlink" href="#pyop2.petsc_base.Dat.vec_ro" title="Permalink to this definition">¶</a></dt>
<dd><p>Context manager for a PETSc Vec appropriate for this Dat.</p>
<p>You&#8217;re not allowed to modify the data you get back from this view.</p>
<p>This function is logically collective over MPI ranks, it is an
error to call it on fewer than all the ranks in MPI communicator.</p>
</dd></dl>

<dl class="method">
<dt id="pyop2.petsc_base.Dat.dump">
<tt class="descname">dump</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#pyop2.petsc_base.Dat.dump" title="Permalink to this definition">¶</a></dt>
<dd><p>Dump the vector to file <tt class="docutils literal"><span class="pre">filename</span></tt> in PETSc binary format.</p>
<p>This function is logically collective over MPI ranks, it is an
error to call it on fewer than all the ranks in MPI communicator.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyop2.petsc_base.MixedDat">
<em class="property">class </em><tt class="descclassname">pyop2.petsc_base.</tt><tt class="descname">MixedDat</tt><big>(</big><em>mdset_or_dats</em><big>)</big><a class="headerlink" href="#pyop2.petsc_base.MixedDat" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyop2.base.MixedDat" title="pyop2.base.MixedDat"><tt class="xref py py-class docutils literal"><span class="pre">pyop2.base.MixedDat</span></tt></a></p>
<dl class="method">
<dt id="pyop2.petsc_base.MixedDat.vecscatter">
<tt class="descname">vecscatter</tt><big>(</big><em>*args</em>, <em>**kwds</em><big>)</big><a class="headerlink" href="#pyop2.petsc_base.MixedDat.vecscatter" title="Permalink to this definition">¶</a></dt>
<dd><p>A context manager scattering the arrays of all components of this
<a class="reference internal" href="#pyop2.petsc_base.MixedDat" title="pyop2.petsc_base.MixedDat"><tt class="xref py py-class docutils literal"><span class="pre">MixedDat</span></tt></a> into a contiguous <tt class="xref py py-class docutils literal"><span class="pre">PETSc.Vec</span></tt> and reverse
scattering to the original arrays when exiting the context.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>readonly</strong> &#8211; Access the data read-only (use <tt class="xref py py-meth docutils literal"><span class="pre">Dat.data_ro()</span></tt>)
or read-write (use <tt class="xref py py-meth docutils literal"><span class="pre">Dat.data()</span></tt>). Read-write
access requires a halo update.</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The <tt class="xref py py-class docutils literal"><span class="pre">Vec</span></tt> obtained from this context is in
the correct order to be left multiplied by a compatible
<tt class="xref py py-class docutils literal"><span class="pre">MixedMat</span></tt>.  In parallel it is <em>not</em> just a
concatenation of the underlying <a class="reference internal" href="#pyop2.petsc_base.Dat" title="pyop2.petsc_base.Dat"><tt class="xref py py-class docutils literal"><span class="pre">Dat</span></tt></a>s.</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.petsc_base.MixedDat.vec">
<tt class="descname">vec</tt><a class="headerlink" href="#pyop2.petsc_base.MixedDat.vec" title="Permalink to this definition">¶</a></dt>
<dd><p>Context manager for a PETSc Vec appropriate for this Dat.</p>
<p>You&#8217;re allowed to modify the data you get back from this view.</p>
<p>This function is logically collective over MPI ranks, it is an
error to call it on fewer than all the ranks in MPI communicator.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.petsc_base.MixedDat.vec_ro">
<tt class="descname">vec_ro</tt><a class="headerlink" href="#pyop2.petsc_base.MixedDat.vec_ro" title="Permalink to this definition">¶</a></dt>
<dd><p>Context manager for a PETSc Vec appropriate for this Dat.</p>
<p>You&#8217;re not allowed to modify the data you get back from this view.</p>
<p>This function is logically collective over MPI ranks, it is an
error to call it on fewer than all the ranks in MPI communicator.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyop2.petsc_base.Mat">
<em class="property">class </em><tt class="descclassname">pyop2.petsc_base.</tt><tt class="descname">Mat</tt><big>(</big><em>sparsity</em>, <em>dtype=None</em>, <em>name=None</em><big>)</big><a class="headerlink" href="#pyop2.petsc_base.Mat" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyop2.base.Mat" title="pyop2.base.Mat"><tt class="xref py py-class docutils literal"><span class="pre">pyop2.base.Mat</span></tt></a>, <a class="reference internal" href="#pyop2.versioning.CopyOnWrite" title="pyop2.versioning.CopyOnWrite"><tt class="xref py py-class docutils literal"><span class="pre">pyop2.versioning.CopyOnWrite</span></tt></a></p>
<p>OP2 matrix data. A Mat is defined on a sparsity pattern and holds a value
for each element in the <tt class="xref py py-class docutils literal"><span class="pre">Sparsity</span></tt>.</p>
<dl class="method">
<dt id="pyop2.petsc_base.Mat.dump">
<tt class="descname">dump</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#pyop2.petsc_base.Mat.dump" title="Permalink to this definition">¶</a></dt>
<dd><p>Dump the matrix to file <tt class="docutils literal"><span class="pre">filename</span></tt> in PETSc binary format.</p>
<p>This function is logically collective over MPI ranks, it is an
error to call it on fewer than all the ranks in MPI communicator.</p>
</dd></dl>

<dl class="method">
<dt id="pyop2.petsc_base.Mat.zero">
<tt class="descname">zero</tt><big>(</big><big>)</big><a class="headerlink" href="#pyop2.petsc_base.Mat.zero" title="Permalink to this definition">¶</a></dt>
<dd><p>Zero the matrix.</p>
<p>This function is logically collective over MPI ranks, it is an
error to call it on fewer than all the ranks in MPI communicator.</p>
</dd></dl>

<dl class="method">
<dt id="pyop2.petsc_base.Mat.zero_rows">
<tt class="descname">zero_rows</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#pyop2.petsc_base.Mat.zero_rows" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyop2.petsc_base.Mat.set_diagonal">
<tt class="descname">set_diagonal</tt><big>(</big><em>vec</em><big>)</big><a class="headerlink" href="#pyop2.petsc_base.Mat.set_diagonal" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a vector to the diagonal of the matrix.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Params vec:</th><td class="field-body">vector to add (<a class="reference internal" href="#pyop2.petsc_base.Dat" title="pyop2.petsc_base.Dat"><tt class="xref py py-class docutils literal"><span class="pre">Dat</span></tt></a> or <tt class="xref py py-class docutils literal"><span class="pre">PETsc.Vec</span></tt>)</td>
</tr>
</tbody>
</table>
<p>This function is logically collective over MPI ranks, it is an
error to call it on fewer than all the ranks in MPI communicator.</p>
</dd></dl>

<dl class="method">
<dt id="pyop2.petsc_base.Mat.inc_local_diagonal_entries">
<tt class="descname">inc_local_diagonal_entries</tt><big>(</big><em>rows</em>, <em>diag_val=1.0</em><big>)</big><a class="headerlink" href="#pyop2.petsc_base.Mat.inc_local_diagonal_entries" title="Permalink to this definition">¶</a></dt>
<dd><p>Increment the diagonal entry in <tt class="docutils literal"><span class="pre">rows</span></tt> by a particular value.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>rows</strong> &#8211; a <tt class="xref py py-class docutils literal"><span class="pre">Subset</span></tt> or an iterable.</li>
<li><strong>diag_val</strong> &#8211; the value to add</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>The indices in <tt class="docutils literal"><span class="pre">rows</span></tt> should index the process-local rows of
the matrix (no mapping to global indexes is applied).</p>
<p>The diagonal entries corresponding to the complement of rows
are incremented by zero.</p>
<p>This function is logically collective over MPI ranks, it is an
error to call it on fewer than all the ranks in MPI communicator.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.petsc_base.Mat.blocks">
<tt class="descname">blocks</tt><a class="headerlink" href="#pyop2.petsc_base.Mat.blocks" title="Permalink to this definition">¶</a></dt>
<dd><p>2-dimensional array of matrix blocks.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.petsc_base.Mat.array">
<tt class="descname">array</tt><a class="headerlink" href="#pyop2.petsc_base.Mat.array" title="Permalink to this definition">¶</a></dt>
<dd><p>Array of non-zero values.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.petsc_base.Mat.values">
<tt class="descname">values</tt><a class="headerlink" href="#pyop2.petsc_base.Mat.values" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyop2.petsc_base.Mat.handle">
<tt class="descname">handle</tt><a class="headerlink" href="#pyop2.petsc_base.Mat.handle" title="Permalink to this definition">¶</a></dt>
<dd><p>Petsc4py Mat holding matrix data.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyop2.petsc_base.Solver">
<em class="property">class </em><tt class="descclassname">pyop2.petsc_base.</tt><tt class="descname">Solver</tt><big>(</big><em>parameters=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#pyop2.petsc_base.Solver" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyop2.base.Solver" title="pyop2.base.Solver"><tt class="xref py py-class docutils literal"><span class="pre">pyop2.base.Solver</span></tt></a>, <tt class="xref py py-class docutils literal"><span class="pre">petsc4py.PETSc.KSP</span></tt></p>
</dd></dl>

</div>
<div class="section" id="module-pyop2.plan">
<span id="plan-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">plan</span></tt> Module<a class="headerlink" href="#module-pyop2.plan" title="Permalink to this headline">¶</a></h2>
<p>Cython implementation of the Plan construction.</p>
<dl class="class">
<dt id="pyop2.plan.Plan">
<em class="property">class </em><tt class="descclassname">pyop2.plan.</tt><tt class="descname">Plan</tt><a class="headerlink" href="#pyop2.plan.Plan" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyop2.caching.Cached" title="pyop2.caching.Cached"><tt class="xref py py-class docutils literal"><span class="pre">pyop2.caching.Cached</span></tt></a>, <tt class="xref py py-class docutils literal"><span class="pre">pyop2.plan._Plan</span></tt></p>
</dd></dl>

</div>
<div class="section" id="module-pyop2.profiling">
<span id="profiling-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">profiling</span></tt> Module<a class="headerlink" href="#module-pyop2.profiling" title="Permalink to this headline">¶</a></h2>
<p>Profiling classes/functions.</p>
<dl class="class">
<dt id="pyop2.profiling.Timer">
<em class="property">class </em><tt class="descclassname">pyop2.profiling.</tt><tt class="descname">Timer</tt><big>(</big><em>name=None</em>, <em>timer=&lt;built-in function time&gt;</em><big>)</big><a class="headerlink" href="#pyop2.profiling.Timer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Generic timer class.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> &#8211; The name of the timer, used as unique identifier.</li>
<li><strong>timer</strong> &#8211; The timer function to use. Takes no parameters and returns
the current time. Defaults to time.time.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="pyop2.profiling.Timer.start">
<tt class="descname">start</tt><big>(</big><big>)</big><a class="headerlink" href="#pyop2.profiling.Timer.start" title="Permalink to this definition">¶</a></dt>
<dd><p>Start the timer.</p>
</dd></dl>

<dl class="method">
<dt id="pyop2.profiling.Timer.stop">
<tt class="descname">stop</tt><big>(</big><big>)</big><a class="headerlink" href="#pyop2.profiling.Timer.stop" title="Permalink to this definition">¶</a></dt>
<dd><p>Stop the timer.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.profiling.Timer.name">
<tt class="descname">name</tt><a class="headerlink" href="#pyop2.profiling.Timer.name" title="Permalink to this definition">¶</a></dt>
<dd><p>Name of the timer.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.profiling.Timer.elapsed">
<tt class="descname">elapsed</tt><a class="headerlink" href="#pyop2.profiling.Timer.elapsed" title="Permalink to this definition">¶</a></dt>
<dd><p>Elapsed time for the currently running timer.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.profiling.Timer.ncalls">
<tt class="descname">ncalls</tt><a class="headerlink" href="#pyop2.profiling.Timer.ncalls" title="Permalink to this definition">¶</a></dt>
<dd><p>Total number of recorded events.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.profiling.Timer.total">
<tt class="descname">total</tt><a class="headerlink" href="#pyop2.profiling.Timer.total" title="Permalink to this definition">¶</a></dt>
<dd><p>Total time spent for all recorded events.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyop2.profiling.Timer.average">
<tt class="descname">average</tt><a class="headerlink" href="#pyop2.profiling.Timer.average" title="Permalink to this definition">¶</a></dt>
<dd><p>Average time spent per recorded event.</p>
</dd></dl>

<dl class="classmethod">
<dt id="pyop2.profiling.Timer.summary">
<em class="property">classmethod </em><tt class="descname">summary</tt><big>(</big><em>filename=None</em><big>)</big><a class="headerlink" href="#pyop2.profiling.Timer.summary" title="Permalink to this definition">¶</a></dt>
<dd><p>Print a summary table for all timers or write CSV to filename.</p>
</dd></dl>

<dl class="classmethod">
<dt id="pyop2.profiling.Timer.get_timers">
<em class="property">classmethod </em><tt class="descname">get_timers</tt><big>(</big><big>)</big><a class="headerlink" href="#pyop2.profiling.Timer.get_timers" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a dict containing all Timers.</p>
</dd></dl>

<dl class="classmethod">
<dt id="pyop2.profiling.Timer.reset">
<em class="property">classmethod </em><tt class="descname">reset</tt><big>(</big><big>)</big><a class="headerlink" href="#pyop2.profiling.Timer.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>Clear all timer information previously recorded.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyop2.profiling.profile">
<em class="property">class </em><tt class="descclassname">pyop2.profiling.</tt><tt class="descname">profile</tt><big>(</big><em>name=None</em>, <em>timer=&lt;built-in function time&gt;</em><big>)</big><a class="headerlink" href="#pyop2.profiling.profile" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyop2.profiling.Timer" title="pyop2.profiling.Timer"><tt class="xref py py-class docutils literal"><span class="pre">pyop2.profiling.Timer</span></tt></a></p>
<p>Decorator to profile function calls.</p>
</dd></dl>

<dl class="function">
<dt id="pyop2.profiling.tic">
<tt class="descclassname">pyop2.profiling.</tt><tt class="descname">tic</tt><big>(</big><em>name</em><big>)</big><a class="headerlink" href="#pyop2.profiling.tic" title="Permalink to this definition">¶</a></dt>
<dd><p>Start a timer with the given name.</p>
</dd></dl>

<dl class="function">
<dt id="pyop2.profiling.toc">
<tt class="descclassname">pyop2.profiling.</tt><tt class="descname">toc</tt><big>(</big><em>name</em><big>)</big><a class="headerlink" href="#pyop2.profiling.toc" title="Permalink to this definition">¶</a></dt>
<dd><p>Stop a timer with the given name.</p>
</dd></dl>

<dl class="function">
<dt id="pyop2.profiling.summary">
<tt class="descclassname">pyop2.profiling.</tt><tt class="descname">summary</tt><big>(</big><em>filename=None</em><big>)</big><a class="headerlink" href="#pyop2.profiling.summary" title="Permalink to this definition">¶</a></dt>
<dd><p>Print a summary table for all timers or write CSV to filename.</p>
</dd></dl>

<dl class="function">
<dt id="pyop2.profiling.get_timers">
<tt class="descclassname">pyop2.profiling.</tt><tt class="descname">get_timers</tt><big>(</big><big>)</big><a class="headerlink" href="#pyop2.profiling.get_timers" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a dict containing all Timers.</p>
</dd></dl>

<dl class="function">
<dt id="pyop2.profiling.reset">
<tt class="descclassname">pyop2.profiling.</tt><tt class="descname">reset</tt><big>(</big><big>)</big><a class="headerlink" href="#pyop2.profiling.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>Clear all timer information previously recorded.</p>
</dd></dl>

</div>
<div class="section" id="module-pyop2.sequential">
<span id="sequential-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">sequential</span></tt> Module<a class="headerlink" href="#module-pyop2.sequential" title="Permalink to this headline">¶</a></h2>
<p>OP2 sequential backend.</p>
<dl class="class">
<dt id="pyop2.sequential.JITModule">
<em class="property">class </em><tt class="descclassname">pyop2.sequential.</tt><tt class="descname">JITModule</tt><big>(</big><em>kernel</em>, <em>itspace</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#pyop2.sequential.JITModule" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyop2.host.JITModule" title="pyop2.host.JITModule"><tt class="xref py py-class docutils literal"><span class="pre">pyop2.host.JITModule</span></tt></a></p>
</dd></dl>

<dl class="class">
<dt id="pyop2.sequential.ParLoop">
<em class="property">class </em><tt class="descclassname">pyop2.sequential.</tt><tt class="descname">ParLoop</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#pyop2.sequential.ParLoop" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyop2.base.ParLoop" title="pyop2.base.ParLoop"><tt class="xref py py-class docutils literal"><span class="pre">pyop2.base.ParLoop</span></tt></a></p>
</dd></dl>

</div>
<div class="section" id="module-pyop2.sparsity">
<span id="sparsity-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">sparsity</span></tt> Module<a class="headerlink" href="#module-pyop2.sparsity" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="pyop2.sparsity.build_sparsity">
<tt class="descclassname">pyop2.sparsity.</tt><tt class="descname">build_sparsity</tt><big>(</big><big>)</big><a class="headerlink" href="#pyop2.sparsity.build_sparsity" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-pyop2.utils">
<span id="utils-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">utils</span></tt> Module<a class="headerlink" href="#module-pyop2.utils" title="Permalink to this headline">¶</a></h2>
<p>Common utility classes/functions.</p>
<dl class="function">
<dt id="pyop2.utils.as_tuple">
<tt class="descclassname">pyop2.utils.</tt><tt class="descname">as_tuple</tt><big>(</big><em>item</em>, <em>type=None</em>, <em>length=None</em><big>)</big><a class="headerlink" href="#pyop2.utils.as_tuple" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="pyop2.utils.as_type">
<tt class="descclassname">pyop2.utils.</tt><tt class="descname">as_type</tt><big>(</big><em>obj</em>, <em>typ</em><big>)</big><a class="headerlink" href="#pyop2.utils.as_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return obj if it is of dtype typ, otherwise return a copy type-cast to
typ.</p>
</dd></dl>

<dl class="class">
<dt id="pyop2.utils.validate_base">
<em class="property">class </em><tt class="descclassname">pyop2.utils.</tt><tt class="descname">validate_base</tt><big>(</big><em>*checks</em><big>)</big><a class="headerlink" href="#pyop2.utils.validate_base" title="Permalink to this definition">¶</a></dt>
<dd><p>Decorator to validate arguments</p>
<p>Formal parameters that don&#8217;t exist in the definition of the function
being decorated as well as actual arguments not being present when
the validation is called are silently ignored.</p>
<dl class="method">
<dt id="pyop2.utils.validate_base.check_args">
<tt class="descname">check_args</tt><big>(</big><em>args</em>, <em>kwargs</em><big>)</big><a class="headerlink" href="#pyop2.utils.validate_base.check_args" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyop2.utils.validate_type">
<em class="property">class </em><tt class="descclassname">pyop2.utils.</tt><tt class="descname">validate_type</tt><big>(</big><em>*checks</em><big>)</big><a class="headerlink" href="#pyop2.utils.validate_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyop2.utils.validate_base" title="pyop2.utils.validate_base"><tt class="xref py py-class docutils literal"><span class="pre">pyop2.utils.validate_base</span></tt></a></p>
<p>Decorator to validate argument types</p>
<p>The decorator expects one or more arguments, which are 3-tuples of
(name, type, exception), where name is the argument name in the
function being decorated, type is the argument type to be validated
and exception is the exception type to be raised if validation fails.</p>
<dl class="method">
<dt id="pyop2.utils.validate_type.check_arg">
<tt class="descname">check_arg</tt><big>(</big><em>arg</em>, <em>argtype</em>, <em>exception</em><big>)</big><a class="headerlink" href="#pyop2.utils.validate_type.check_arg" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyop2.utils.validate_in">
<em class="property">class </em><tt class="descclassname">pyop2.utils.</tt><tt class="descname">validate_in</tt><big>(</big><em>*checks</em><big>)</big><a class="headerlink" href="#pyop2.utils.validate_in" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyop2.utils.validate_base" title="pyop2.utils.validate_base"><tt class="xref py py-class docutils literal"><span class="pre">pyop2.utils.validate_base</span></tt></a></p>
<p>Decorator to validate argument is in a set of valid argument values</p>
<p>The decorator expects one or more arguments, which are 3-tuples of
(name, list, exception), where name is the argument name in the
function being decorated, list is the list of valid argument values
and exception is the exception type to be raised if validation fails.</p>
<dl class="method">
<dt id="pyop2.utils.validate_in.check_arg">
<tt class="descname">check_arg</tt><big>(</big><em>arg</em>, <em>values</em>, <em>exception</em><big>)</big><a class="headerlink" href="#pyop2.utils.validate_in.check_arg" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyop2.utils.validate_range">
<em class="property">class </em><tt class="descclassname">pyop2.utils.</tt><tt class="descname">validate_range</tt><big>(</big><em>*checks</em><big>)</big><a class="headerlink" href="#pyop2.utils.validate_range" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyop2.utils.validate_base" title="pyop2.utils.validate_base"><tt class="xref py py-class docutils literal"><span class="pre">pyop2.utils.validate_base</span></tt></a></p>
<p>Decorator to validate argument value is in a given numeric range</p>
<p>The decorator expects one or more arguments, which are 3-tuples of
(name, range, exception), where name is the argument name in the
function being decorated, range is a 2-tuple defining the valid argument
range and exception is the exception type to be raised if validation
fails.</p>
<dl class="method">
<dt id="pyop2.utils.validate_range.check_arg">
<tt class="descname">check_arg</tt><big>(</big><em>arg</em>, <em>range</em>, <em>exception</em><big>)</big><a class="headerlink" href="#pyop2.utils.validate_range.check_arg" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyop2.utils.validate_dtype">
<em class="property">class </em><tt class="descclassname">pyop2.utils.</tt><tt class="descname">validate_dtype</tt><big>(</big><em>*checks</em><big>)</big><a class="headerlink" href="#pyop2.utils.validate_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyop2.utils.validate_base" title="pyop2.utils.validate_base"><tt class="xref py py-class docutils literal"><span class="pre">pyop2.utils.validate_base</span></tt></a></p>
<p>Decorator to validate argument value is in a valid Numpy dtype</p>
<p>The decorator expects one or more arguments, which are 3-tuples of
(name, _, exception), where name is the argument name in the
function being decorated, second argument is ignored and exception
is the exception type to be raised if validation fails.</p>
<dl class="method">
<dt id="pyop2.utils.validate_dtype.check_arg">
<tt class="descname">check_arg</tt><big>(</big><em>arg</em>, <em>ignored</em>, <em>exception</em><big>)</big><a class="headerlink" href="#pyop2.utils.validate_dtype.check_arg" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="pyop2.utils.verify_reshape">
<tt class="descclassname">pyop2.utils.</tt><tt class="descname">verify_reshape</tt><big>(</big><em>data</em>, <em>dtype</em>, <em>shape</em>, <em>allow_none=False</em><big>)</big><a class="headerlink" href="#pyop2.utils.verify_reshape" title="Permalink to this definition">¶</a></dt>
<dd><p>Verify data is of type dtype and try to reshaped to shape.</p>
</dd></dl>

<dl class="function">
<dt id="pyop2.utils.align">
<tt class="descclassname">pyop2.utils.</tt><tt class="descname">align</tt><big>(</big><em>bytes</em>, <em>alignment=16</em><big>)</big><a class="headerlink" href="#pyop2.utils.align" title="Permalink to this definition">¶</a></dt>
<dd><p>Align BYTES to a multiple of ALIGNMENT</p>
</dd></dl>

<dl class="function">
<dt id="pyop2.utils.flatten">
<tt class="descclassname">pyop2.utils.</tt><tt class="descname">flatten</tt><big>(</big><em>iterable</em><big>)</big><a class="headerlink" href="#pyop2.utils.flatten" title="Permalink to this definition">¶</a></dt>
<dd><p>Flatten a given nested iterable.</p>
</dd></dl>

<dl class="function">
<dt id="pyop2.utils.uniquify">
<tt class="descclassname">pyop2.utils.</tt><tt class="descname">uniquify</tt><big>(</big><em>iterable</em><big>)</big><a class="headerlink" href="#pyop2.utils.uniquify" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove duplicates in given iterable, preserving order.</p>
</dd></dl>

<dl class="function">
<dt id="pyop2.utils.parser">
<tt class="descclassname">pyop2.utils.</tt><tt class="descname">parser</tt><big>(</big><em>description=None</em>, <em>group=False</em><big>)</big><a class="headerlink" href="#pyop2.utils.parser" title="Permalink to this definition">¶</a></dt>
<dd><p>Create default argparse.ArgumentParser parser for pyop2 programs.</p>
</dd></dl>

<dl class="function">
<dt id="pyop2.utils.maybe_setflags">
<tt class="descclassname">pyop2.utils.</tt><tt class="descname">maybe_setflags</tt><big>(</big><em>array</em>, <em>write=None</em>, <em>align=None</em>, <em>uic=None</em><big>)</big><a class="headerlink" href="#pyop2.utils.maybe_setflags" title="Permalink to this definition">¶</a></dt>
<dd><p>Set flags on a numpy ary.</p>
<p>But don&#8217;t try to set the write flag if the data aren&#8217;t owned by this array.
See <cite>numpy.ndarray.setflags</cite> for details of the parameters.</p>
</dd></dl>

<dl class="function">
<dt id="pyop2.utils.parse_args">
<tt class="descclassname">pyop2.utils.</tt><tt class="descname">parse_args</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#pyop2.utils.parse_args" title="Permalink to this definition">¶</a></dt>
<dd><p>Return parsed arguments as variables for later use.</p>
<p>ARGS and KWARGS are passed into the parser instantiation.
The only recognised options are <cite>group</cite> and <cite>description</cite>.</p>
</dd></dl>

<dl class="function">
<dt id="pyop2.utils.preprocess">
<tt class="descclassname">pyop2.utils.</tt><tt class="descname">preprocess</tt><big>(</big><em>text</em>, <em>include_dirs=</em><span class="optional">[</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#pyop2.utils.preprocess" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="pyop2.utils.trim">
<tt class="descclassname">pyop2.utils.</tt><tt class="descname">trim</tt><big>(</big><em>docstring</em><big>)</big><a class="headerlink" href="#pyop2.utils.trim" title="Permalink to this definition">¶</a></dt>
<dd><p>Trim a docstring according to <a class="reference external" href="http://www.python.org/dev/peps/pep-0257/#handling-docstring-indentation">PEP 257</a>.</p>
</dd></dl>

<dl class="function">
<dt id="pyop2.utils.get_petsc_dir">
<tt class="descclassname">pyop2.utils.</tt><tt class="descname">get_petsc_dir</tt><big>(</big><big>)</big><a class="headerlink" href="#pyop2.utils.get_petsc_dir" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-pyop2.version">
<span id="version-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">version</span></tt> Module<a class="headerlink" href="#module-pyop2.version" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-pyop2.versioning">
<span id="versioning-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">versioning</span></tt> Module<a class="headerlink" href="#module-pyop2.versioning" title="Permalink to this headline">¶</a></h2>
<p>This module implements the infrastructure required for versioning
of data carrying objects (chiefly <a class="reference internal" href="#pyop2.base.Dat" title="pyop2.base.Dat"><tt class="xref py py-class docutils literal"><span class="pre">Dat</span></tt></a>). Core
functionality provided includes object version numbers and copy on
write duplicates.</p>
<p>Each data carrying object is equipped with a version number. This is
incremented every time the value of the object is changed, whether
this is by a <a class="reference internal" href="#pyop2.base.par_loop" title="pyop2.base.par_loop"><tt class="xref py py-func docutils literal"><span class="pre">par_loop()</span></tt></a> or through direct user access to a
<tt class="xref py py-attr docutils literal"><span class="pre">data</span></tt> attribute. Access to the <tt class="xref py py-attr docutils literal"><span class="pre">data_ro</span></tt> read only data attribute does
not increase the version number.</p>
<p>Data carrying objects are also equipped with a <tt class="xref py py-meth docutils literal"><span class="pre">duplicate()</span></tt>
method. From a user perspective, this is a deep copy of the original
object. In the case of <a class="reference internal" href="#pyop2.base.Dat" title="pyop2.base.Dat"><tt class="xref py py-class docutils literal"><span class="pre">Dat</span></tt></a> objects, this is implemented
as a shallow copy along with a copy on write mechanism which causes
the actual copy to occur if either the original or the copy is
modified.  The delayed copy is implemented by immediately creating a
copy <a class="reference internal" href="#pyop2.base.par_loop" title="pyop2.base.par_loop"><tt class="xref py py-func docutils literal"><span class="pre">par_loop()</span></tt></a> and, if lazy evaluation is enabled,
enqueing it. This ensures that the dependency trace will cause all
operations on which the copy depends to occur before the
copy. Conversely, the dependency of the copy <a class="reference internal" href="#pyop2.base.Dat" title="pyop2.base.Dat"><tt class="xref py py-class docutils literal"><span class="pre">Dat</span></tt></a> on the
copying loop is artificially removed. This prevents the execution of
the copy being triggered when the copy <a class="reference internal" href="#pyop2.base.Dat" title="pyop2.base.Dat"><tt class="xref py py-class docutils literal"><span class="pre">Dat</span></tt></a> is
read. Instead, writes to the original and copy <a class="reference internal" href="#pyop2.base.Dat" title="pyop2.base.Dat"><tt class="xref py py-class docutils literal"><span class="pre">Dat</span></tt></a> are
intercepted and execution of the copy <a class="reference internal" href="#pyop2.base.par_loop" title="pyop2.base.par_loop"><tt class="xref py py-func docutils literal"><span class="pre">par_loop()</span></tt></a> is forced
at that point.</p>
<dl class="class">
<dt id="pyop2.versioning.Versioned">
<em class="property">class </em><tt class="descclassname">pyop2.versioning.</tt><tt class="descname">Versioned</tt><a class="headerlink" href="#pyop2.versioning.Versioned" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Versioning class for objects with mutable data</p>
</dd></dl>

<dl class="function">
<dt id="pyop2.versioning.modifies">
<tt class="descclassname">pyop2.versioning.</tt><tt class="descname">modifies</tt><big>(</big><em>method</em><big>)</big><a class="headerlink" href="#pyop2.versioning.modifies" title="Permalink to this definition">¶</a></dt>
<dd><p>Decorator for methods that modify their instance&#8217;s data</p>
</dd></dl>

<dl class="function">
<dt id="pyop2.versioning.modifies_arguments">
<tt class="descclassname">pyop2.versioning.</tt><tt class="descname">modifies_arguments</tt><big>(</big><em>func</em><big>)</big><a class="headerlink" href="#pyop2.versioning.modifies_arguments" title="Permalink to this definition">¶</a></dt>
<dd><p>Decorator for functions that modify their arguments&#8217; data</p>
</dd></dl>

<dl class="class">
<dt id="pyop2.versioning.CopyOnWrite">
<em class="property">class </em><tt class="descclassname">pyop2.versioning.</tt><tt class="descname">CopyOnWrite</tt><a class="headerlink" href="#pyop2.versioning.CopyOnWrite" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Class that overrides the duplicate method and performs the actual copy
operation when either the original or the copy has been written.  Classes
that inherit from CopyOnWrite need to provide the methods:</p>
<dl class="docutils">
<dt>_cow_actual_copy(self, src):</dt>
<dd>Performs an actual copy of src&#8217;s data to self</dd>
<dt>_cow_shallow_copy(self):</dt>
<dd>Returns a shallow copy of the current object, e.g. the data handle
should be the same.
(optionally, otherwise the standard copy.copy() is used)</dd>
</dl>
<dl class="method">
<dt id="pyop2.versioning.CopyOnWrite.duplicate">
<tt class="descname">duplicate</tt><big>(</big><big>)</big><a class="headerlink" href="#pyop2.versioning.CopyOnWrite.duplicate" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pyop2.void">
<span id="void-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">void</span></tt> Module<a class="headerlink" href="#module-pyop2.void" title="Permalink to this headline">¶</a></h2>
<p>This module contains stub implementations of core classes which are used to
provide useful error messages if the user invokes them before calling
<a class="reference internal" href="#pyop2.op2.init" title="pyop2.op2.init"><tt class="xref py py-func docutils literal"><span class="pre">pyop2.op2.init()</span></tt></a></p>
<dl class="class">
<dt id="pyop2.void.Access">
<em class="property">class </em><tt class="descclassname">pyop2.void.</tt><tt class="descname">Access</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#pyop2.void.Access" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
</dd></dl>

<dl class="class">
<dt id="pyop2.void.Set">
<em class="property">class </em><tt class="descclassname">pyop2.void.</tt><tt class="descname">Set</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#pyop2.void.Set" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
</dd></dl>

<dl class="class">
<dt id="pyop2.void.Halo">
<em class="property">class </em><tt class="descclassname">pyop2.void.</tt><tt class="descname">Halo</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#pyop2.void.Halo" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
</dd></dl>

<dl class="class">
<dt id="pyop2.void.Kernel">
<em class="property">class </em><tt class="descclassname">pyop2.void.</tt><tt class="descname">Kernel</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#pyop2.void.Kernel" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
</dd></dl>

<dl class="class">
<dt id="pyop2.void.Dat">
<em class="property">class </em><tt class="descclassname">pyop2.void.</tt><tt class="descname">Dat</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#pyop2.void.Dat" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
</dd></dl>

<dl class="class">
<dt id="pyop2.void.Mat">
<em class="property">class </em><tt class="descclassname">pyop2.void.</tt><tt class="descname">Mat</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#pyop2.void.Mat" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
</dd></dl>

<dl class="class">
<dt id="pyop2.void.Const">
<em class="property">class </em><tt class="descclassname">pyop2.void.</tt><tt class="descname">Const</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#pyop2.void.Const" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
</dd></dl>

<dl class="class">
<dt id="pyop2.void.Global">
<em class="property">class </em><tt class="descclassname">pyop2.void.</tt><tt class="descname">Global</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#pyop2.void.Global" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
</dd></dl>

<dl class="class">
<dt id="pyop2.void.Map">
<em class="property">class </em><tt class="descclassname">pyop2.void.</tt><tt class="descname">Map</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#pyop2.void.Map" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
</dd></dl>

<dl class="class">
<dt id="pyop2.void.Sparsity">
<em class="property">class </em><tt class="descclassname">pyop2.void.</tt><tt class="descname">Sparsity</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#pyop2.void.Sparsity" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
</dd></dl>

<dl class="class">
<dt id="pyop2.void.Solver">
<em class="property">class </em><tt class="descclassname">pyop2.void.</tt><tt class="descname">Solver</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#pyop2.void.Solver" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
</dd></dl>

<dl class="function">
<dt id="pyop2.void.par_loop">
<tt class="descclassname">pyop2.void.</tt><tt class="descname">par_loop</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#pyop2.void.par_loop" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="pyop2.void.solve">
<tt class="descclassname">pyop2.void.</tt><tt class="descname">solve</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#pyop2.void.solve" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="subpackages">
<h2>Subpackages<a class="headerlink" href="#subpackages" title="Permalink to this headline">¶</a></h2>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="pyop2.ir.html">ir Package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="pyop2.ir.html#module-pyop2.ir.ast_base"><tt class="docutils literal"><span class="pre">ast_base</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="pyop2.ir.html#module-pyop2.ir.ast_optimizer"><tt class="docutils literal"><span class="pre">ast_optimizer</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="pyop2.ir.html#module-pyop2.ir.ast_plan"><tt class="docutils literal"><span class="pre">ast_plan</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="pyop2.ir.html#module-pyop2.ir.ast_vectorizer"><tt class="docutils literal"><span class="pre">ast_vectorizer</span></tt> Module</a></li>
</ul>
</li>
</ul>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">pyop2 Package</a><ul>
<li><a class="reference internal" href="#id1"><tt class="docutils literal"><span class="pre">pyop2</span></tt> Package</a></li>
<li><a class="reference internal" href="#module-pyop2.backends"><tt class="docutils literal"><span class="pre">backends</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-pyop2.base"><tt class="docutils literal"><span class="pre">base</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-pyop2.caching"><tt class="docutils literal"><span class="pre">caching</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-pyop2.computeind"><tt class="docutils literal"><span class="pre">computeind</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-pyop2.configuration"><tt class="docutils literal"><span class="pre">configuration</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-pyop2.cuda"><tt class="docutils literal"><span class="pre">cuda</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-pyop2.device"><tt class="docutils literal"><span class="pre">device</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-pyop2.exceptions"><tt class="docutils literal"><span class="pre">exceptions</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-pyop2.ffc_interface"><tt class="docutils literal"><span class="pre">ffc_interface</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-pyop2.finalised"><tt class="docutils literal"><span class="pre">finalised</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-pyop2.find_op2"><tt class="docutils literal"><span class="pre">find_op2</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-pyop2.host"><tt class="docutils literal"><span class="pre">host</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-pyop2.logger"><tt class="docutils literal"><span class="pre">logger</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-pyop2.mpi"><tt class="docutils literal"><span class="pre">mpi</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-pyop2.op2"><tt class="docutils literal"><span class="pre">op2</span></tt> Module</a></li>
<li><a class="reference internal" href="#opencl-module"><tt class="docutils literal"><span class="pre">opencl</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-pyop2.openmp"><tt class="docutils literal"><span class="pre">openmp</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-pyop2.petsc_base"><tt class="docutils literal"><span class="pre">petsc_base</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-pyop2.plan"><tt class="docutils literal"><span class="pre">plan</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-pyop2.profiling"><tt class="docutils literal"><span class="pre">profiling</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-pyop2.sequential"><tt class="docutils literal"><span class="pre">sequential</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-pyop2.sparsity"><tt class="docutils literal"><span class="pre">sparsity</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-pyop2.utils"><tt class="docutils literal"><span class="pre">utils</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-pyop2.version"><tt class="docutils literal"><span class="pre">version</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-pyop2.versioning"><tt class="docutils literal"><span class="pre">versioning</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-pyop2.void"><tt class="docutils literal"><span class="pre">void</span></tt> Module</a></li>
<li><a class="reference internal" href="#subpackages">Subpackages</a><ul>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="user.html"
                        title="previous chapter">pyop2 user documentation</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="pyop2.ir.html"
                        title="next chapter">ir Package</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/pyop2.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="pyop2.ir.html" title="ir Package"
             >next</a> |</li>
        <li class="right" >
          <a href="user.html" title="pyop2 user documentation"
             >previous</a> |</li>
        <li><a href="index.html">PyOP2 0.10.0 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012-2013, Imperial College et al.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2b1.
    </div>
  </body>
</html>